<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<META http-equiv="content-type" content="text/html; charset=iso-8859-1">
<TITLE>DVR Firmware and SDK Interface</TITLE>
<STYLE>
@media screen {
    BODY {
	background: rgb(220, 220, 220);
	margin-left: .25in;
	margin-right: .25in;
    }
}
BODY {
    font-family: Arial, sans-serif;
    font-size: 10pt;
    text-align: justify;
}
H1 {
    font-size: 18pt;
    color: rgb(255, 0, 0);
    text-align: center;
    page-break-after: avoid;
}
H2 {
    font-size: 14pt;
    color: rgb(0, 0, 255);
    margin-top: 14pt;
    page-break-after: avoid;
}
H2.int {
    font-size: 14pt;
    color: rgb(235, 27, 235);
    margin-top: 14pt;
    page-break-after: avoid;
}
H3 {
    font-size: 12pt;
    page-break-after: avoid;
}
A {
    text-decoration: none;
}
A:link {
    color: rgb(48, 96, 255);
}
A:visited {
    color: rgb(48, 96, 255);
}
A:hover { 
    background: rgb(255, 255, 0);
} 
PRE.cdef A:link {
    font-family: "Courier New", monospace;
    color: rgb(176, 0, 0);
}
PRE.cdef A:visited {
    font-family: "Courier New", monospace;
    color: rgb(176, 0, 0);
}
PRE.cdef {
    font-family: "Courier New", monospace;
    font-weight: bold;
    color: rgb(176, 0, 0);
}
PRE.cdefint A:link {
    font-family: "Courier New", monospace;
    color: rgb(235, 27, 235);
}
PRE.cdefint A:visited {
    font-family: "Courier New", monospace;
    color: rgb(235, 27, 235);
}
PRE.cdefint {
    font-family: "Courier New", monospace;
    font-weight: bold;
    color: rgb(235, 27, 235);
}
PRE.ccode A:link {
    font-family: "Courier New", monospace;
    color: rgb(40, 40, 40);
}
PRE.ccode A:visited {
    font-family: "Courier New", monospace;
    color: rgb(40, 40, 40);
}
PRE.ccode {
    font-family: "Courier New", monospace;
    font-size: 9pt;
    color: rgb(40, 40, 40);
}
PRE.text A:link {
    font-family: "Courier New", monospace;
    color: rgb(0, 0, 0);
}
PRE.text A:visited {
    font-family: "Courier New", monospace;
    color: rgb(0, 0, 0);
}
PRE.text {
    font-family: "Courier New", monospace;
    font-size: 9pt;
    color: rgb(0, 0, 0);
}
TD.int A:link {
    color: rgb(235, 27, 235);
}
TD.int A:visited {
    color: rgb(235, 27, 235);
}
DIV.descr {
   padding-left: 20pt;
}
* UL {
    list-style: disc;
}
* LI {
    margin-top: 5pt;
}
TABLE {
    font-size: 10pt;
    margin-top: 0in;
    margin-bottom: 0in;
}
TABLE.index {
    font-size: 9pt;
    margin-top: 0in;
    margin-bottom: 0in;
}
</STYLE>
</HEAD>
<A NAME=index_html_start_of_file></A>
<BODY>
<H1>Table of Contents</H1>
<A HREF="#sdvr_ui_sdk_html_start_of_file">Chapter 1. &nbsp; DVR Display SDK (sdvr_ui_sdk) (Stretch)</A>
<P CLASS="indent">
<A HREF="#sdvr_ui_sdk_html_Top__Include">1.1 &nbsp; Include</A>
<BR>
<A HREF="#sdvr_ui_sdk_html_Top__Introduction">1.2 &nbsp; Introduction</A>
<BR>
<A HREF="#sdvr_ui_sdk_html_Top__Linking___with___UI___SDK___API___in___MS___Window___Platform">1.3 &nbsp; Linking with UI SDK API in MS Window Platform</A>
<BR>
<A HREF="#sdvr_ui_sdk_html_Top__Linking___with___UI___SDK___API___in___Linux___Platform">1.4 &nbsp; Linking with UI SDK API in Linux Platform</A>
<BR>
<A HREF="#sdvr_ui_sdk_html_Top__Using___the___UI___SDK___API">1.5 &nbsp; Using the UI SDK API</A>
<BR>
<A HREF="#sdvr_ui_sdk_html_Top__Important___Restrictions">1.6 &nbsp; Important Restrictions</A>
<BR>
<A HREF="#sdvr_ui_sdk_html_Top__Example___of___a___callback___function:">1.7 &nbsp; Example of a callback function:</A>
<BR>
<A HREF="#sdvr_ui_sdk_html_Top__Types">1.8 &nbsp; Types</A>
<BR>
<A HREF="#sdvr_ui_sdk_html_Top__Defines">1.9 &nbsp; Defines</A>
<BR>
<A HREF="#sdvr_ui_sdk_html_Top__Routines">1.10 &nbsp; Routines</A>
<BR>
</P>
<BR>
<A HREF="#dvr_common_html_start_of_file">Chapter 2. &nbsp; Common Definitions Shared Between Board and PC (dvr_common)</A>
<P CLASS="indent">
<A HREF="#dvr_common_html_Top__Include">2.1 &nbsp; Include</A>
<BR>
<A HREF="#dvr_common_html_Top__Introduction">2.2 &nbsp; Introduction</A>
<BR>
<A HREF="#dvr_common_html_Top__Basic___Communication___Method___Between___the___PCIe___Card___and___the___Host___PC">2.3 &nbsp; Basic Communication Method Between the PCIe Card and the Host PC</A>
<BR>
<A HREF="#dvr_common_html_Top__Usage___Model">2.4 &nbsp; Usage Model</A>
<BR>
<A HREF="#dvr_common_html_Top__A___Convention">2.5 &nbsp; A Convention</A>
<BR>
<A HREF="#dvr_common_html_Top__Data___Communication___Between___Firmware___and___SDK">2.6 &nbsp; Data Communication Between Firmware and SDK</A>
<BR>
<A HREF="#dvr_common_html_Top__Asynchronous___Events">2.7 &nbsp; Asynchronous Events</A>
<BR>
<A HREF="#dvr_common_html_Top__Restrictions">2.8 &nbsp; Restrictions</A>
<BR>
<A HREF="#dvr_common_html_Top__Types">2.9 &nbsp; Types</A>
<BR>
<A HREF="#dvr_common_html_Top__Defines">2.10 &nbsp; Defines</A>
<BR>
<A HREF="#dvr_common_html_Top__Routines">2.11 &nbsp; Routines</A>
<BR>
</P>
<BR>
<A HREF="#dvrfw_html_start_of_file">Chapter 3. &nbsp; Common Header File Internal to the DVR Firmware (dvrfw)</A>
<P CLASS="indent">
<A HREF="#dvrfw_html_Top__Include">3.1 &nbsp; Include</A>
<BR>
<A HREF="#dvrfw_html_Top__Introduction">3.2 &nbsp; Introduction</A>
<BR>
<A HREF="#dvrfw_html_Top__Types">3.3 &nbsp; Types</A>
<BR>
<A HREF="#dvrfw_html_Top__Defines">3.4 &nbsp; Defines</A>
<BR>
<A HREF="#dvrfw_html_Top__Routines">3.5 &nbsp; Routines</A>
<BR>
</P>
<BR>
<A HREF="#sdvr_sdk_html_start_of_file">Chapter 4. &nbsp; Stretch DVR SDK (sdvr_sdk)</A>
<P CLASS="indent">
<A HREF="#sdvr_sdk_html_Top__Include">4.1 &nbsp; Include</A>
<BR>
<A HREF="#sdvr_sdk_html_Top__Introduction">4.2 &nbsp; Introduction</A>
<BR>
<A HREF="#sdvr_sdk_html_Top__Function___Groups">4.3 &nbsp; Function Groups</A>
<BR>
<A HREF="#sdvr_sdk_html_Top__Important___Notes___about___the___SDK">4.4 &nbsp; Important Notes about the SDK</A>
<BR>
<A HREF="#sdvr_sdk_html_Top__Important___Restrictions">4.5 &nbsp; Important Restrictions</A>
<BR>
<A HREF="#sdvr_sdk_html_Top__Format___of___data___buffer___exchange___between___SDK___and___DVR___Application">4.6 &nbsp; Format of data buffer exchange between SDK and DVR Application</A>
<BR>
<A HREF="#sdvr_sdk_html_Top__Using___the___SDK___API">4.7 &nbsp; Using the SDK API</A>
<BR>
<A HREF="#sdvr_sdk_html_Top__Types">4.8 &nbsp; Types</A>
<BR>
<A HREF="#sdvr_sdk_html_Top__Defines">4.9 &nbsp; Defines</A>
<BR>
<A HREF="#sdvr_sdk_html_Top__Routines">4.10 &nbsp; Routines</A>
<BR>
</P>
<BR>
<DIV style="page-break-before:always"></DIV>
<A NAME=sdvr_ui_sdk_html_start_of_file></A>

<H1>DVR Display SDK (sdvr_ui_sdk) &nbsp; (Stretch)</H1>

<CENTER>Last modified on Mar 18, 2009 at 07:18 UTC</CENTER>

<!-- last_modified : Mar 18, 2009 at 07:18 UTC -->

<!-- package : Stretch -->

<!-- short-description : DVR Display SDK (sdvr_ui_sdk) -->

<!-- contact_name :  -->

<!-- contact_email :  -->

<!-- copyright :  -->

<!-- cdoc-version : 2.4.5 -->
<!-- ANCHOR_TABLE
"Package"	"Stretch"	"sdvr_ui_sdk.html"
"Section"	"Include"	"Top__Include"
"Section"	"Introduction"	"Top__Introduction"
"Section"	"Linking with UI SDK API in MS Window Platform"	"Top__Linking___with___UI___SDK___API___in___MS___Window___Platform"
"Section"	"Linking with UI SDK API in Linux Platform"	"Top__Linking___with___UI___SDK___API___in___Linux___Platform"
"Section"	"Using the UI SDK API"	"Top__Using___the___UI___SDK___API"
"Section"	"Important Restrictions"	"Top__Important___Restrictions"
"Section"	"Example of a callback function:"	"Top__Example___of___a___callback___function___"
"Section"	"Types"	"Top__Types"
"Typedef"	"sdvr_err_ui_e"	"Types__sdvr_err_ui_e"
"Typedef"	"SDVR_ERR_UI_INIT"	"Types__SDVR_ERR_UI_INIT"
"Typedef"	"SDVR_ERR_UI_INVALID_PARAM"	"Types__SDVR_ERR_UI_INVALID_PARAM"
"Typedef"	"SDVR_ERR_UI_SET_BUFFER"	"Types__SDVR_ERR_UI_SET_BUFFER"
"Typedef"	"SDVR_ERR_UI_DRAW_YUV"	"Types__SDVR_ERR_UI_DRAW_YUV"
"Typedef"	"SDVR_ERR_UI_INVALID_YUV_BUF"	"Types__SDVR_ERR_UI_INVALID_YUV_BUF"
"Typedef"	"SDVR_ERR_UI_VIDEO_SIZE"	"Types__SDVR_ERR_UI_VIDEO_SIZE"
"Typedef"	"SDVR_ERR_UI_NO_BUFFER"	"Types__SDVR_ERR_UI_NO_BUFFER"
"Typedef"	"SDVR_ERR_UI_MAX_PREVIEW_REGIONS"	"Types__SDVR_ERR_UI_MAX_PREVIEW_REGIONS"
"Typedef"	"SDVR_ERR_UI_DRAWINFO_FULL"	"Types__SDVR_ERR_UI_DRAWINFO_FULL"
"Typedef"	"SDVR_ERR_UI_CHANNEL_NOT_START"	"Types__SDVR_ERR_UI_CHANNEL_NOT_START"
"Typedef"	"SDVR_ERR_UI_NO_INIT"	"Types__SDVR_ERR_UI_NO_INIT"
"Typedef"	"SDVR_ERR_UI_MEMORY"	"Types__SDVR_ERR_UI_MEMORY"
"Typedef"	"sdvr_ui_region_t"	"Types__sdvr_ui_region_t"
"Typedef"	"sdvr_ui_hwnd_t"	"Types__sdvr_ui_hwnd_t"
"Typedef"	"sdvr_ui_color_key_t"	"Types__sdvr_ui_color_key_t"
"Typedef"	"sdvr_ui_preview_cb"	"Types__sdvr_ui_preview_cb"
"Section"	"Defines"	"Top__Defines"
"Define"	"SDVR_UI_ERR_NONE"	"Defines__SDVR_UI_ERR_NONE"
"Define"	"SDVR_MAX_DRAW_REGIONS"	"Defines__SDVR_MAX_DRAW_REGIONS"
"Define"	"SDVR_UI_LS_SOLID"	"Defines__SDVR_UI_LS_SOLID"
"Define"	"SDVR_UI_LS_DASH"	"Defines__SDVR_UI_LS_DASH"
"Define"	"SDVR_UI_LS_DOT"	"Defines__SDVR_UI_LS_DOT"
"Define"	"EXTERN"	"Defines__EXTERN"
"Section"	"Routines"	"Top__Routines"
"Section"	"Miscellaneous"	"Routines__Miscellaneous"
"Routine"	"sdvr_rgb"	"Routines__sdvr_rgb"
"Routine"	"sdvr_ui_init"	"Routines__sdvr_ui_init"
"Routine"	"sdvr_ui_close"	"Routines__sdvr_ui_close"
"Routine"	"sdvr_ui_set_key_color"	"Routines__sdvr_ui_set_key_color"
"Routine"	"sdvr_ui_set_yuv_buffer"	"Routines__sdvr_ui_set_yuv_buffer"
"Routine"	"sdvr_ui_draw_yuv"	"Routines__sdvr_ui_draw_yuv"
"Routine"	"sdvr_ui_clear_yuv"	"Routines__sdvr_ui_clear_yuv"
"Routine"	"sdvr_ui_draw_frame"	"Routines__sdvr_ui_draw_frame"
"Routine"	"sdvr_ui_version"	"Routines__sdvr_ui_version"
"Routine"	"sdvr_ui_start_video_preview"	"Routines__sdvr_ui_start_video_preview"
"Routine"	"sdvr_ui_stop_video_preview"	"Routines__sdvr_ui_stop_video_preview"
"Routine"	"sdvr_ui_set_preview_callback"	"Routines__sdvr_ui_set_preview_callback"
"Routine"	"sdvr_ui_refresh"	"Routines__sdvr_ui_refresh"
-->

<P>
</P>


<!-- SEC_DESCRIPTION_START -->

<a name="sdvr_ui_sdk_html_Top__Include"></a>
<H2>1.1 &nbsp; Include</H2>
<PRE class="ccode">
#include "sdvr_ui_sdk.h" 
</PRE>

<a name="sdvr_ui_sdk_html_Top__Introduction"></a>
<H2>1.2 &nbsp; Introduction</H2>
In conjunction with the Stretch DVR SDK, there is a UI SDK library that lets you 
display raw video frames on the display monitor. 
<P>
This is an optional library that can be added to your Stretch DVR Application 
development environment.  If you are developing an embedded  DVR 
Application or choose to use a different 
display API, you may choose not to include this library. 
</P>
<P>
This document describes the Application Programming Interface (API) 
implemented in the UI SDK. 
</P>
<P>
The SDK provides the ability to: 
</P>
<UL>
<LI>
Display the specified raw video frame into one or more regions 
within a given window. 
</LI>
<LI>
Display a raw video frame in a rectangle within a display window. 
</LI>
<LI>
Clear the contents of a rectangle within a display window. 
</LI>
</UL>

<a name="sdvr_ui_sdk_html_Top__Linking___with___UI___SDK___API___in___MS___Window___Platform"></a>
<H2>1.3 &nbsp; Linking with UI SDK API in MS Window Platform</H2>
This library uses DirectX functions to draw directly into the 
video buffer. As result, ddraw.lib and dxguid.lib must be added to your development environment. 
(ddraw.lib and ddraw.dll are shipped as part of MSVC++ SDK.) Additionally, you need to 
add <EM>&lt;program files&gt;/Microsoft DirectX SDK (March 2008)\Lib\x86</EM> to your library path and 
<EM>&lt;program files&gt;/Microsoft DirectX SDK (March 2008)\Include</EM> to your include path. 
Lastly, make sure WIN32 is added to your C/C++ preprocessor definitions. 
<P>
You can choose to link with UI SDK API statically or dynamically. 
</P>
<P>
1) Statically Linking - You must add sdvr_sdk.lib and sdvr_ui_sdk.lib to your 
library dependecies. 
</P>
<P>
2) Dynamically Linking - To do so, you must add sdvr_ui_sdk_dll.lib 
and sdvr_sdk_dll.lib to your library dependecies. Additionally, you must 
include sdvr_ui_sdk_dll.dll and sdvr_sdk_dll.dll in the same directory as 
your DVR Application. 
</P>

<a name="sdvr_ui_sdk_html_Top__Linking___with___UI___SDK___API___in___Linux___Platform"></a>
<H2>1.4 &nbsp; Linking with UI SDK API in Linux Platform</H2>
This library requires an X Server that supports Xv extensions 
to display live video. As result, in addition to sdvr_sdk.lib and sdvr_ui_sdk.lib, 
you must include the following libraries to your  development environment: 
<P>
1) CentOS 5 - libXv-devel 
2) Ubuntau 7.10 - libxv-dev 
</P>

<a name="sdvr_ui_sdk_html_Top__Using___the___UI___SDK___API"></a>
<H2>1.5 &nbsp; Using the UI SDK API</H2>
This section provides the steps required to display raw video frames on 
the display screen. 
<UL>
<LI>
You must provide the SDK the largest video frame size that would ever be 
displayed. This size is passed as parameters to <NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_init">sdvr_ui_init</A>()</NOBR>. This function 
must be called before any of the display functions can be called and should only 
be called once within your application. 
</LI>
<LI>
The color key defines one specific color that should not 
be drawn to the  render surface. 
After initializing the UI SDK, you can specify the color key by calling 
<NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_set_key_color">sdvr_ui_set_key_color</A>()</NOBR>.  This is an optional step. The SDK uses white 
as the default color key. 
</LI>
<LI>
There are two different methods that you can choose in order to display raw 
video frames. 
</LI>
<LI>
Method 1: This method is used if you don't need to access the YUV buffers to peform any video 
analytics, save into a file, or any other operations on raw video frames. To 
start raw video display on a specific region within a window, call 
<NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_start_video_preview">sdvr_ui_start_video_preview</A>()</NOBR>. To stop raw video display, call 
<NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_stop_video_preview">sdvr_ui_stop_video_preview</A>()</NOBR>. In cases where you are interested in displaying 
the raw video frames from one channel in different regions within a preview window, 
you should call <NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_start_video_preview">sdvr_ui_start_video_preview</A>()</NOBR> multiple times for each region. 
Once <NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_start_video_preview">sdvr_ui_start_video_preview</A>()</NOBR> is called for a specific 
encoder or decoder channel, the SDK starts displaying any raw video frame received 
from the DVR board into all the regions within the given window handle. You direct 
the SDK to stop displaying raw video for each region by calling <NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_stop_video_preview">sdvr_ui_stop_video_preview</A>()</NOBR>. 
It is also possible to get notificatioin with every video frame by setting a 
preview callback. With the preview callback you can put additional graphics 
over the video, such as highlighting some regions, and so on. To set the preview 
callback call <NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_set_preview_callback">sdvr_ui_set_preview_callback</A>()</NOBR>. 
</LI>
<LI>
Method 2: This method is used if you need to have more control over displaying the video frames. 
To display YUV frames, get the YUV buffers by calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_yuv_buffer">sdvr_get_yuv_buffer</A>()</NOBR>. 
In general, you can either poll this function or wait to be called back in your 
video frame callback. After you acquire the YUV buffer, set the 
buffer by calling <NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_set_yuv_buffer">sdvr_ui_set_yuv_buffer</A>()</NOBR> for displaying. Once a YUV buffer is 
set to be displayed, you can call <NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_draw_yuv">sdvr_ui_draw_yuv</A>()</NOBR> to draw the buffer 
into a specific region within a display window. There is no need to call 
<NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_set_yuv_buffer">sdvr_ui_set_yuv_buffer</A>()</NOBR> multiple times to display the same 
video frame in different regions of the screen. 
</LI>
</UL>

<a name="sdvr_ui_sdk_html_Top__Important___Restrictions"></a>
<H2>1.6 &nbsp; Important Restrictions</H2>
Note the following restrictions when using the UI SDK. These 
restrictions, apart from those explicitly noted, are not permanent 
and will be removed in future versions of the SDK. 
<UL>
<LI>
You must call <NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_refresh">sdvr_ui_refresh</A>()</NOBR> in your application's paint message handler 
if your application can be covered by any other applications 
while there are still video frames displaying. This function only applies 
when using Method 2 for display. (See section <EM>Using the UI SDK API</EM>) 
This is a permanent restriction. 
</LI>
<LI>
The screen must not be locked while video is being displayed. Screen 
savers must not be activated while video is being displayed. Either of 
these actions can cause the display to stop refreshing. If this happens, 
the application must be shut down and restarted. 
</LI>
<LI>
There are only four display regions per channel 
when using <NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_start_video_preview">sdvr_ui_start_video_preview</A>()</NOBR> to display raw video frames. 
</LI>
<LI>
Dynamic linking of the display and board SDK libraries is only 
available in the MS Windows environment. 
</LI>
<LI>
DirectDraw acceleration is required to be enabled on your video card. 
</LI>
</UL>

<a name="sdvr_ui_sdk_html_Top__Example___of___a___callback___function___"></a>
<H2>1.7 &nbsp; Example of a callback function:</H2>
<PRE class="ccode">
  void av_frame_callback(<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A> handle, 
     <A HREF="#sdvr_sdk_html_Types__sdvr_frame_type_e">sdvr_frame_type_e</A> frame_type, <A HREF="#sdvr_sdk_html_Types__sx_bool">sx_bool</A> is_primary) 
  { 
      <A HREF="#sdvr_sdk_html_Types__sdvr_av_buffer_t">sdvr_av_buffer_t</A>  *av_buffer; 
      <A HREF="#sdvr_sdk_html_Types__sdvr_yuv_buffer_t">sdvr_yuv_buffer_t</A> *yuv_buf; 
      switch (frame_type) 
      { 
      case <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_AUDIO_ENCODED">SDVR_FRAME_AUDIO_ENCODED</A>: 
          if (<A HREF="#sdvr_sdk_html_Routines__sdvr_get_av_buffer">sdvr_get_av_buffer</A>(handle, <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_AUDIO_ENCODED">SDVR_FRAME_AUDIO_ENCODED</A>, 
                                 &amp;av_buffer) == <A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A>) 
          { 
                &lt;add the buffer to an audio queue to be processed from 
                a different thread&gt; 
                &lt;The buffer should be released from that thread when 
                you processed the audio frame.&gt; 
          } 
          break; 
      case <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_RAW_VIDEO">SDVR_FRAME_RAW_VIDEO</A>: 
          if (<A HREF="#sdvr_sdk_html_Routines__sdvr_get_yuv_buffer">sdvr_get_yuv_buffer</A>(handle, &amp;yuv_buf) == <A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A>) 
          { 
              <A HREF="#sdvr_ui_sdk_html_Types__sdvr_ui_region_t">sdvr_ui_region_t</A> ui_region; 
 
              // set the YUV buffer so that we can display it within 
              // any rectangle in any window handle. 
 
              <A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_set_yuv_buffer">sdvr_ui_set_yuv_buffer</A>(yuv_buf); 
 
              // following code checks to see where this new 
              // channel handle needs to be displayed. 
              for (int screen = 0; screen &lt; numScreens; ++screen) 
              { 
                  if (m_settings-&gt;displayChannel(screen) == handle) 
                  { 
                      <A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_draw_yuv">sdvr_ui_draw_yuv</A>(m_displayRect[screen].hWnd,&amp;m_displayRect[screen].region); 
                  } 
              } 
 
              // Once you are done displaying the frame, 
              // you must release it. 
              <A HREF="#sdvr_sdk_html_Routines__sdvr_release_yuv_buffer">sdvr_release_yuv_buffer</A>(yuv_buf); 
          } 
          break; 
      case <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_H264_IDR">SDVR_FRAME_H264_IDR</A>: 
      case <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_H264_I">SDVR_FRAME_H264_I</A>: 
      case <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_H264_P">SDVR_FRAME_H264_P</A>: 
      case <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_H264_B">SDVR_FRAME_H264_B</A>: 
      case <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_H264_SPS">SDVR_FRAME_H264_SPS</A>: 
      case <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_H264_PPS">SDVR_FRAME_H264_PPS</A>: 
      case <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_JPEG">SDVR_FRAME_JPEG</A>: 
      case <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_MPEG4_I">SDVR_FRAME_MPEG4_I</A>: 
      case <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_MPEG4_P">SDVR_FRAME_MPEG4_P</A>: 
      case <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_MPEG4_VOL">SDVR_FRAME_MPEG4_VOL</A>: 
          if (<A HREF="#sdvr_sdk_html_Routines__sdvr_get_av_buffer">sdvr_get_av_buffer</A>(handle, 
            is_primary ? <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_VIDEO_ENCODED_PRIMARY">SDVR_FRAME_VIDEO_ENCODED_PRIMARY</A> : 
            <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_VIDEO_ENCODED_SECONDARY">SDVR_FRAME_VIDEO_ENCODED_SECONDARY</A>, &amp;av_buffer) == <A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A>) 
          { 
                &lt;add the buffer to a video encoded queue to be processed 
                from a different thread.&gt; 
                &lt;The buffer should be released from that thread when 
                you processed the video frame.&gt; 
          } 
          break; 
      } 
      NOTE: Any buffer that is not retrieved(i.e. no call to the 
            "sdvr_get_xxx_buffer") will be freed by the SDK once 
            the frame queue is full. 
  } 
 
</PRE>

<!-- SEC_DESCRIPTION_CLOSE -->

<!-- SEC_TYPES_START -->

<a name="sdvr_ui_sdk_html_Top__Types"></a>
<H2>1.8 &nbsp; Types</H2>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_ui_sdk_html_Types__sdvr_err_ui_e"></a>
<PRE class="cdef">
typedef enum _sdvr_err_ui_e {
    <A name="sdvr_ui_sdk_html_Types__SDVR_ERR_UI_INIT">SDVR_ERR_UI_INIT</A> = 3000,
    <A name="sdvr_ui_sdk_html_Types__SDVR_ERR_UI_INVALID_PARAM">SDVR_ERR_UI_INVALID_PARAM</A>,
    <A name="sdvr_ui_sdk_html_Types__SDVR_ERR_UI_SET_BUFFER">SDVR_ERR_UI_SET_BUFFER</A>,
    <A name="sdvr_ui_sdk_html_Types__SDVR_ERR_UI_DRAW_YUV">SDVR_ERR_UI_DRAW_YUV</A>,
    <A name="sdvr_ui_sdk_html_Types__SDVR_ERR_UI_INVALID_YUV_BUF">SDVR_ERR_UI_INVALID_YUV_BUF</A>,
    <A name="sdvr_ui_sdk_html_Types__SDVR_ERR_UI_VIDEO_SIZE">SDVR_ERR_UI_VIDEO_SIZE</A>,
    <A name="sdvr_ui_sdk_html_Types__SDVR_ERR_UI_NO_BUFFER">SDVR_ERR_UI_NO_BUFFER</A>,
    <A name="sdvr_ui_sdk_html_Types__SDVR_ERR_UI_MAX_PREVIEW_REGIONS">SDVR_ERR_UI_MAX_PREVIEW_REGIONS</A>,
    <A name="sdvr_ui_sdk_html_Types__SDVR_ERR_UI_DRAWINFO_FULL">SDVR_ERR_UI_DRAWINFO_FULL</A>,
    <A name="sdvr_ui_sdk_html_Types__SDVR_ERR_UI_CHANNEL_NOT_START">SDVR_ERR_UI_CHANNEL_NOT_START</A>,
    <A name="sdvr_ui_sdk_html_Types__SDVR_ERR_UI_NO_INIT">SDVR_ERR_UI_NO_INIT</A>,
    <A name="sdvr_ui_sdk_html_Types__SDVR_ERR_UI_MEMORY">SDVR_ERR_UI_MEMORY</A>
} <A HREF="#sdvr_ui_sdk_html_Types__sdvr_err_ui_e">sdvr_err_ui_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
Typedef for the errors returned by the UI SDK. 
</P>
<UL>
<LI>
<A HREF="#sdvr_ui_sdk_html_Types__SDVR_ERR_UI_INIT">SDVR_ERR_UI_INIT</A> - Error code for failure to initialize the UI. 
</LI>
<LI>
<A HREF="#sdvr_ui_sdk_html_Types__SDVR_ERR_UI_INVALID_PARAM">SDVR_ERR_UI_INVALID_PARAM</A> - Error code if the any of the parameters 
passed to any of the SDVR UI function is invalid. 
</LI>
<LI>
<A HREF="#sdvr_ui_sdk_html_Types__SDVR_ERR_UI_SET_BUFFER">SDVR_ERR_UI_SET_BUFFER</A> - Error code for failure to lock the draw surface. 
</LI>
<LI>
<A HREF="#sdvr_ui_sdk_html_Types__SDVR_ERR_UI_DRAW_YUV">SDVR_ERR_UI_DRAW_YUV</A> - Error code for failure to draw the surface. 
</LI>
<LI>
<A HREF="#sdvr_ui_sdk_html_Types__SDVR_ERR_UI_INVALID_YUV_BUF">SDVR_ERR_UI_INVALID_YUV_BUF</A> - Error code if the given YUV buffer is 
not valid. 
</LI>
<LI>
<A HREF="#sdvr_ui_sdk_html_Types__SDVR_ERR_UI_VIDEO_SIZE">SDVR_ERR_UI_VIDEO_SIZE</A> - Error code if the YUV buffer size is larger 
than the maximum supported video frame size. 
</LI>
<LI>
<A HREF="#sdvr_ui_sdk_html_Types__SDVR_ERR_UI_NO_BUFFER">SDVR_ERR_UI_NO_BUFFER</A> - Error code if no buffer was set before calling 
<NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_draw_yuv">sdvr_ui_draw_yuv</A>()</NOBR>. 
</LI>
<LI>
<A HREF="#sdvr_ui_sdk_html_Types__SDVR_ERR_UI_MAX_PREVIEW_REGIONS">SDVR_ERR_UI_MAX_PREVIEW_REGIONS</A> - Error code if no more preview regions 
can be added. 
</LI>
<LI>
<A HREF="#sdvr_ui_sdk_html_Types__SDVR_ERR_UI_DRAWINFO_FULL">SDVR_ERR_UI_DRAWINFO_FULL</A> - Error code if the maximum number preview 
channel is reached. 
</LI>
<LI>
<A HREF="#sdvr_ui_sdk_html_Types__SDVR_ERR_UI_CHANNEL_NOT_START">SDVR_ERR_UI_CHANNEL_NOT_START</A> - Error code if the preview was not started 
for the specified channel handle. 
</LI>
<LI>
<A HREF="#sdvr_ui_sdk_html_Types__SDVR_ERR_UI_NO_INIT">SDVR_ERR_UI_NO_INIT</A> - Error code if <NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_init">sdvr_ui_init</A>()</NOBR> was not called prior 
calling this API. 
</LI>
<LI>
<A HREF="#sdvr_ui_sdk_html_Types__SDVR_ERR_UI_MEMORY">SDVR_ERR_UI_MEMORY</A> - Error code if failed to allocate enough memory for 
the internal data structures. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_ui_sdk_html_Types__sdvr_ui_region_t"></a>
<PRE class="cdef">
typedef struct _sdvr_ui_region_t {
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> top_left_x;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> top_left_y;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> width;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> height;
} <A HREF="#sdvr_ui_sdk_html_Types__sdvr_ui_region_t">sdvr_ui_region_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This data structure is used to define a display region. 
A display region is the area within a window in which the video frame 
is displayed. The top left corner of a window is specified by (0,0). 
Each window can include many of such regions. 
</P>
<UL>
<LI>
<STRONG>top_left_x</STRONG> - X-coordinate of the upper left corner. 
</LI>
<LI>
<STRONG>top_left_y</STRONG> - Y-coordinate of the upper left corner. 
</LI>
<LI>
<STRONG>width</STRONG> - The width of display region within the given window. 
</LI>
<LI>
<STRONG>height</STRONG> - The height of display region  within the given window. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_ui_sdk_html_Types__sdvr_ui_hwnd_t"></a>
<PRE class="cdef">
typedef HWND <A HREF="#sdvr_ui_sdk_html_Types__sdvr_ui_hwnd_t">sdvr_ui_hwnd_t</A>; 
</PRE>
<DIV CLASS="descr">
<P>
The window handle for where to display the raw video frames. In 
MS Windows environment  this is HWND. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_ui_sdk_html_Types__sdvr_ui_color_key_t"></a>
<PRE class="cdef">
typedef DWORD <A HREF="#sdvr_ui_sdk_html_Types__sdvr_ui_color_key_t">sdvr_ui_color_key_t</A>; 
</PRE>
<DIV CLASS="descr">
<P>
The color key defines one specific color, for example white, 
which should not be drawn to the render surface. The color key usually 
is defined by the RGB macro. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_ui_sdk_html_Types__sdvr_ui_preview_cb"></a>
<PRE class="cdef">
typedef void (*<A HREF="#sdvr_ui_sdk_html_Types__sdvr_ui_preview_cb">sdvr_ui_preview_cb</A>)(HDC);
</PRE>
<DIV CLASS="descr">
<P>
Preview callback function type. 
</P>
</DIV>

</DIV>

<!-- SEC_TYPES_CLOSE -->

<!-- SEC_DEFINES_START -->

<a name="sdvr_ui_sdk_html_Top__Defines"></a>
<H2>1.9 &nbsp; Defines</H2>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_ui_sdk_html_Defines__SDVR_UI_ERR_NONE"></a>
<PRE class="cdef">
#define <A HREF="#sdvr_ui_sdk_html_Defines__SDVR_UI_ERR_NONE">SDVR_UI_ERR_NONE</A>
</PRE>
<DIV CLASS="descr">
<P>
<A HREF="#sdvr_ui_sdk_html_Defines__SDVR_UI_ERR_NONE">SDVR_UI_ERR_NONE</A> - Error coder if no error. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_ui_sdk_html_Defines__SDVR_MAX_DRAW_REGIONS"></a>
<PRE class="cdef">
#define <A HREF="#sdvr_ui_sdk_html_Defines__SDVR_MAX_DRAW_REGIONS">SDVR_MAX_DRAW_REGIONS</A> 4 
</PRE>
<DIV CLASS="descr">
<P>
It is possible to display raw video frames for each encoder 
or decoder channel in multiple regions within a given window handle. 
<A HREF="#sdvr_ui_sdk_html_Defines__SDVR_MAX_DRAW_REGIONS">SDVR_MAX_DRAW_REGIONS</A> defines the maximum number of display regions 
that can be added to the display preview regions. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_ui_sdk_html_Defines__SDVR_UI_LS_SOLID"></a>
<a name="sdvr_ui_sdk_html_Defines__SDVR_UI_LS_DASH"></a>
<a name="sdvr_ui_sdk_html_Defines__SDVR_UI_LS_DOT"></a>
<PRE class="cdef">
#define <A HREF="#sdvr_ui_sdk_html_Defines__SDVR_UI_LS_SOLID">SDVR_UI_LS_SOLID</A> 0 
#define <A HREF="#sdvr_ui_sdk_html_Defines__SDVR_UI_LS_DASH">SDVR_UI_LS_DASH</A> 1 
#define <A HREF="#sdvr_ui_sdk_html_Defines__SDVR_UI_LS_DOT">SDVR_UI_LS_DOT</A> 2 
</PRE>
<DIV CLASS="descr">
<P>
The line style to use to draw a frame around a 
region. 
</P>
<P>
<A HREF="#sdvr_ui_sdk_html_Defines__SDVR_UI_LS_SOLID">SDVR_UI_LS_SOLID</A> - Use solid lines.  ____ 
</P>
<P>
<A HREF="#sdvr_ui_sdk_html_Defines__SDVR_UI_LS_DASH">SDVR_UI_LS_DASH</A> - Use dashed lines.  ----- 
</P>
<P>
<A HREF="#sdvr_ui_sdk_html_Defines__SDVR_UI_LS_DOT">SDVR_UI_LS_DOT</A> - Use dotted lines.   ..... 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_ui_sdk_html_Defines__EXTERN"></a>
<PRE class="cdef">
#define <A HREF="#sdvr_ui_sdk_html_Defines__EXTERN">EXTERN</A>
</PRE>
<DIV CLASS="descr">
<P>
A necessary evil introduced for C++ compatibility.  C source files must 
not declare a function <EM>extern</EM> ; instead, they must declare the function 
<EM>EXTERN</EM>.  For example: 
<PRE class="ccode">
    <A HREF="#sdvr_ui_sdk_html_Defines__EXTERN">EXTERN</A> void my_external_symbol(int a, double f); 
</PRE>
This specifies that the function has C linkage so that it can be used 
when compiled with a C++ compiler. 
</P>
</DIV>

</DIV>

<!-- SEC_DEFINES_CLOSE -->

<!-- SEC_ROUTINES_START -->

<a name="sdvr_ui_sdk_html_Top__Routines"></a>
<H2>1.10 &nbsp; Routines</H2>

<a name="sdvr_ui_sdk_html_Routines__Miscellaneous"></a>
<H3>1.10.1 &nbsp; Miscellaneous</H3>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_ui_sdk_html_Routines__sdvr_rgb"></a>
<PRE class="cdef">
#define <A HREF="#sdvr_ui_sdk_html_Routines__sdvr_rgb">sdvr_rgb</A> (r,g,b) { ... }
</PRE>
<DIV CLASS="descr">
<P>
A macro to construct an RGB color scheme. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_ui_sdk_html_Routines__sdvr_ui_init"></a>
<PRE class="cdef">
<A HREF="#sdvr_ui_sdk_html_Types__sdvr_err_ui_e">sdvr_err_ui_e</A> <A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_init">sdvr_ui_init</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> max_width, <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> max_lines);
</PRE>
<DIV CLASS="descr">
<P>
This function initializes video surface and sets up the maximum supported 
video frame size. (i.e., <A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_init">sdvr_ui_init</A>(720, 480) sets the largest video frame 
size in your system as NTSC D1.) 
</P>
<P>
This function must be called before any of the display functions 
and should be called only once per session. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<STRONG>max_width</STRONG> - The maximum width video frame that will ever be displayed. 
</LI>
<LI>
<STRONG>max_lines</STRONG> - The maximum number of lines in a video frame that will ever 
be displayed. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_ui_sdk_html_Routines__sdvr_ui_close"></a>
<PRE class="cdef">
<A HREF="#sdvr_ui_sdk_html_Types__sdvr_err_ui_e">sdvr_err_ui_e</A> <A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_close">sdvr_ui_close</A> ();
</PRE>
<DIV CLASS="descr">
<P>
This function closes the UI SDK and frees up the system 
resources used by it. You must call this function prior to exiting 
your DVR Application for a clean shutdown of your system. 
No other UI API function calls, except <NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_init">sdvr_ui_init</A>()</NOBR>, are allowed after 
this function is called. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
None. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_ui_sdk_html_Routines__sdvr_ui_set_key_color"></a>
<PRE class="cdef">
void <A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_set_key_color">sdvr_ui_set_key_color</A> (<A HREF="#sdvr_ui_sdk_html_Types__sdvr_ui_color_key_t">sdvr_ui_color_key_t</A> color_key);
</PRE>
<DIV CLASS="descr">
<P>
The color key defines one specific color that should not be drawn to the 
render surface. The color key is used to set the background window color 
when clearing a region. The default color key is white. 
</P>
<P>
<STRONG>NOTE: Color key is not supported by all the video cards.</STRONG> 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<STRONG>color_key</STRONG> - The new color key. It is usually defined by the sdvr_rgb macro. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
None. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_ui_sdk_html_Routines__sdvr_ui_set_yuv_buffer"></a>
<PRE class="cdef">
<A HREF="#sdvr_ui_sdk_html_Types__sdvr_err_ui_e">sdvr_err_ui_e</A> <A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_set_yuv_buffer">sdvr_ui_set_yuv_buffer</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_yuv_buffer_t">sdvr_yuv_buffer_t</A> *yuv_buffer);
</PRE>
<DIV CLASS="descr">
<P>
Before a video frame can be displayed, you must specify a raw video frame in 
the format of 4-2-0. The same buffer is used every time <NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_draw_yuv">sdvr_ui_draw_yuv</A>()</NOBR> is 
called. This means that the same video frame can be displayed in multiple window regions. 
To display the next video frame, you must call this function again with a new 
yuv_buffer. In general you get YUV buffers by calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_yuv_buffer">sdvr_get_yuv_buffer</A>()</NOBR> 
in the video frame callback, as you are notified when YUV buffers arrive. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<STRONG>yuv_buffer</STRONG> - A pointer to a YUV buffer structure. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_ui_sdk_html_Routines__sdvr_ui_draw_yuv"></a>
<PRE class="cdef">
<A HREF="#sdvr_ui_sdk_html_Types__sdvr_err_ui_e">sdvr_err_ui_e</A> <A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_draw_yuv">sdvr_ui_draw_yuv</A> (<A HREF="#sdvr_ui_sdk_html_Types__sdvr_ui_hwnd_t">sdvr_ui_hwnd_t</A>     hwnd,
                                <A HREF="#sdvr_ui_sdk_html_Types__sdvr_ui_region_t">sdvr_ui_region_t</A> * region);
</PRE>
<DIV CLASS="descr">
<P>
This function displays a YUV video frame that was previously set 
by <NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_set_yuv_buffer">sdvr_ui_set_yuv_buffer</A>()</NOBR> in the given region within the given 
window handle. 
</P>
<P>
The specified region must be within the maximum video frame width and 
lines that were set by the call to <NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_init">sdvr_ui_init</A>()</NOBR>. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<STRONG>hwnd</STRONG> - The window handle to display the video frame. 
</LI>
<LI>
<STRONG>region</STRONG> - The rectangle within the given window handle in which to 
display the video frame. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_ui_sdk_html_Routines__sdvr_ui_clear_yuv"></a>
<PRE class="cdef">
<A HREF="#sdvr_ui_sdk_html_Types__sdvr_err_ui_e">sdvr_err_ui_e</A> <A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_clear_yuv">sdvr_ui_clear_yuv</A> (<A HREF="#sdvr_ui_sdk_html_Types__sdvr_ui_hwnd_t">sdvr_ui_hwnd_t</A>     hwnd,
                                 <A HREF="#sdvr_ui_sdk_html_Types__sdvr_ui_region_t">sdvr_ui_region_t</A> * region);
</PRE>
<DIV CLASS="descr">
<P>
This function uses the previously defined color key that was set by 
calling <NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_set_key_color">sdvr_ui_set_key_color</A>()</NOBR> to clear the contents of the given 
rectangle within the given window handle. 
</P>
<P>
The specified region must be within the maximum video frame width and 
lines that were set by the call to <NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_init">sdvr_ui_init</A>()</NOBR>. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<STRONG>hwnd</STRONG> - The window handle to clear the video frame. 
</LI>
<LI>
<STRONG>region</STRONG> - The rectangle within the given window handle to 
clear. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_ui_sdk_html_Routines__sdvr_ui_draw_frame"></a>
<PRE class="cdef">
<A HREF="#sdvr_ui_sdk_html_Types__sdvr_err_ui_e">sdvr_err_ui_e</A> <A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_draw_frame">sdvr_ui_draw_frame</A> (<A HREF="#sdvr_ui_sdk_html_Types__sdvr_ui_hwnd_t">sdvr_ui_hwnd_t</A>        hwnd,
                                  <A HREF="#sdvr_ui_sdk_html_Types__sdvr_ui_region_t">sdvr_ui_region_t</A>      region,
                                  <A HREF="#sdvr_ui_sdk_html_Types__sdvr_ui_color_key_t">sdvr_ui_color_key_t</A>   rgb_color,
                                  int                   line_style);
</PRE>
<DIV CLASS="descr">
<P>
Use this function to draw a frame around the given region within the 
given window. 
</P>
<P>
You can specify the frame color or the line style. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<STRONG>hwnd</STRONG> - The current window handle. 
</LI>
<LI>
<STRONG>region</STRONG> - The rectangle within the given window handle around which to 
draw a frame. 
</LI>
<LI>
<STRONG>rgb_color</STRONG> - The line frame color. 
</LI>
<LI>
<STRONG>line_style</STRONG> - The line frame style. (i.e., <A HREF="#sdvr_ui_sdk_html_Defines__SDVR_UI_LS_SOLID">SDVR_UI_LS_SOLID</A>) 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_ui_sdk_html_Routines__sdvr_ui_version"></a>
<PRE class="cdef">
void <A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_version">sdvr_ui_version</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> * major,
                      <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> * minor,
                      <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> * revision,
                      <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> * build);
</PRE>
<DIV CLASS="descr">
<P>
This function returns the display SDK version. 
</P>
<P>
Stretch follows the convention of using four numbers for version 
control. A change in the major number indicates major changes to 
functionality, a change in the minor number indicates minor 
changes to functionality, and a change in the revision number indicates 
significant bug fixes that were introduced in the minor change functionality. 
A change to the build number indicates only bug fixes that do not 
change functionality. 
</P>
<P>
This function can be called before or after <NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_init">sdvr_ui_init</A>()</NOBR>; 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>major</EM> - Pointer to a variable that will hold the major version of the 
display SDK when this function returns. 
</LI>
<LI>
<EM>minor</EM> - Pointer to a variable that will hold the minor version of 
the display SDK when this function returns. 
</LI>
<LI>
<EM>revision</EM> - Pointer to a variable that will hold the revision version of the 
display SDK when this function returns. 
</LI>
<LI>
<EM>build</EM> - Pointer to a variable that will hold the build or bug fix 
version of the display SDK when this function returns. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
Nothing. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_ui_sdk_html_Routines__sdvr_ui_start_video_preview"></a>
<PRE class="cdef">
<A HREF="#sdvr_ui_sdk_html_Types__sdvr_err_ui_e">sdvr_err_ui_e</A> <A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_start_video_preview">sdvr_ui_start_video_preview</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>   handle,
                                           <A HREF="#sdvr_ui_sdk_html_Types__sdvr_ui_hwnd_t">sdvr_ui_hwnd_t</A>       wnd_handle,
                                           <A HREF="#sdvr_ui_sdk_html_Types__sdvr_ui_region_t">sdvr_ui_region_t</A>   * region,
                                           int                * preview_id);
</PRE>
<DIV CLASS="descr">
<P>
You can request the SDK to display video frames directly into one or more 
regions within a given window handle. Each consecutive call to this function 
causes 
the given display region within the given window handle to be added to the 
preview lists. There is a unique preview ID returned for each region that 
can be used to stop the preview on it by calling <NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_stop_video_preview">sdvr_ui_stop_video_preview</A>()</NOBR>. 
</P>
<P>
This function does not enable video streaming. You must call <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_stream_raw_video">sdvr_stream_raw_video</A>()</NOBR> 
to enable streaming of the raw video frames for the specific encoder or decoder 
channel. Then, if this function is called, the corresponding video frame will be 
displayed in the given regions. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<STRONG>handle</STRONG> - An encoder or decoder channel to display its raw video frames. 
</LI>
<LI>
<STRONG>wnd_handle</STRONG> - The window handle to display the video frames. 
</LI>
<LI>
<STRONG>region</STRONG> - The rectangle within the given window handle to 
display the video frames. You can add up to <A HREF="#sdvr_ui_sdk_html_Defines__SDVR_MAX_DRAW_REGIONS">SDVR_MAX_DRAW_REGIONS</A> 
regions by calling this function multiple times. Each region 
displays the same raw video frame for the given encoder or 
decoder handle. 
</LI>
<LI>
<STRONG>preview_id</STRONG> - A pointer to the variable holding the ID for the region 
that is added successfully. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
<P>
Remark: 
</P>
<UL>
<LI>
You still can call <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_yuv_buffer">sdvr_get_yuv_buffer</A>()</NOBR> to retrieve raw video frames for 
further processing if it is needed. 
</LI>
<LI>
<STRONG>NOTE:</STRONG> : For decoder channels, you must send each encoded frame to 
the board to decode them to receive raw video frames. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_ui_sdk_html_Routines__sdvr_ui_stop_video_preview"></a>
<PRE class="cdef">
<A HREF="#sdvr_ui_sdk_html_Types__sdvr_err_ui_e">sdvr_err_ui_e</A> <A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_stop_video_preview">sdvr_ui_stop_video_preview</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>   handle,
                                          int                  preview_id);
</PRE>
<DIV CLASS="descr">
<P>
This function stops previewing of the raw video frames of the given encoder 
or decoder channel for the given region ID. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<STRONG>handle</STRONG> - An encoder or decoder channel to display its raw video frames. 
</LI>
<LI>
<STRONG>preview_id</STRONG> - The ID of the region to stop raw video frame previewing. 
This ID was returned from the call <NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_start_video_preview">sdvr_ui_start_video_preview</A>()</NOBR>. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
<P>
Remark: 
</P>
<UL>
<LI>
Calling this function will not stop the actual raw video streaming. 
Call sdvr_stream_raw_video to stop raw video streaming. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_ui_sdk_html_Routines__sdvr_ui_set_preview_callback"></a>
<PRE class="cdef">
<A HREF="#sdvr_ui_sdk_html_Types__sdvr_err_ui_e">sdvr_err_ui_e</A> <A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_set_preview_callback">sdvr_ui_set_preview_callback</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>   handle,
                                            int                  preview_id,
                                            <A HREF="#sdvr_ui_sdk_html_Types__sdvr_ui_preview_cb">sdvr_ui_preview_cb</A>   cb);
</PRE>
<DIV CLASS="descr">
<P>
Sets the preview callback function. The video preview must be started before 
calling this function. The preview callback function is executed with every video 
frame, making it possible to modify the content of the frame. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<STRONG>handle</STRONG> - An encoder or decoder channel to display its raw video frames. 
</LI>
<LI>
<STRONG>preview_id</STRONG> - The ID of the region for which the callback is set. 
</LI>
<LI>
<STRONG>preview_cb</STRONG> - Pointer to the callback function or NULL to clear. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
<P>
Callback function on Windows: 
</P>
<UL>
<LI>
void (*preview_cb)(HDC hdc); 
</LI>
</UL>
<UL>
<LI>
Executed before the frame is diplayed. Device context handle can be used 
for drawing on the frame. Do not release the device context. It is created 
by the UI SDK and will be released automatically. 
</LI>
</UL>
<P>
Callback function on Linux: 
</P>
<UL>
<LI>
void (*preview_cb)(Display *dpy, Drawable win); 
</LI>
</UL>
<UL>
<LI>
Executed after the video frame is rendered into the window. Display and 
Drawable identify the X window and can be used for drawing over the frame. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_ui_sdk_html_Routines__sdvr_ui_refresh"></a>
<PRE class="cdef">
void <A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_refresh">sdvr_ui_refresh</A> ();
</PRE>
<DIV CLASS="descr">
<P>
Occasionally, the window region displaying the video frames may need 
to be repainted as the result of another window or application covering it. 
In this case, you will receive a paint message to repaint the region. 
</P>
<P>
Call this function to refresh the content of all the regions that were 
being previewed. 
</P>
<P>
<STRONG>Note:</STRONG> This function can only be used in conjunction with 
<NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_start_video_preview">sdvr_ui_start_video_preview</A>()</NOBR> and <NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_stop_video_preview">sdvr_ui_stop_video_preview</A>()</NOBR>. If you 
are using the low level UI API, calling this function will have no affect 
on the display. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
None. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
None. 
</LI>
</UL>
<P>
Remark: 
</P>
<UL>
<LI>
It is recommended although not required to call <NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_clear_yuv">sdvr_ui_clear_yuv</A>()</NOBR> for the 
desired region before calling this function. 
</LI>
</UL>
</DIV>

</DIV>

<!-- SEC_ROUTINES_CLOSE -->

<DIV style="page-break-before:always"></DIV>
<A NAME=dvr_common_html_start_of_file></A>

<H1>Common Definitions Shared Between Board and PC &nbsp; (dvr_common)</H1>

<CENTER>Last modified on Mar 18, 2009 at 07:17 UTC</CENTER>

<!-- last_modified : Mar 18, 2009 at 07:17 UTC -->

<!-- package : dvr_common -->

<!-- short-description : Common Definitions Shared Between Board and PC -->

<!-- contact_name :  -->

<!-- contact_email :  -->

<!-- copyright :  -->

<!-- cdoc-version : 2.4.5 -->
<!-- ANCHOR_TABLE
"Package"	"dvr_common"	"dvr_common.html"
"Section"	"Include"	"Top__Include"
"Section"	"Introduction"	"Top__Introduction"
"Section"	"Basic Communication Method Between the PCIe Card and the Host PC"	"Top__Basic___Communication___Method___Between___the___PCIe___Card___and___the___Host___PC"
"Section"	"Usage Model"	"Top__Usage___Model"
"Section"	"Command and Response Messages"	"Top__Command___and___Response___Messages"
"Section"	"Creating, Destroying, and Configuring a Job"	"Top__Creating______Destroying______and___Configuring___a___Job"
"Section"	"Dynamic Control of Basic Jobs"	"Top__Dynamic___Control___of___Basic___Jobs"
"Section"	"A Convention"	"Top__A___Convention"
"Section"	"Data Communication Between Firmware and SDK"	"Top__Data___Communication___Between___Firmware___and___SDK"
"Section"	"Asynchronous Events"	"Top__Asynchronous___Events"
"Section"	"Restrictions"	"Top__Restrictions"
"Section"	"Types"	"Top__Types"
"Typedef"	"dvr_status_e"	"Types__dvr_status_e"
"Typedef"	"dvr_chip_rev_e"	"Types__dvr_chip_rev_e"
"Typedef"	"dvr_job_type_e"	"Types__dvr_job_type_e"
"Typedef"	"dvr_video_res_e"	"Types__dvr_video_res_e"
"Typedef"	"dvr_vc_format_e"	"Types__dvr_vc_format_e"
"Typedef"	"dvr_ac_format_e"	"Types__dvr_ac_format_e"
"Typedef"	"dvr_vpp_mode_e"	"Types__dvr_vpp_mode_e"
"Typedef"	"dvr_vpp_action_e"	"Types__dvr_vpp_action_e"
"Typedef"	"dvr_rc_e"	"Types__dvr_rc_e"
"Typedef"	"dvr_job_action_e"	"Types__dvr_job_action_e"
"Typedef"	"dvr_osd_pos_e"	"Types__dvr_osd_pos_e"
"Typedef"	"dvr_osd_dts_e"	"Types__dvr_osd_dts_e"
"Typedef"	"dvr_data_type_e"	"Types__dvr_data_type_e"
"Typedef"	"dvr_signal_type_e"	"Types__dvr_signal_type_e"
"Typedef"	"dvr_term_e"	"Types__dvr_term_e"
"Typedef"	"dvr_led_type_e"	"Types__dvr_led_type_e"
"Typedef"	"dvr_message_e"	"Types__dvr_message_e"
"Typedef"	"dvr_rawv_format_e"	"Types__dvr_rawv_format_e"
"Typedef"	"dvr_status_enum"	"Types__dvr_status_enum"
"Typedef"	"DVR_STATUS_OK"	"Types__DVR_STATUS_OK"
"Typedef"	"DVR_STATUS_WRONG_CAMERA_NUMBER"	"Types__DVR_STATUS_WRONG_CAMERA_NUMBER"
"Typedef"	"DVR_STATUS_WRONG_CAMERA_TYPE"	"Types__DVR_STATUS_WRONG_CAMERA_TYPE"
"Typedef"	"DVR_STATUS_WRONG_CODEC_FORMAT"	"Types__DVR_STATUS_WRONG_CODEC_FORMAT"
"Typedef"	"DVR_STATUS_WRONG_CODEC_RESOLUTION"	"Types__DVR_STATUS_WRONG_CODEC_RESOLUTION"
"Typedef"	"DVR_STATUS_WRONG_JOB_TYPE"	"Types__DVR_STATUS_WRONG_JOB_TYPE"
"Typedef"	"DVR_STATUS_WRONG_JOB_ID"	"Types__DVR_STATUS_WRONG_JOB_ID"
"Typedef"	"DVR_STATUS_WRONG_VIDEO_FORMAT"	"Types__DVR_STATUS_WRONG_VIDEO_FORMAT"
"Typedef"	"DVR_STATUS_WRONG_AUDIO_FORMAT"	"Types__DVR_STATUS_WRONG_AUDIO_FORMAT"
"Typedef"	"DVR_STATUS_EXCEED_CPU_LIMIT"	"Types__DVR_STATUS_EXCEED_CPU_LIMIT"
"Typedef"	"DVR_STATUS_JOB_NOT_CREATED"	"Types__DVR_STATUS_JOB_NOT_CREATED"
"Typedef"	"DVR_STATUS_JOB_ALREADY_CREATED"	"Types__DVR_STATUS_JOB_ALREADY_CREATED"
"Typedef"	"DVR_STATUS_JOB_NOT_ENABLED"	"Types__DVR_STATUS_JOB_NOT_ENABLED"
"Typedef"	"DVR_STATUS_JOB_NOT_DISABLED"	"Types__DVR_STATUS_JOB_NOT_DISABLED"
"Typedef"	"DVR_STATUS_SMO_NOT_CREATED"	"Types__DVR_STATUS_SMO_NOT_CREATED"
"Typedef"	"DVR_STATUS_INVALID_TIME"	"Types__DVR_STATUS_INVALID_TIME"
"Typedef"	"DVR_STATUS_ILLEGAL_SMO_PARAMS"	"Types__DVR_STATUS_ILLEGAL_SMO_PARAMS"
"Typedef"	"DVR_STATUS_SMO_NOT_SUPPORTED"	"Types__DVR_STATUS_SMO_NOT_SUPPORTED"
"Typedef"	"DVR_STATUS_VDET_ERROR"	"Types__DVR_STATUS_VDET_ERROR"
"Typedef"	"DVR_STATUS_RUNTIME_ERROR"	"Types__DVR_STATUS_RUNTIME_ERROR"
"Typedef"	"DVR_STATUS_VPP_RUNTIME_ERROR"	"Types__DVR_STATUS_VPP_RUNTIME_ERROR"
"Typedef"	"DVR_STATUS_ENCODER_RUNTIME_ERROR"	"Types__DVR_STATUS_ENCODER_RUNTIME_ERROR"
"Typedef"	"DVR_STATUS_DECODER_RUNTIME_ERROR"	"Types__DVR_STATUS_DECODER_RUNTIME_ERROR"
"Typedef"	"DVR_STATUS_ILLEGAL_PARAMETER"	"Types__DVR_STATUS_ILLEGAL_PARAMETER"
"Typedef"	"DVR_STATUS_INTERNAL_ERROR"	"Types__DVR_STATUS_INTERNAL_ERROR"
"Typedef"	"DVR_STATUS_ILLEGAL_COMMAND"	"Types__DVR_STATUS_ILLEGAL_COMMAND"
"Typedef"	"DVR_STATUS_SMO_NOT_DISABLED"	"Types__DVR_STATUS_SMO_NOT_DISABLED"
"Typedef"	"DVR_STATUS_OUT_OF_MEMORY"	"Types__DVR_STATUS_OUT_OF_MEMORY"
"Typedef"	"DVR_STATUS_NO_IO_BOARD"	"Types__DVR_STATUS_NO_IO_BOARD"
"Typedef"	"DVR_STATUS_AUDIO_RUNTIME_ERROR"	"Types__DVR_STATUS_AUDIO_RUNTIME_ERROR"
"Typedef"	"DVR_STATUS_UNSUPPORTED_COMMAND"	"Types__DVR_STATUS_UNSUPPORTED_COMMAND"
"Typedef"	"DVR_STATUS_SMO_CHAN_FAILED"	"Types__DVR_STATUS_SMO_CHAN_FAILED"
"Typedef"	"DVR_STATUS_RES_LIMIT_EXCEEDED"	"Types__DVR_STATUS_RES_LIMIT_EXCEEDED"
"Typedef"	"dvr_chip_rev_enum"	"Types__dvr_chip_rev_enum"
"Typedef"	"CHIP_S6100_3_REV_C"	"Types__CHIP_S6100_3_REV_C"
"Typedef"	"CHIP_S6105_3_REV_C"	"Types__CHIP_S6105_3_REV_C"
"Typedef"	"CHIP_S6106_3_REV_C"	"Types__CHIP_S6106_3_REV_C"
"Typedef"	"CHIP_S6100_3_REV_D"	"Types__CHIP_S6100_3_REV_D"
"Typedef"	"CHIP_S6105_3_REV_D"	"Types__CHIP_S6105_3_REV_D"
"Typedef"	"CHIP_S6106_3_REV_D"	"Types__CHIP_S6106_3_REV_D"
"Typedef"	"CHIP_S6100_3_REV_F"	"Types__CHIP_S6100_3_REV_F"
"Typedef"	"CHIP_S6105_3_REV_F"	"Types__CHIP_S6105_3_REV_F"
"Typedef"	"CHIP_S6106_3_REV_F"	"Types__CHIP_S6106_3_REV_F"
"Typedef"	"CHIP_S6100_3_UNKNOWN"	"Types__CHIP_S6100_3_UNKNOWN"
"Typedef"	"CHIP_S6105_3_UNKNOWN"	"Types__CHIP_S6105_3_UNKNOWN"
"Typedef"	"CHIP_S6106_3_UNKNOWN"	"Types__CHIP_S6106_3_UNKNOWN"
"Typedef"	"CHIP_UNKNOWN"	"Types__CHIP_UNKNOWN"
"Typedef"	"dvr_job_type_enum"	"Types__dvr_job_type_enum"
"Typedef"	"DVR_JOB_CAMERA_ENCODE"	"Types__DVR_JOB_CAMERA_ENCODE"
"Typedef"	"DVR_JOB_HOST_ENCODE"	"Types__DVR_JOB_HOST_ENCODE"
"Typedef"	"DVR_JOB_HOST_DECODE"	"Types__DVR_JOB_HOST_DECODE"
"Typedef"	"DVR_JOB_VIDEO_OUTPUT"	"Types__DVR_JOB_VIDEO_OUTPUT"
"Typedef"	"dvr_video_res_enum"	"Types__dvr_video_res_enum"
"Typedef"	"DVR_VIDEO_RES_INVALID"	"Types__DVR_VIDEO_RES_INVALID"
"Typedef"	"DVR_VIDEO_RES_FULL"	"Types__DVR_VIDEO_RES_FULL"
"Typedef"	"DVR_VIDEO_RES_CIF"	"Types__DVR_VIDEO_RES_CIF"
"Typedef"	"DVR_VIDEO_RES_QCIF"	"Types__DVR_VIDEO_RES_QCIF"
"Typedef"	"DVR_VIDEO_RES_HALF"	"Types__DVR_VIDEO_RES_HALF"
"Typedef"	"DVR_VIDEO_RES_DCIF"	"Types__DVR_VIDEO_RES_DCIF"
"Typedef"	"DVR_VIDEO_RES_CLASSIC_CIF"	"Types__DVR_VIDEO_RES_CLASSIC_CIF"
"Typedef"	"DVR_VIDEO_RES_CLASSIC_2CIF"	"Types__DVR_VIDEO_RES_CLASSIC_2CIF"
"Typedef"	"DVR_VIDEO_RES_CLASSIC_4CIF"	"Types__DVR_VIDEO_RES_CLASSIC_4CIF"
"Typedef"	"dvr_vc_format_enum"	"Types__dvr_vc_format_enum"
"Typedef"	"DVR_VC_FORMAT_NONE"	"Types__DVR_VC_FORMAT_NONE"
"Typedef"	"DVR_VC_FORMAT_H264"	"Types__DVR_VC_FORMAT_H264"
"Typedef"	"DVR_VC_FORMAT_JPEG"	"Types__DVR_VC_FORMAT_JPEG"
"Typedef"	"DVR_VC_FORMAT_MPEG4"	"Types__DVR_VC_FORMAT_MPEG4"
"Typedef"	"dvr_ac_format_enum"	"Types__dvr_ac_format_enum"
"Typedef"	"DVR_AC_FORMAT_NONE"	"Types__DVR_AC_FORMAT_NONE"
"Typedef"	"DVR_AC_FORMAT_G711"	"Types__DVR_AC_FORMAT_G711"
"Typedef"	"DVR_AC_FORMAT_G726_16K"	"Types__DVR_AC_FORMAT_G726_16K"
"Typedef"	"DVR_AC_FORMAT_G726_24K"	"Types__DVR_AC_FORMAT_G726_24K"
"Typedef"	"DVR_AC_FORMAT_G726_32K"	"Types__DVR_AC_FORMAT_G726_32K"
"Typedef"	"DVR_AC_FORMAT_G726_48K"	"Types__DVR_AC_FORMAT_G726_48K"
"Typedef"	"dvr_vpp_mode_enum"	"Types__dvr_vpp_mode_enum"
"Typedef"	"DVR_VPP_MODE_SLATERAL"	"Types__DVR_VPP_MODE_SLATERAL"
"Typedef"	"DVR_VPP_MODE_ANALYTICS"	"Types__DVR_VPP_MODE_ANALYTICS"
"Typedef"	"dvr_vpp_action_enum"	"Types__dvr_vpp_action_enum"
"Typedef"	"DVR_VPP_ACTION_ANALYTIC"	"Types__DVR_VPP_ACTION_ANALYTIC"
"Typedef"	"DVR_VPP_ACTION_DEINTERLACE"	"Types__DVR_VPP_ACTION_DEINTERLACE"
"Typedef"	"DVR_VPP_ACTION_MEDIAN_FILTER"	"Types__DVR_VPP_ACTION_MEDIAN_FILTER"
"Typedef"	"DVR_VPP_ACTION_SLATERAL"	"Types__DVR_VPP_ACTION_SLATERAL"
"Typedef"	"dvr_rc_enum"	"Types__dvr_rc_enum"
"Typedef"	"DVR_RC_NONE"	"Types__DVR_RC_NONE"
"Typedef"	"DVR_RC_VBR"	"Types__DVR_RC_VBR"
"Typedef"	"DVR_RC_CBR"	"Types__DVR_RC_CBR"
"Typedef"	"DVR_RC_CQP"	"Types__DVR_RC_CQP"
"Typedef"	"DVR_RC_CQ"	"Types__DVR_RC_CQ"
"Typedef"	"dvr_job_action_enum"	"Types__dvr_job_action_enum"
"Typedef"	"DVR_JOB_CREATE"	"Types__DVR_JOB_CREATE"
"Typedef"	"DVR_JOB_DESTROY"	"Types__DVR_JOB_DESTROY"
"Typedef"	"DVR_JOB_RESET"	"Types__DVR_JOB_RESET"
"Typedef"	"dvr_osd_pos_enum"	"Types__dvr_osd_pos_enum"
"Typedef"	"DVR_OSD_POS_TL"	"Types__DVR_OSD_POS_TL"
"Typedef"	"DVR_OSD_POS_BL"	"Types__DVR_OSD_POS_BL"
"Typedef"	"DVR_OSD_POS_TR"	"Types__DVR_OSD_POS_TR"
"Typedef"	"DVR_OSD_POS_BR"	"Types__DVR_OSD_POS_BR"
"Typedef"	"DVR_OSD_POS_CUSTOM"	"Types__DVR_OSD_POS_CUSTOM"
"Typedef"	"dvr_osd_dts_enum"	"Types__dvr_osd_dts_enum"
"Typedef"	"DVR_OSD_DTS_NONE"	"Types__DVR_OSD_DTS_NONE"
"Typedef"	"DVR_OSD_DTS_DEBUG"	"Types__DVR_OSD_DTS_DEBUG"
"Typedef"	"DVR_OSD_DTS_MDY_12H"	"Types__DVR_OSD_DTS_MDY_12H"
"Typedef"	"DVR_OSD_DTS_DMY_12H"	"Types__DVR_OSD_DTS_DMY_12H"
"Typedef"	"DVR_OSD_DTS_YMD_12H"	"Types__DVR_OSD_DTS_YMD_12H"
"Typedef"	"DVR_OSD_DTS_MDY_24H"	"Types__DVR_OSD_DTS_MDY_24H"
"Typedef"	"DVR_OSD_DTS_DMY_24H"	"Types__DVR_OSD_DTS_DMY_24H"
"Typedef"	"DVR_OSD_DTS_YMD_24H"	"Types__DVR_OSD_DTS_YMD_24H"
"Typedef"	"DVR_OSD_DTS_DEBUG_2"	"Types__DVR_OSD_DTS_DEBUG_2"
"Typedef"	"dvr_data_type_enum"	"Types__dvr_data_type_enum"
"Typedef"	"DVR_DATA_RAW_VIDEO_Y"	"Types__DVR_DATA_RAW_VIDEO_Y"
"Typedef"	"DVR_DATA_RAW_VIDEO_U"	"Types__DVR_DATA_RAW_VIDEO_U"
"Typedef"	"DVR_DATA_RAW_VIDEO_V"	"Types__DVR_DATA_RAW_VIDEO_V"
"Typedef"	"DVR_DATA_RAW_AUDIO"	"Types__DVR_DATA_RAW_AUDIO"
"Typedef"	"DVR_DATA_H264_IDR"	"Types__DVR_DATA_H264_IDR"
"Typedef"	"DVR_DATA_H264_I"	"Types__DVR_DATA_H264_I"
"Typedef"	"DVR_DATA_H264_P"	"Types__DVR_DATA_H264_P"
"Typedef"	"DVR_DATA_H264_B"	"Types__DVR_DATA_H264_B"
"Typedef"	"DVR_DATA_H264_SPS"	"Types__DVR_DATA_H264_SPS"
"Typedef"	"DVR_DATA_H264_PPS"	"Types__DVR_DATA_H264_PPS"
"Typedef"	"DVR_DATA_JPEG"	"Types__DVR_DATA_JPEG"
"Typedef"	"DVR_DATA_G711"	"Types__DVR_DATA_G711"
"Typedef"	"DVR_DATA_MPEG4_I"	"Types__DVR_DATA_MPEG4_I"
"Typedef"	"DVR_DATA_MPEG4_P"	"Types__DVR_DATA_MPEG4_P"
"Typedef"	"DVR_DATA_MPEG4_B"	"Types__DVR_DATA_MPEG4_B"
"Typedef"	"DVR_DATA_MPEG4_VOL"	"Types__DVR_DATA_MPEG4_VOL"
"Typedef"	"DVR_DATA_G726_16K"	"Types__DVR_DATA_G726_16K"
"Typedef"	"DVR_DATA_G726_32K"	"Types__DVR_DATA_G726_32K"
"Typedef"	"DVR_DATA_MOTION_VALUES"	"Types__DVR_DATA_MOTION_VALUES"
"Typedef"	"DVR_DATA_RAW_VIDEO"	"Types__DVR_DATA_RAW_VIDEO"
"Typedef"	"DVR_DATA_UNKNOWN"	"Types__DVR_DATA_UNKNOWN"
"Typedef"	"dvr_signal_type_enum"	"Types__dvr_signal_type_enum"
"Typedef"	"DVR_SIGNAL_SENSOR_ACTIVATED"	"Types__DVR_SIGNAL_SENSOR_ACTIVATED"
"Typedef"	"DVR_SIGNAL_MOTION_DETECTED"	"Types__DVR_SIGNAL_MOTION_DETECTED"
"Typedef"	"DVR_SIGNAL_BLIND_DETECTED"	"Types__DVR_SIGNAL_BLIND_DETECTED"
"Typedef"	"DVR_SIGNAL_NIGHT_DETECTED"	"Types__DVR_SIGNAL_NIGHT_DETECTED"
"Typedef"	"DVR_SIGNAL_VIDEO_LOST"	"Types__DVR_SIGNAL_VIDEO_LOST"
"Typedef"	"DVR_SIGNAL_VIDEO_DETECTED"	"Types__DVR_SIGNAL_VIDEO_DETECTED"
"Typedef"	"DVR_SIGNAL_RUNTIME_ERROR"	"Types__DVR_SIGNAL_RUNTIME_ERROR"
"Typedef"	"DVR_SIGNAL_FATAL_ERROR"	"Types__DVR_SIGNAL_FATAL_ERROR"
"Typedef"	"DVR_SIGNAL_HEARTBEAT"	"Types__DVR_SIGNAL_HEARTBEAT"
"Typedef"	"DVR_SIGNAL_WATCHDOG_EXPIRED"	"Types__DVR_SIGNAL_WATCHDOG_EXPIRED"
"Typedef"	"dvr_rawv_format_enum"	"Types__dvr_rawv_format_enum"
"Typedef"	"DVR_RAWV_FORMAT_YUV_4_2_0"	"Types__DVR_RAWV_FORMAT_YUV_4_2_0"
"Typedef"	"DVR_RAWV_FORMAT_YUV_4_2_2"	"Types__DVR_RAWV_FORMAT_YUV_4_2_2"
"Typedef"	"DVR_RAWV_FORMAT_YVU_4_2_0"	"Types__DVR_RAWV_FORMAT_YVU_4_2_0"
"Typedef"	"dvr_message_enum"	"Types__dvr_message_enum"
"Typedef"	"DVR_GET_VER_INFO"	"Types__DVR_GET_VER_INFO"
"Typedef"	"DVR_REP_VER_INFO"	"Types__DVR_REP_VER_INFO"
"Typedef"	"DVR_GET_CODEC_INFO"	"Types__DVR_GET_CODEC_INFO"
"Typedef"	"DVR_REP_CODEC_INFO"	"Types__DVR_REP_CODEC_INFO"
"Typedef"	"DVR_GET_BOARD"	"Types__DVR_GET_BOARD"
"Typedef"	"DVR_SET_BOARD"	"Types__DVR_SET_BOARD"
"Typedef"	"DVR_REP_BOARD"	"Types__DVR_REP_BOARD"
"Typedef"	"DVR_GET_JOB"	"Types__DVR_GET_JOB"
"Typedef"	"DVR_SET_JOB"	"Types__DVR_SET_JOB"
"Typedef"	"DVR_REP_JOB"	"Types__DVR_REP_JOB"
"Typedef"	"DVR_GET_SMO"	"Types__DVR_GET_SMO"
"Typedef"	"DVR_SET_SMO"	"Types__DVR_SET_SMO"
"Typedef"	"DVR_REP_SMO"	"Types__DVR_REP_SMO"
"Typedef"	"DVR_GET_HMO"	"Types__DVR_GET_HMO"
"Typedef"	"DVR_SET_HMO"	"Types__DVR_SET_HMO"
"Typedef"	"DVR_REP_HMO"	"Types__DVR_REP_HMO"
"Typedef"	"DVR_GET_OSD"	"Types__DVR_GET_OSD"
"Typedef"	"DVR_SET_OSD"	"Types__DVR_SET_OSD"
"Typedef"	"DVR_REP_OSD"	"Types__DVR_REP_OSD"
"Typedef"	"DVR_GET_PR"	"Types__DVR_GET_PR"
"Typedef"	"DVR_SET_PR"	"Types__DVR_SET_PR"
"Typedef"	"DVR_REP_PR"	"Types__DVR_REP_PR"
"Typedef"	"DVR_GET_MD"	"Types__DVR_GET_MD"
"Typedef"	"DVR_SET_MD"	"Types__DVR_SET_MD"
"Typedef"	"DVR_REP_MD"	"Types__DVR_REP_MD"
"Typedef"	"DVR_GET_BD"	"Types__DVR_GET_BD"
"Typedef"	"DVR_SET_BD"	"Types__DVR_SET_BD"
"Typedef"	"DVR_REP_BD"	"Types__DVR_REP_BD"
"Typedef"	"DVR_GET_ND"	"Types__DVR_GET_ND"
"Typedef"	"DVR_SET_ND"	"Types__DVR_SET_ND"
"Typedef"	"DVR_REP_ND"	"Types__DVR_REP_ND"
"Typedef"	"DVR_GET_RELAYS"	"Types__DVR_GET_RELAYS"
"Typedef"	"DVR_SET_RELAYS"	"Types__DVR_SET_RELAYS"
"Typedef"	"DVR_REP_RELAYS"	"Types__DVR_REP_RELAYS"
"Typedef"	"DVR_GET_SENSORS"	"Types__DVR_GET_SENSORS"
"Typedef"	"DVR_SET_SENSORS"	"Types__DVR_SET_SENSORS"
"Typedef"	"DVR_REP_SENSORS"	"Types__DVR_REP_SENSORS"
"Typedef"	"DVR_GET_WATCHDOG"	"Types__DVR_GET_WATCHDOG"
"Typedef"	"DVR_SET_WATCHDOG"	"Types__DVR_SET_WATCHDOG"
"Typedef"	"DVR_REP_WATCHDOG"	"Types__DVR_REP_WATCHDOG"
"Typedef"	"DVR_GET_CONTROL"	"Types__DVR_GET_CONTROL"
"Typedef"	"DVR_SET_CONTROL"	"Types__DVR_SET_CONTROL"
"Typedef"	"DVR_REP_CONTROL"	"Types__DVR_REP_CONTROL"
"Typedef"	"DVR_GET_TIME"	"Types__DVR_GET_TIME"
"Typedef"	"DVR_SET_TIME"	"Types__DVR_SET_TIME"
"Typedef"	"DVR_REP_TIME"	"Types__DVR_REP_TIME"
"Typedef"	"DVR_GET_ENCODE"	"Types__DVR_GET_ENCODE"
"Typedef"	"DVR_SET_ENCODE"	"Types__DVR_SET_ENCODE"
"Typedef"	"DVR_REP_ENCODE"	"Types__DVR_REP_ENCODE"
"Typedef"	"DVR_GET_ENC_ALARM"	"Types__DVR_GET_ENC_ALARM"
"Typedef"	"DVR_SET_ENC_ALARM"	"Types__DVR_SET_ENC_ALARM"
"Typedef"	"DVR_REP_ENC_ALARM"	"Types__DVR_REP_ENC_ALARM"
"Typedef"	"DVR_GET_DECODE"	"Types__DVR_GET_DECODE"
"Typedef"	"DVR_SET_DECODE"	"Types__DVR_SET_DECODE"
"Typedef"	"DVR_REP_DECODE"	"Types__DVR_REP_DECODE"
"Typedef"	"DVR_SET_FONT_TABLE"	"Types__DVR_SET_FONT_TABLE"
"Typedef"	"DVR_REP_FONT_TABLE"	"Types__DVR_REP_FONT_TABLE"
"Typedef"	"DVR_GET_OSD_EX"	"Types__DVR_GET_OSD_EX"
"Typedef"	"DVR_SET_OSD_EX"	"Types__DVR_SET_OSD_EX"
"Typedef"	"DVR_REP_OSD_EX"	"Types__DVR_REP_OSD_EX"
"Typedef"	"DVR_GET_UART"	"Types__DVR_GET_UART"
"Typedef"	"DVR_SET_UART"	"Types__DVR_SET_UART"
"Typedef"	"DVR_REP_UART"	"Types__DVR_REP_UART"
"Typedef"	"DVR_GET_IOCTL"	"Types__DVR_GET_IOCTL"
"Typedef"	"DVR_SET_IOCTL"	"Types__DVR_SET_IOCTL"
"Typedef"	"DVR_REP_IOCTL"	"Types__DVR_REP_IOCTL"
"Typedef"	"DVR_GET_AUTH_KEY"	"Types__DVR_GET_AUTH_KEY"
"Typedef"	"DVR_SET_AUTH_KEY"	"Types__DVR_SET_AUTH_KEY"
"Typedef"	"DVR_REP_AUTH_KEY"	"Types__DVR_REP_AUTH_KEY"
"Typedef"	"DVR_SET_REGIONS_MAP"	"Types__DVR_SET_REGIONS_MAP"
"Typedef"	"DVR_REP_REGIONS_MAP"	"Types__DVR_REP_REGIONS_MAP"
"Typedef"	"DVR_SET_VIDEO_OUTPUT"	"Types__DVR_SET_VIDEO_OUTPUT"
"Typedef"	"DVR_REP_VIDEO_OUTPUT"	"Types__DVR_REP_VIDEO_OUTPUT"
"Typedef"	"DVR_GET_SMO_ATTRIB"	"Types__DVR_GET_SMO_ATTRIB"
"Typedef"	"DVR_REP_SMO_ATTRIB"	"Types__DVR_REP_SMO_ATTRIB"
"Typedef"	"DVR_SIG_HOST"	"Types__DVR_SIG_HOST"
"Typedef"	"DVR_FW_INTERNAL"	"Types__DVR_FW_INTERNAL"
"Typedef"	"dvr_ver_info_t"	"Types__dvr_ver_info_t"
"Typedef"	"dvr_codec_info_t"	"Types__dvr_codec_info_t"
"Typedef"	"dvr_board_t"	"Types__dvr_board_t"
"Typedef"	"dvr_job_t"	"Types__dvr_job_t"
"Typedef"	"dvr_smo_t"	"Types__dvr_smo_t"
"Typedef"	"dvr_hmo_t"	"Types__dvr_hmo_t"
"Typedef"	"dvr_osd_t"	"Types__dvr_osd_t"
"Typedef"	"dvr_font_table_t"	"Types__dvr_font_table_t"
"Typedef"	"dvr_osd_ex_t"	"Types__dvr_osd_ex_t"
"Typedef"	"dvr_auth_key_t"	"Types__dvr_auth_key_t"
"Typedef"	"dvr_regions_map_t"	"Types__dvr_regions_map_t"
"Typedef"	"dvr_pr_t"	"Types__dvr_pr_t"
"Typedef"	"dvr_md_t"	"Types__dvr_md_t"
"Typedef"	"dvr_bd_t"	"Types__dvr_bd_t"
"Typedef"	"dvr_nd_t"	"Types__dvr_nd_t"
"Typedef"	"dvr_encode_info_t"	"Types__dvr_encode_info_t"
"Typedef"	"dvr_enc_alarm_info_t"	"Types__dvr_enc_alarm_info_t"
"Typedef"	"dvr_decode_info_t"	"Types__dvr_decode_info_t"
"Typedef"	"dvr_relay_t"	"Types__dvr_relay_t"
"Typedef"	"dvr_sensor_t"	"Types__dvr_sensor_t"
"Typedef"	"dvr_watchdog_t"	"Types__dvr_watchdog_t"
"Typedef"	"dvr_control_t"	"Types__dvr_control_t"
"Typedef"	"dvr_time_t"	"Types__dvr_time_t"
"Typedef"	"dvr_data_header_t"	"Types__dvr_data_header_t"
"Typedef"	"dvr_sig_host_t"	"Types__dvr_sig_host_t"
"Typedef"	"dvr_uart_t"	"Types__dvr_uart_t"
"Typedef"	"dvr_term_enum"	"Types__dvr_term_enum"
"Typedef"	"DVR_TERM_75OHM"	"Types__DVR_TERM_75OHM"
"Typedef"	"DVR_TERM_HIGH_IMPEDANCE"	"Types__DVR_TERM_HIGH_IMPEDANCE"
"Typedef"	"dvr_led_type_enum"	"Types__dvr_led_type_enum"
"Typedef"	"DVR_LED_TYPE_RECORD"	"Types__DVR_LED_TYPE_RECORD"
"Typedef"	"DVR_LED_TYPE_ALARM"	"Types__DVR_LED_TYPE_ALARM"
"Typedef"	"dvr_ioctl_t"	"Types__dvr_ioctl_t"
"Typedef"	"dvr_videoout_t"	"Types__dvr_videoout_t"
"Typedef"	"dvr_smo_capabilities_e"	"Types__dvr_smo_capabilities_e"
"Typedef"	"DVR_SMO_CAP_OUTPUT"	"Types__DVR_SMO_CAP_OUTPUT"
"Typedef"	"DVR_SMO_CAP_OSD"	"Types__DVR_SMO_CAP_OSD"
"Typedef"	"DVR_SMO_CAP_ALPHA_BLENDING"	"Types__DVR_SMO_CAP_ALPHA_BLENDING"
"Typedef"	"DVR_SMO_CAP_TILING"	"Types__DVR_SMO_CAP_TILING"
"Typedef"	"DVR_SMO_CAP_ANALOG"	"Types__DVR_SMO_CAP_ANALOG"
"Typedef"	"dvr_smo_attrib_t"	"Types__dvr_smo_attrib_t"
"Section"	"Defines"	"Top__Defines"
"Define"	"DDR_DIAG_WRITEREAD_FAIL"	"Defines__DDR_DIAG_WRITEREAD_FAIL"
"Define"	"DDR_DIAG_ADDRLINES_FAIL"	"Defines__DDR_DIAG_ADDRLINES_FAIL"
"Define"	"DDR_DIAG_BITFLIP_FAIL"	"Defines__DDR_DIAG_BITFLIP_FAIL"
"Define"	"DDR_DIAG_DMA_FAIL"	"Defines__DDR_DIAG_DMA_FAIL"
"Define"	"DDR_DIAG_READ_DMA_FAIL"	"Defines__DDR_DIAG_READ_DMA_FAIL"
"Define"	"PLL_TEST_MHZ_ERR"	"Defines__PLL_TEST_MHZ_ERR"
"Define"	"PLL_TEST_SYS_PLL_ERR"	"Defines__PLL_TEST_SYS_PLL_ERR"
"Define"	"PLL_TEST_IO_PLL_ERR"	"Defines__PLL_TEST_IO_PLL_ERR"
"Define"	"PLL_TEST_AIM_PLL_ERR"	"Defines__PLL_TEST_AIM_PLL_ERR"
"Define"	"PLL_TEST_DP0_PLL_ERR"	"Defines__PLL_TEST_DP0_PLL_ERR"
"Define"	"PLL_TEST_DP2_PLL_ERR"	"Defines__PLL_TEST_DP2_PLL_ERR"
"Define"	"PLL_TEST_DDR_DLL_ERR"	"Defines__PLL_TEST_DDR_DLL_ERR"
"Define"	"SPI_TEST_READ_ERR"	"Defines__SPI_TEST_READ_ERR"
"Define"	"SPI_TEST_ERASE_ERR"	"Defines__SPI_TEST_ERASE_ERR"
"Define"	"SPI_TEST_PROG_ERR"	"Defines__SPI_TEST_PROG_ERR"
"Define"	"SPI_TEST_UNLOCK_ERR"	"Defines__SPI_TEST_UNLOCK_ERR"
"Define"	"SPI_TEST_COMPARE_ERR"	"Defines__SPI_TEST_COMPARE_ERR"
"Define"	"SPI_TEST_MAINT_ERR"	"Defines__SPI_TEST_MAINT_ERR"
"Define"	"SPI_TEST_MISC_ERR"	"Defines__SPI_TEST_MISC_ERR"
"Define"	"TWI_EEPROM_TEST_READ_ERR"	"Defines__TWI_EEPROM_TEST_READ_ERR"
"Define"	"TWI_EEPROM_TEST_WRITE_ERR"	"Defines__TWI_EEPROM_TEST_WRITE_ERR"
"Define"	"TWI_EEPROM_TEST_INIT_ERR"	"Defines__TWI_EEPROM_TEST_INIT_ERR"
"Define"	"TWI_EEPROM_TEST_COMPARE_ERR"	"Defines__TWI_EEPROM_TEST_COMPARE_ERR"
"Define"	"TWI_EEPROM_TEST_WP_COMPARE_ERR"	"Defines__TWI_EEPROM_TEST_WP_COMPARE_ERR"
"Define"	"EPSON_REG_TEST_INIT_ERR"	"Defines__EPSON_REG_TEST_INIT_ERR"
"Define"	"EPSON_REG_TEST_WALKING_ERR"	"Defines__EPSON_REG_TEST_WALKING_ERR"
"Define"	"DECODER_AUDIO_TEST_INIT_ERR"	"Defines__DECODER_AUDIO_TEST_INIT_ERR"
"Define"	"DECODER_AUDIO_TEST_NO_AUDIO_ERR"	"Defines__DECODER_AUDIO_TEST_NO_AUDIO_ERR"
"Define"	"TW2815_REG_TEST_ERR"	"Defines__TW2815_REG_TEST_ERR"
"Define"	"TW2864_REG_TEST_ERR"	"Defines__TW2864_REG_TEST_ERR"
"Define"	"DECODER_VIDEO_TEST_INIT_ERR"	"Defines__DECODER_VIDEO_TEST_INIT_ERR"
"Define"	"DECODER_VIDEO_TEST_NO_VIDEO_ERR"	"Defines__DECODER_VIDEO_TEST_NO_VIDEO_ERR"
"Define"	"DECODER_VIDEO_TEST_TIMEOUT"	"Defines__DECODER_VIDEO_TEST_TIMEOUT"
"Define"	"DECODER_VIDDET_TEST_INIT_ERR"	"Defines__DECODER_VIDDET_TEST_INIT_ERR"
"Define"	"DECODER_VIDDET_TEST_UNKNOWN_CHIP"	"Defines__DECODER_VIDDET_TEST_UNKNOWN_CHIP"
"Define"	"DECODER_VIDDET_TEST_NO_INPUT_ERR"	"Defines__DECODER_VIDDET_TEST_NO_INPUT_ERR"
"Define"	"DECODER_VIDDET_TEST_CONFLICT_ERR"	"Defines__DECODER_VIDDET_TEST_CONFLICT_ERR"
"Define"	"DECODER_VIDDET_TEST_NO_SYNC_ERR"	"Defines__DECODER_VIDDET_TEST_NO_SYNC_ERR"
"Define"	"DECODER_AUDDET_TEST_NO_SYNC_ERR"	"Defines__DECODER_AUDDET_TEST_NO_SYNC_ERR"
"Define"	"DECODER_UNIQUE_VIDEO_TEST_ERR"	"Defines__DECODER_UNIQUE_VIDEO_TEST_ERR"
"Define"	"NVP1104_REG_TEST_ERR"	"Defines__NVP1104_REG_TEST_ERR"
"Define"	"NVP1114_REG_TEST_ERR"	"Defines__NVP1114_REG_TEST_ERR"
"Define"	"DECODER_AUDIO_TEST_TIMEOUT"	"Defines__DECODER_AUDIO_TEST_TIMEOUT"
"Define"	"DECODER_UNIQUE_AUDIO_TEST_ERR"	"Defines__DECODER_UNIQUE_AUDIO_TEST_ERR"
"Define"	"PCIE_EYEMASK_TEST_NO_CBB"	"Defines__PCIE_EYEMASK_TEST_NO_CBB"
"Define"	"PCIE_EYEMASK_TEST_ERR"	"Defines__PCIE_EYEMASK_TEST_ERR"
"Define"	"PCIE_EYEMASK_TEST_TIMEOUT"	"Defines__PCIE_EYEMASK_TEST_TIMEOUT"
"Define"	"AIM_TEST_ERRORS"	"Defines__AIM_TEST_ERRORS"
"Define"	"ASWITCH_ENABLE_ERR"	"Defines__ASWITCH_ENABLE_ERR"
"Define"	"SMO_ENABLE_ERR"	"Defines__SMO_ENABLE_ERR"
"Define"	"VOUT_ENABLE_ERR"	"Defines__VOUT_ENABLE_ERR"
"Define"	"IOBOARD_LOOPBACK_ERR"	"Defines__IOBOARD_LOOPBACK_ERR"
"Define"	"IOBOARD_CAMTERM_ERR"	"Defines__IOBOARD_CAMTERM_ERR"
"Define"	"IOBOARD_ALARMIN_ERR"	"Defines__IOBOARD_ALARMIN_ERR"
"Define"	"IOBOARD_ALARMOUT_ERR"	"Defines__IOBOARD_ALARMOUT_ERR"
"Define"	"IOBOARD_ALARMOUTRELAY_ERR"	"Defines__IOBOARD_ALARMOUTRELAY_ERR"
"Define"	"IOBOARD_LED_ERR"	"Defines__IOBOARD_LED_ERR"
"Define"	"GLOBAL_RESET_TEST_ERR"	"Defines__GLOBAL_RESET_TEST_ERR"
"Define"	"DVR_VSTD_UNKNOWN"	"Defines__DVR_VSTD_UNKNOWN"
"Define"	"DVR_VSTD_D1_PAL"	"Defines__DVR_VSTD_D1_PAL"
"Define"	"DVR_VSTD_D1_NTSC"	"Defines__DVR_VSTD_D1_NTSC"
"Define"	"DVR_VSTD_CIF_PAL"	"Defines__DVR_VSTD_CIF_PAL"
"Define"	"DVR_VSTD_CIF_NTSC"	"Defines__DVR_VSTD_CIF_NTSC"
"Define"	"DVR_VSTD_2CIF_PAL"	"Defines__DVR_VSTD_2CIF_PAL"
"Define"	"DVR_VSTD_2CIF_NTSC"	"Defines__DVR_VSTD_2CIF_NTSC"
"Define"	"DVR_VSTD_4CIF_PAL"	"Defines__DVR_VSTD_4CIF_PAL"
"Define"	"DVR_VSTD_4CIF_NTSC"	"Defines__DVR_VSTD_4CIF_NTSC"
"Define"	"DVR_VSTD_QCIF_PAL"	"Defines__DVR_VSTD_QCIF_PAL"
"Define"	"DVR_VSTD_QCIF_NTSC"	"Defines__DVR_VSTD_QCIF_NTSC"
"Define"	"DVR_JOB_STATE_VIDEO_LOST"	"Defines__DVR_JOB_STATE_VIDEO_LOST"
"Define"	"DVR_JOB_STATE_AUDIO_LOST"	"Defines__DVR_JOB_STATE_AUDIO_LOST"
"Define"	"DVR_FONT_OPCODE_START"	"Defines__DVR_FONT_OPCODE_START"
"Define"	"DVR_FONT_OPCODE_FINISH"	"Defines__DVR_FONT_OPCODE_FINISH"
"Define"	"DVR_FONT_OPCODE_SELECT"	"Defines__DVR_FONT_OPCODE_SELECT"
"Define"	"DVR_FONT_OPCODE_BUF_YY"	"Defines__DVR_FONT_OPCODE_BUF_YY"
"Define"	"DVR_FONT_OPCODE_BUF_UU"	"Defines__DVR_FONT_OPCODE_BUF_UU"
"Define"	"DVR_FONT_OPCODE_BUF_VV"	"Defines__DVR_FONT_OPCODE_BUF_VV"
"Define"	"DVR_FONT_OPCODE_BUF_UTF16"	"Defines__DVR_FONT_OPCODE_BUF_UTF16"
"Define"	"DVR_FONT_OPCODE_BUF_INDEX"	"Defines__DVR_FONT_OPCODE_BUF_INDEX"
"Define"	"DVR_FONT_OPCODE_BUF_WIDTH"	"Defines__DVR_FONT_OPCODE_BUF_WIDTH"
"Define"	"DVR_FONT_OPCODE_COPY"	"Defines__DVR_FONT_OPCODE_COPY"
"Define"	"DVR_FONT_OPCODE_COPY_DONE"	"Defines__DVR_FONT_OPCODE_COPY_DONE"
"Define"	"DVR_FONT_ENGLISH"	"Defines__DVR_FONT_ENGLISH"
"Define"	"DVR_FONT_FORMAT_YUV_4_2_0"	"Defines__DVR_FONT_FORMAT_YUV_4_2_0"
"Define"	"DVR_OSD_OPCODE_CONFIG"	"Defines__DVR_OSD_OPCODE_CONFIG"
"Define"	"DVR_OSD_OPCODE_SHOW"	"Defines__DVR_OSD_OPCODE_SHOW"
"Define"	"DVR_OSD_OPCODE_TEXT"	"Defines__DVR_OSD_OPCODE_TEXT"
"Define"	"DVR_OSD_OPCODE_CLEAR_TEXT"	"Defines__DVR_OSD_OPCODE_CLEAR_TEXT"
"Define"	"DVRFW_OSD_LEN"	"Defines__DVRFW_OSD_LEN"
"Define"	"DVR_AUTH_KEY_LEN"	"Defines__DVR_AUTH_KEY_LEN"
"Define"	"DVR_REGION_OPCODE_START"	"Defines__DVR_REGION_OPCODE_START"
"Define"	"DVR_REGION_OPCODE_FINISH"	"Defines__DVR_REGION_OPCODE_FINISH"
"Define"	"DVR_REGION_OPCODE_CONFIG"	"Defines__DVR_REGION_OPCODE_CONFIG"
"Define"	"DVR_REGION_OPCODE_ENABLE"	"Defines__DVR_REGION_OPCODE_ENABLE"
"Define"	"DVR_REGION_TYPE_MD"	"Defines__DVR_REGION_TYPE_MD"
"Define"	"DVR_REGION_TYPE_BD"	"Defines__DVR_REGION_TYPE_BD"
"Define"	"DVR_REGION_TYPE_ND"	"Defines__DVR_REGION_TYPE_ND"
"Define"	"DVR_REGION_TYPE_PR"	"Defines__DVR_REGION_TYPE_PR"
"Define"	"DVR_REGION_MAP_MAX_SIZE"	"Defines__DVR_REGION_MAP_MAX_SIZE"
"Define"	"DVR_VPP_OPCODE_CONTROL"	"Defines__DVR_VPP_OPCODE_CONTROL"
"Define"	"DVR_VPP_OPCODE_REGIONS"	"Defines__DVR_VPP_OPCODE_REGIONS"
"Define"	"DVR_DATA_HDR_SIG"	"Defines__DVR_DATA_HDR_SIG"
"Define"	"DVR_DATA_HDR_VER"	"Defines__DVR_DATA_HDR_VER"
"Define"	"DVR_DATA_HDR_LEN"	"Defines__DVR_DATA_HDR_LEN"
"Define"	"DVR_UART_CMD_CONFIG"	"Defines__DVR_UART_CMD_CONFIG"
"Define"	"DVR_UART_CMD_OUTPUT"	"Defines__DVR_UART_CMD_OUTPUT"
"Define"	"DVR_IOCTL_CODE_IMG_CONTROL"	"Defines__DVR_IOCTL_CODE_IMG_CONTROL"
"Define"	"DVR_IOCTL_CODE_DECODER_REGS"	"Defines__DVR_IOCTL_CODE_DECODER_REGS"
"Define"	"DVR_IOCTL_CODE_OPEN_CHAN"	"Defines__DVR_IOCTL_CODE_OPEN_CHAN"
"Define"	"DVR_IOCTL_CODE_CLOSE_CHAN"	"Defines__DVR_IOCTL_CODE_CLOSE_CHAN"
"Define"	"DVR_IOCTL_CODE_MOTION_FRAME_FREQ"	"Defines__DVR_IOCTL_CODE_MOTION_FRAME_FREQ"
"Define"	"DVR_IOCTL_CODE_VPP_CONTROL"	"Defines__DVR_IOCTL_CODE_VPP_CONTROL"
"Define"	"DVR_IOCTL_CODE_GAIN_MODE"	"Defines__DVR_IOCTL_CODE_GAIN_MODE"
"Define"	"DVR_IOCTL_CODE_TERMINATION"	"Defines__DVR_IOCTL_CODE_TERMINATION"
"Define"	"DVR_IOCTL_CODE_LED"	"Defines__DVR_IOCTL_CODE_LED"
"Define"	"DVR_IOCTL_CODE_RAWV_FORMAT"	"Defines__DVR_IOCTL_CODE_RAWV_FORMAT"
"Define"	"DVR_ICFLAG_HUE"	"Defines__DVR_ICFLAG_HUE"
"Define"	"DVR_ICFLAG_SAT"	"Defines__DVR_ICFLAG_SAT"
"Define"	"DVR_ICFLAG_BRT"	"Defines__DVR_ICFLAG_BRT"
"Define"	"DVR_ICFLAG_CONT"	"Defines__DVR_ICFLAG_CONT"
"Define"	"DVR_ICFLAG_SHARP"	"Defines__DVR_ICFLAG_SHARP"
"Define"	"DVR_VOUT_OPCODE_START"	"Defines__DVR_VOUT_OPCODE_START"
"Define"	"DVR_VOUT_OPCODE_STOP"	"Defines__DVR_VOUT_OPCODE_STOP"
"Section"	"Routines"	"Top__Routines"
"Section"	"Miscellaneous"	"Routines__Miscellaneous"
"Routine"	"DVR_JOB_NUM"	"Routines__DVR_JOB_NUM"
-->

<P>
</P>


<!-- SEC_DESCRIPTION_START -->

<a name="dvr_common_html_Top__Include"></a>
<H2>2.1 &nbsp; Include</H2>
<PRE class="ccode">
#include "dvr_common.h" 
</PRE>

<a name="dvr_common_html_Top__Introduction"></a>
<H2>2.2 &nbsp; Introduction</H2>
<P>
<A HREF="#dvr_common_html_start_of_file">dvr_common</A> is a collection of common declarations to be shared 
between the Stretch PCIe DVR card software and the Stretch DVR SDK  
running on the host PC. 
</P>

<a name="dvr_common_html_Top__Basic___Communication___Method___Between___the___PCIe___Card___and___the___Host___PC"></a>
<H2>2.3 &nbsp; Basic Communication Method Between the PCIe Card and the Host PC</H2>
<P>
The Stretch PCIe card communicates with the host PC via layered APIs. 
Sitting at the bottom level is the basic PCIe device drivers running 
on the board and on the host PC.  It provides basic PCIe hardware 
abstraction.  For details on the PCIe driver, refer to <STRONG>pci</STRONG> 
in Stretch SBIOS. 
</P>
<P>
The next level up is a basic communication layer <STRONG>sct</STRONG>.  <STRONG>sct</STRONG> 
provides basic communication channels and messages between the 
application code running on the PCIe card and on the host PC.   
Refer to <STRONG>sct</STRONG> for more details about the communication layer API. 
</P>
<P>
The next level up is the application code.  Specific to the DVR, 
the application code on the PCIe is generally referred to as <EM>DVR 
Firmware</EM> and the application code on the host PC as <EM>DVR SDK</EM>. 
Using <STRONG>sct</STRONG>, the DVR firmware and DVR SDK exchange all required data 
using agreed-upon <STRONG>sct</STRONG> messages and <STRONG>sct</STRONG> channels.  The purpose 
of this document is to detail the common message types, semantics of 
the message data, and the <STRONG>sct</STRONG> channel creation process.  This file must 
be included by the DVR firmware and DVR SDK to ensure consistency. 
</P>

<a name="dvr_common_html_Top__Usage___Model"></a>
<H2>2.4 &nbsp; Usage Model</H2>
<P>
This interface file is designed with a particular usage model in mind. 
Using a PCIe card is defined as creating and configuring various 
jobs running on the board.  The following is a list of basic 
jobs that the board supports: 
</P>
<UL>
<LI>
Encoding of a real-time camera input.  In this job, the input 
video is encoded and the bit stream is sent to the host. 
Optionally, a decimated raw input image can be sent to the Spot  
Monitor Out (SMO) or the host (HMO) for display. 
</LI>
<LI>
Decoding a bit stream supplied by the host.  In this job, the 
bit stream supplied by the host is decoded.  The decoded 
image can be sent to SMO or host for display. 
</LI>
<LI>
Encoding of raw images supplied by the host.  In this job, the 
raw images supplied by the host are encoded.  The resulting 
bit stream is sent back to the host.  Optionally, a decimated 
raw input image can be sent to the SMO for display. 
</LI>
</UL>
<P>
A job can be created, destroyed, configured, enabled, or disabled. 
The following are the rules must be obeyed when managing the jobs: 
</P>
<UL>
<LI>
A job must be created before it can be configured. 
</LI>
<LI>
A job can only be configured or reconfigured when it is disabled. 
(When a job is first created, it is disabled.) 
</LI>
</UL>
<P>
After a basic job is properly configured, it can be activated 
or deactivated.  These basic jobs are described in more 
detail in the following subsections. 
</P>

<a name="dvr_common_html_Top__Command___and___Response___Messages"></a>
<H3>2.4.1 &nbsp; Command and Response Messages</H3>
<P>
The host queries board state by sending <EM>GET</EM> messages. Information 
about a specific module is queried by sending a <EM>DVR_GET_xxx</EM> message. 
The board replies with the corresponding <EM>DVR_REP_xxx</EM> message. 
Job settings and state are modified by sending <EM>DVR_SET_xxx</EM> messages. 
The board replies to these using <EM>DVR_REP_xxx</EM> messages as well. 
The GET/SET/REP messages use the same data structure as payload. 
</P>

<a name="dvr_common_html_Top__Creating______Destroying______and___Configuring___a___Job"></a>
<H3>2.4.2 &nbsp; Creating, Destroying, and Configuring a Job</H3>
<P>
A specific handshake between the host application and the firmware 
must be followed when creating a job. A new job is created by the host 
application initiating the request. The following scenario describes 
the sequence to be followed in setting up a camera encode job. 
</P>
<UL>
<LI>
1) The host sends a <A HREF="#dvr_common_html_Types__DVR_SET_JOB">DVR_SET_JOB</A>  message with the control field set to 
<A HREF="#dvr_common_html_Types__DVR_JOB_CREATE">DVR_JOB_CREATE</A>. In response, the firmware opens a PCI port connection 
for sending data, initializes the dataport for its camera input, and 
pre-allocates all the necessary resources for the job. 
</LI>
<LI>
2) The host calls the <STRONG>sct_channel_accept</STRONG> function to accept the 
data connection from the board. 
(The host DVR application must call the macro DVR_JOB_NUM to get  
the PCI port number.) 
</LI>
<LI>
3) The host waits for the <A HREF="#dvr_common_html_Types__DVR_REP_JOB">DVR_REP_JOB</A> message from the firmware. 
</LI>
</UL>
<P>
To destroy the job: 
</P>
<UL>
<LI>
1) The host sends a <A HREF="#dvr_common_html_Types__DVR_SET_JOB">DVR_SET_JOB</A> message with control field set 
to <A HREF="#dvr_common_html_Types__DVR_JOB_DESTROY">DVR_JOB_DESTROY</A>. In response, the firmware closes the PCI port  
connection and frees up all resources allocated for this job. 
</LI>
<LI>
2) The host calls the <STRONG>sct_channel_close</STRONG> function to shut down 
the data connection to the job. 
</LI>
<LI>
3) The host waits for <A HREF="#dvr_common_html_Types__DVR_REP_JOB">DVR_REP_JOB</A> message from the firmware. 
</LI>
</UL>

<a name="dvr_common_html_Top__Dynamic___Control___of___Basic___Jobs"></a>
<H3>2.4.3 &nbsp; Dynamic Control of Basic Jobs</H3>
<P>
One special group of messages are used to activate or deactivate jobs 
on the board.  The messages are <A HREF="#dvr_common_html_Types__DVR_GET_JOB">DVR_GET_JOB</A>, <A HREF="#dvr_common_html_Types__DVR_SET_JOB">DVR_SET_JOB</A>, 
and <A HREF="#dvr_common_html_Types__DVR_REP_JOB">DVR_REP_JOB</A>. 
</P>

<a name="dvr_common_html_Top__A___Convention"></a>
<H2>2.5 &nbsp; A Convention</H2>
<P>
We use the following convention to uniquely associate a message  
with a particular instance of a job:   
</P>
<UL>
<LI>
A job type, which must be one of 
<A HREF="#dvr_common_html_Types__DVR_JOB_CAMERA_ENCODE">DVR_JOB_CAMERA_ENCODE</A>, <A HREF="#dvr_common_html_Types__DVR_JOB_HOST_DECODE">DVR_JOB_HOST_DECODE</A>, 
or <A HREF="#dvr_common_html_Types__DVR_JOB_HOST_ENCODE">DVR_JOB_HOST_ENCODE</A>. 
</LI>
<LI>
A job id, which is a 8-bit number.  The IDs do not have 
to start at 0 and do not need to be sequential. 
</LI>
</UL>

<a name="dvr_common_html_Top__Data___Communication___Between___Firmware___and___SDK"></a>
<H2>2.6 &nbsp; Data Communication Between Firmware and SDK</H2>
<P>
All data exchanged between board and host are between specific 
job on the board and SDK on the host.  A job on the board 
is uniquely identified by its type and id.  By combining 
the board id, the job type and the job ID into a single 16 number  
&lt;board_id, job_type, job_id&gt;, 
we have a unique job number (JN).  This JN will be used 
as the port number for exchange all the data between  
the job and the SDK.  The macro DVR_JOB_NUM should 
be used to construct the job number to ensure 
compatability between SDK and firmware. 
</P>
<P>
The actual data exchanged is either raw video, raw audio, 
or bitstream.  In addition, other ancillary data might 
be needed.  So, the following convention will be used 
to exchange the data. 
</P>
<P>
Data buffers sent to or received from the board are of 
variable size. When the system is initialized, buffers 
are allocated to handle the maximum possible size. The 
maximum is currently defined by one frame of raw YUV 
data for a D1 PAL image, the buffer size being determined 
by the Y plane size which is the largest component. 
For decimated images, encoded frames, and ancillary data, 
the actual transfer sizes could be a lot smaller. 
</P>
<P>
All data buffers must begin with a header of type 
<A HREF="#dvr_common_html_Types__dvr_data_header_t">dvr_data_header_t</A>. This allows identification of the job 
associated with the data, specifies the transfer size, and 
provides other ancillary information. The rest of the data 
follows the header. The total number of bytes transferred is 
equal to the size of the header structure plus the actual 
buffer size. 
</P>

<a name="dvr_common_html_Top__Asynchronous___Events"></a>
<H2>2.7 &nbsp; Asynchronous Events</H2>
<P>
The board can generate the following asynchronous events. 
These are all signalled to the host via the <A HREF="#dvr_common_html_Types__DVR_SIG_HOST">DVR_SIG_HOST</A> 
message. 
</P>
<UL>
<LI>
- Sensor activated. 
</LI>
<LI>
- Motion detection alarm triggered. 
</LI>
<LI>
- Blind detection alarm triggered. 
</LI>
<LI>
- Night detection alarm triggered. 
</LI>
<LI>
- Video signal from camera lost. 
</LI>
<LI>
- Video signal from camera detected. 
</LI>
<LI>
- Runtime error in the firmware. 
</LI>
<LI>
- Fatal error in the firmware. 
</LI>
<LI>
- Board heartbeat. (This is currently not implemented). 
</LI>
</UL>

<a name="dvr_common_html_Top__Restrictions"></a>
<H2>2.8 &nbsp; Restrictions</H2>
<P>
The resolutions at which a video channel (incoming or decoded) 
can be displayed on the spot monitor (SMO) or the host monitor 
(HMO) are restricted to its original resolution, 2x-decimated, or 
4x-decimated resolutions. Enlargement is not supported. 
</P>

<!-- SEC_DESCRIPTION_CLOSE -->

<!-- SEC_TYPES_START -->

<a name="dvr_common_html_Top__Types"></a>
<H2>2.9 &nbsp; Types</H2>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_status_e"></a>
<PRE class="cdef">
typedef enum <A HREF="#dvr_common_html_Types__dvr_status_enum">dvr_status_enum</A> <A HREF="#dvr_common_html_Types__dvr_status_e">dvr_status_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
This is a work around for MSC compiler. The <EM>:n</EM> with  
enum type fields within a structure is not supported. See  
<A HREF="#dvr_common_html_Types__dvr_status_enum">dvr_status_enum</A> for the description of this type. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_chip_rev_e"></a>
<PRE class="cdef">
typedef enum <A HREF="#dvr_common_html_Types__dvr_chip_rev_enum">dvr_chip_rev_enum</A> <A HREF="#dvr_common_html_Types__dvr_chip_rev_e">dvr_chip_rev_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
This is a work around for MSC compiler. The <EM>:n</EM> with  
enum type fields within a structure is not supported. See  
<A HREF="#dvr_common_html_Types__dvr_chip_rev_enum">dvr_chip_rev_enum</A> for the description of this type. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_job_type_e"></a>
<PRE class="cdef">
typedef enum <A HREF="#dvr_common_html_Types__dvr_job_type_enum">dvr_job_type_enum</A> <A HREF="#dvr_common_html_Types__dvr_job_type_e">dvr_job_type_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
This is a work around for MSC compiler. The <EM>:n</EM> with  
enum type fields within a structure is not supported. See  
<A HREF="#dvr_common_html_Types__dvr_job_type_enum">dvr_job_type_enum</A> for the description of this type. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_video_res_e"></a>
<PRE class="cdef">
typedef enum <A HREF="#dvr_common_html_Types__dvr_video_res_enum">dvr_video_res_enum</A> <A HREF="#dvr_common_html_Types__dvr_video_res_e">dvr_video_res_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
This is a work around for MSC compiler. The <EM>:n</EM> with  
enum type fields within a structure is not supported. See  
<A HREF="#dvr_common_html_Types__dvr_video_res_enum">dvr_video_res_enum</A> for the description of this type. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_vc_format_e"></a>
<PRE class="cdef">
typedef enum <A HREF="#dvr_common_html_Types__dvr_vc_format_enum">dvr_vc_format_enum</A> <A HREF="#dvr_common_html_Types__dvr_vc_format_e">dvr_vc_format_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
This is a work around for MSC compiler. The <EM>:n</EM> with  
enum type fields within a structure is not supported. See  
<A HREF="#dvr_common_html_Types__dvr_vc_format_enum">dvr_vc_format_enum</A> for the description of this type. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_ac_format_e"></a>
<PRE class="cdef">
typedef enum <A HREF="#dvr_common_html_Types__dvr_ac_format_enum">dvr_ac_format_enum</A> <A HREF="#dvr_common_html_Types__dvr_ac_format_e">dvr_ac_format_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
This is a work around for MSC compiler. The <EM>:n</EM> with  
enum type fields within a structure is not supported. See  
<A HREF="#dvr_common_html_Types__dvr_ac_format_enum">dvr_ac_format_enum</A> for the description of this type. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_vpp_mode_e"></a>
<PRE class="cdef">
typedef enum <A HREF="#dvr_common_html_Types__dvr_vpp_mode_enum">dvr_vpp_mode_enum</A> <A HREF="#dvr_common_html_Types__dvr_vpp_mode_e">dvr_vpp_mode_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
This is a work around for MSC compiler. The <EM>:n</EM> with  
enum type fields within a structure is not supported. See  
<A HREF="#dvr_common_html_Types__dvr_vpp_mode_enum">dvr_vpp_mode_enum</A> for the description of this type. 
</P>
<P>
<STRONG>NOTE</STRONG>: This is deprecated and will be removed in a future release. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_vpp_action_e"></a>
<PRE class="cdef">
typedef enum <A HREF="#dvr_common_html_Types__dvr_vpp_action_enum">dvr_vpp_action_enum</A> <A HREF="#dvr_common_html_Types__dvr_vpp_action_e">dvr_vpp_action_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
This is a work around for MSC compiler. The <EM>:n</EM> with  
enum type fields within a structure is not supported. See  
<A HREF="#dvr_common_html_Types__dvr_vpp_action_enum">dvr_vpp_action_enum</A> for the description of this type. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_rc_e"></a>
<PRE class="cdef">
typedef enum <A HREF="#dvr_common_html_Types__dvr_rc_enum">dvr_rc_enum</A> <A HREF="#dvr_common_html_Types__dvr_rc_e">dvr_rc_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
This is a work around for MSC compiler. The <EM>:n</EM> with  
enum type fields within a structure is not supported. See  
<A HREF="#dvr_common_html_Types__dvr_rc_enum">dvr_rc_enum</A> for the description of this type. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_job_action_e"></a>
<PRE class="cdef">
typedef enum <A HREF="#dvr_common_html_Types__dvr_job_action_enum">dvr_job_action_enum</A> <A HREF="#dvr_common_html_Types__dvr_job_action_e">dvr_job_action_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
This is a work around for MSC compiler. The <EM>:n</EM> with  
enum type fields within a structure is not supported. See  
<A HREF="#dvr_common_html_Types__dvr_job_action_enum">dvr_job_action_enum</A> for the description of this type. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_osd_pos_e"></a>
<PRE class="cdef">
typedef enum <A HREF="#dvr_common_html_Types__dvr_osd_pos_enum">dvr_osd_pos_enum</A> <A HREF="#dvr_common_html_Types__dvr_osd_pos_e">dvr_osd_pos_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
This is a work around for MSC compiler. The <EM>:n</EM> with  
enum type fields within a structure is not supported. See  
<A HREF="#dvr_common_html_Types__dvr_osd_pos_enum">dvr_osd_pos_enum</A> for the description of this type. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_osd_dts_e"></a>
<PRE class="cdef">
typedef enum <A HREF="#dvr_common_html_Types__dvr_osd_dts_enum">dvr_osd_dts_enum</A> <A HREF="#dvr_common_html_Types__dvr_osd_dts_e">dvr_osd_dts_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
This is a work around for MSC compiler. The <EM>:n</EM> with  
enum type fields within a structure is not supported. See  
<A HREF="#dvr_common_html_Types__dvr_osd_dts_enum">dvr_osd_dts_enum</A> for the description of this type. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_data_type_e"></a>
<PRE class="cdef">
typedef enum <A HREF="#dvr_common_html_Types__dvr_data_type_enum">dvr_data_type_enum</A> <A HREF="#dvr_common_html_Types__dvr_data_type_e">dvr_data_type_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
This is a work around for MSC compiler. The <EM>:n</EM> with  
enum type fields within a structure is not supported. See  
<A HREF="#dvr_common_html_Types__dvr_data_type_enum">dvr_data_type_enum</A> for the description of this type. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_signal_type_e"></a>
<PRE class="cdef">
typedef enum <A HREF="#dvr_common_html_Types__dvr_signal_type_enum">dvr_signal_type_enum</A> <A HREF="#dvr_common_html_Types__dvr_signal_type_e">dvr_signal_type_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
This is a work around for MSC compiler. The <EM>:n</EM> with  
enum type fields within a structure is not supported. See  
<A HREF="#dvr_common_html_Types__dvr_signal_type_enum">dvr_signal_type_enum</A> for the description of this type. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_term_e"></a>
<PRE class="cdef">
typedef enum <A HREF="#dvr_common_html_Types__dvr_term_enum">dvr_term_enum</A> <A HREF="#dvr_common_html_Types__dvr_term_e">dvr_term_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
This is a work around for MSC compiler. The <EM>:n</EM> with  
enum type fields within a structure is not supported. See  
<A HREF="#dvr_common_html_Types__dvr_term_enum">dvr_term_enum</A> for the description of this type. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_led_type_e"></a>
<PRE class="cdef">
typedef enum <A HREF="#dvr_common_html_Types__dvr_led_type_enum">dvr_led_type_enum</A> <A HREF="#dvr_common_html_Types__dvr_led_type_e">dvr_led_type_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
This is a work around for MSC compiler. The <EM>:n</EM> with  
enum type fields within a structure is not supported. See  
<A HREF="#dvr_common_html_Types__dvr_led_type_enum">dvr_led_type_enum</A> for the description of this type. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_message_e"></a>
<PRE class="cdef">
typedef enum <A HREF="#dvr_common_html_Types__dvr_message_enum">dvr_message_enum</A> <A HREF="#dvr_common_html_Types__dvr_message_e">dvr_message_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
This is a work around for MSC compiler. The <EM>:n</EM> with  
enum type fields within a structure is not supported. See  
<A HREF="#dvr_common_html_Types__dvr_message_enum">dvr_message_enum</A> for the description of this type. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_rawv_format_e"></a>
<PRE class="cdef">
typedef enum <A HREF="#dvr_common_html_Types__dvr_rawv_format_enum">dvr_rawv_format_enum</A> <A HREF="#dvr_common_html_Types__dvr_rawv_format_e">dvr_rawv_format_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
This is a work around for MSC compiler. The <EM>:n</EM> with  
enum type fields within a structure is not supported. See  
<A HREF="#dvr_common_html_Types__dvr_rawv_format_enum">dvr_rawv_format_enum</A> for the description of this type. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_status_enum"></a>
<PRE class="cdef">
enum <A HREF="#dvr_common_html_Types__dvr_status_enum">dvr_status_enum</A> {
    <A name="dvr_common_html_Types__DVR_STATUS_OK">DVR_STATUS_OK</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_WRONG_CAMERA_NUMBER">DVR_STATUS_WRONG_CAMERA_NUMBER</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_WRONG_CAMERA_TYPE">DVR_STATUS_WRONG_CAMERA_TYPE</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_WRONG_CODEC_FORMAT">DVR_STATUS_WRONG_CODEC_FORMAT</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_WRONG_CODEC_RESOLUTION">DVR_STATUS_WRONG_CODEC_RESOLUTION</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_WRONG_JOB_TYPE">DVR_STATUS_WRONG_JOB_TYPE</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_WRONG_JOB_ID">DVR_STATUS_WRONG_JOB_ID</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_WRONG_VIDEO_FORMAT">DVR_STATUS_WRONG_VIDEO_FORMAT</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_WRONG_AUDIO_FORMAT">DVR_STATUS_WRONG_AUDIO_FORMAT</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_EXCEED_CPU_LIMIT">DVR_STATUS_EXCEED_CPU_LIMIT</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_JOB_NOT_CREATED">DVR_STATUS_JOB_NOT_CREATED</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_JOB_ALREADY_CREATED">DVR_STATUS_JOB_ALREADY_CREATED</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_JOB_NOT_ENABLED">DVR_STATUS_JOB_NOT_ENABLED</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_JOB_NOT_DISABLED">DVR_STATUS_JOB_NOT_DISABLED</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_SMO_NOT_CREATED">DVR_STATUS_SMO_NOT_CREATED</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_INVALID_TIME">DVR_STATUS_INVALID_TIME</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_ILLEGAL_SMO_PARAMS">DVR_STATUS_ILLEGAL_SMO_PARAMS</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_SMO_NOT_SUPPORTED">DVR_STATUS_SMO_NOT_SUPPORTED</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_VDET_ERROR">DVR_STATUS_VDET_ERROR</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_RUNTIME_ERROR">DVR_STATUS_RUNTIME_ERROR</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_VPP_RUNTIME_ERROR">DVR_STATUS_VPP_RUNTIME_ERROR</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_ENCODER_RUNTIME_ERROR">DVR_STATUS_ENCODER_RUNTIME_ERROR</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_DECODER_RUNTIME_ERROR">DVR_STATUS_DECODER_RUNTIME_ERROR</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_ILLEGAL_PARAMETER">DVR_STATUS_ILLEGAL_PARAMETER</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_INTERNAL_ERROR">DVR_STATUS_INTERNAL_ERROR</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_ILLEGAL_COMMAND">DVR_STATUS_ILLEGAL_COMMAND</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_SMO_NOT_DISABLED">DVR_STATUS_SMO_NOT_DISABLED</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_OUT_OF_MEMORY">DVR_STATUS_OUT_OF_MEMORY</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_NO_IO_BOARD">DVR_STATUS_NO_IO_BOARD</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_AUDIO_RUNTIME_ERROR">DVR_STATUS_AUDIO_RUNTIME_ERROR</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_UNSUPPORTED_COMMAND">DVR_STATUS_UNSUPPORTED_COMMAND</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_SMO_CHAN_FAILED">DVR_STATUS_SMO_CHAN_FAILED</A>,
    <A name="dvr_common_html_Types__DVR_STATUS_RES_LIMIT_EXCEEDED">DVR_STATUS_RES_LIMIT_EXCEEDED</A>
} ; 
</PRE>
<DIV CLASS="descr">
<P>
Status for all message exchanges. All reply messages must set the 
status field to let the originator know how the message was handled. 
<A HREF="#dvr_common_html_Types__DVR_STATUS_OK">DVR_STATUS_OK</A> means a message was successfully processed. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_chip_rev_enum"></a>
<PRE class="cdef">
enum <A HREF="#dvr_common_html_Types__dvr_chip_rev_enum">dvr_chip_rev_enum</A> {
    <A name="dvr_common_html_Types__CHIP_S6100_3_REV_C">CHIP_S6100_3_REV_C</A>,
    <A name="dvr_common_html_Types__CHIP_S6105_3_REV_C">CHIP_S6105_3_REV_C</A>,
    <A name="dvr_common_html_Types__CHIP_S6106_3_REV_C">CHIP_S6106_3_REV_C</A>,
    <A name="dvr_common_html_Types__CHIP_S6100_3_REV_D">CHIP_S6100_3_REV_D</A>,
    <A name="dvr_common_html_Types__CHIP_S6105_3_REV_D">CHIP_S6105_3_REV_D</A>,
    <A name="dvr_common_html_Types__CHIP_S6106_3_REV_D">CHIP_S6106_3_REV_D</A>,
    <A name="dvr_common_html_Types__CHIP_S6100_3_REV_F">CHIP_S6100_3_REV_F</A>,
    <A name="dvr_common_html_Types__CHIP_S6105_3_REV_F">CHIP_S6105_3_REV_F</A>,
    <A name="dvr_common_html_Types__CHIP_S6106_3_REV_F">CHIP_S6106_3_REV_F</A>,
    <A name="dvr_common_html_Types__CHIP_S6100_3_UNKNOWN">CHIP_S6100_3_UNKNOWN</A>,
    <A name="dvr_common_html_Types__CHIP_S6105_3_UNKNOWN">CHIP_S6105_3_UNKNOWN</A>,
    <A name="dvr_common_html_Types__CHIP_S6106_3_UNKNOWN">CHIP_S6106_3_UNKNOWN</A>,
    <A name="dvr_common_html_Types__CHIP_UNKNOWN">CHIP_UNKNOWN</A>
} ; 
</PRE>
<DIV CLASS="descr">
<P>
Chip revision definitions. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_job_type_enum"></a>
<PRE class="cdef">
enum <A HREF="#dvr_common_html_Types__dvr_job_type_enum">dvr_job_type_enum</A> {
    <A name="dvr_common_html_Types__DVR_JOB_CAMERA_ENCODE">DVR_JOB_CAMERA_ENCODE</A>,
    <A name="dvr_common_html_Types__DVR_JOB_HOST_ENCODE">DVR_JOB_HOST_ENCODE</A>,
    <A name="dvr_common_html_Types__DVR_JOB_HOST_DECODE">DVR_JOB_HOST_DECODE</A>,
    <A name="dvr_common_html_Types__DVR_JOB_VIDEO_OUTPUT">DVR_JOB_VIDEO_OUTPUT</A>
} ; 
</PRE>
<DIV CLASS="descr">
<P>
Supported job types. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_JOB_CAMERA_ENCODE">DVR_JOB_CAMERA_ENCODE</A> encodes real-time video captured by a camera. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_JOB_HOST_ENCODE">DVR_JOB_HOST_ENCODE</A>   encodes raw images supplied by the host. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_JOB_HOST_DECODE">DVR_JOB_HOST_DECODE</A>   decodes bitstreams supplied by the host. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_JOB_VIDEO_OUTPUT">DVR_JOB_VIDEO_OUTPUT</A>  manages video output from the board. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_video_res_enum"></a>
<PRE class="cdef">
enum <A HREF="#dvr_common_html_Types__dvr_video_res_enum">dvr_video_res_enum</A> {
    <A name="dvr_common_html_Types__DVR_VIDEO_RES_INVALID">DVR_VIDEO_RES_INVALID</A>,
    <A name="dvr_common_html_Types__DVR_VIDEO_RES_FULL">DVR_VIDEO_RES_FULL</A>,
    <A name="dvr_common_html_Types__DVR_VIDEO_RES_CIF">DVR_VIDEO_RES_CIF</A>,
    <A name="dvr_common_html_Types__DVR_VIDEO_RES_QCIF">DVR_VIDEO_RES_QCIF</A>,
    <A name="dvr_common_html_Types__DVR_VIDEO_RES_HALF">DVR_VIDEO_RES_HALF</A>,
    <A name="dvr_common_html_Types__DVR_VIDEO_RES_DCIF">DVR_VIDEO_RES_DCIF</A>,
    <A name="dvr_common_html_Types__DVR_VIDEO_RES_CLASSIC_CIF">DVR_VIDEO_RES_CLASSIC_CIF</A>,
    <A name="dvr_common_html_Types__DVR_VIDEO_RES_CLASSIC_2CIF">DVR_VIDEO_RES_CLASSIC_2CIF</A>,
    <A name="dvr_common_html_Types__DVR_VIDEO_RES_CLASSIC_4CIF">DVR_VIDEO_RES_CLASSIC_4CIF</A>
} ; 
</PRE>
<DIV CLASS="descr">
<P>
Video output resolution formats. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_VIDEO_RES_INVALID">DVR_VIDEO_RES_INVALID</A> - Invalid. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_VIDEO_RES_FULL">DVR_VIDEO_RES_FULL</A>    - Full size picture, size depends on the video 
standard selected. For D1, it is 720x480 (NTSC) or 720x576 (PAL). For 
4CIF, it is 704x480 (NTSC) or 704x576 (PAL). 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_VIDEO_RES_CIF">DVR_VIDEO_RES_CIF</A>     - CIF size.  352x240 (NTSC) or 352x288 (PAL). 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_VIDEO_RES_QCIF">DVR_VIDEO_RES_QCIF</A>    - QCIF size. 176x112 (NTSC) or 176x144 (PAL). 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_VIDEO_RES_HALF">DVR_VIDEO_RES_HALF</A>    - Half size. Same width as <A HREF="#dvr_common_html_Types__DVR_VIDEO_RES_FULL">DVR_VIDEO_RES_FULL</A> 
but half the height. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_VIDEO_RES_DCIF">DVR_VIDEO_RES_DCIF</A>    - DCIF size. 528x320 (NTSC) or 528x384 (PAL). 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_VIDEO_RES_CLASSIC_CIF">DVR_VIDEO_RES_CLASSIC_CIF</A> - 320x240 - Not supported for  
encoding or decoding. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_VIDEO_RES_CLASSIC_2CIF">DVR_VIDEO_RES_CLASSIC_2CIF</A> - 640x240  - Not supported for  
encoding or decoding. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_VIDEO_RES_CLASSIC_4CIF">DVR_VIDEO_RES_CLASSIC_4CIF</A> - 640x480  - Not supported for  
encoding or decoding. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_vc_format_enum"></a>
<PRE class="cdef">
enum <A HREF="#dvr_common_html_Types__dvr_vc_format_enum">dvr_vc_format_enum</A> {
    <A name="dvr_common_html_Types__DVR_VC_FORMAT_NONE">DVR_VC_FORMAT_NONE</A>,
    <A name="dvr_common_html_Types__DVR_VC_FORMAT_H264">DVR_VC_FORMAT_H264</A>,
    <A name="dvr_common_html_Types__DVR_VC_FORMAT_JPEG">DVR_VC_FORMAT_JPEG</A>,
    <A name="dvr_common_html_Types__DVR_VC_FORMAT_MPEG4">DVR_VC_FORMAT_MPEG4</A>
} ; 
</PRE>
<DIV CLASS="descr">
<P>
Video encoding and decoding formats. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_VC_FORMAT_NONE">DVR_VC_FORMAT_NONE</A>     no video codec. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_VC_FORMAT_H264">DVR_VC_FORMAT_H264</A>     H.264 baseline. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_VC_FORMAT_JPEG">DVR_VC_FORMAT_JPEG</A>     motion JPEG. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_VC_FORMAT_MPEG4">DVR_VC_FORMAT_MPEG4</A>    MPEG4 simple profile. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_ac_format_enum"></a>
<PRE class="cdef">
enum <A HREF="#dvr_common_html_Types__dvr_ac_format_enum">dvr_ac_format_enum</A> {
    <A name="dvr_common_html_Types__DVR_AC_FORMAT_NONE">DVR_AC_FORMAT_NONE</A>,
    <A name="dvr_common_html_Types__DVR_AC_FORMAT_G711">DVR_AC_FORMAT_G711</A>,
    <A name="dvr_common_html_Types__DVR_AC_FORMAT_G726_16K">DVR_AC_FORMAT_G726_16K</A>,
    <A name="dvr_common_html_Types__DVR_AC_FORMAT_G726_24K">DVR_AC_FORMAT_G726_24K</A>,
    <A name="dvr_common_html_Types__DVR_AC_FORMAT_G726_32K">DVR_AC_FORMAT_G726_32K</A>,
    <A name="dvr_common_html_Types__DVR_AC_FORMAT_G726_48K">DVR_AC_FORMAT_G726_48K</A>
} ; 
</PRE>
<DIV CLASS="descr">
<P>
Audio encoding and decoding formats. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_AC_FORMAT_NONE">DVR_AC_FORMAT_NONE</A>        no audio codec. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_AC_FORMAT_G711">DVR_AC_FORMAT_G711</A>        G.711 audio. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_AC_FORMAT_G726_16K">DVR_AC_FORMAT_G726_16K</A>    G.726 audio at 16 Kbits/sec. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_AC_FORMAT_G726_32K">DVR_AC_FORMAT_G726_32K</A>    G.726 audio at 32 Kbits/sec. 
</P>
<P>
The other formats defined are not currently supported. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_vpp_mode_enum"></a>
<PRE class="cdef">
enum <A HREF="#dvr_common_html_Types__dvr_vpp_mode_enum">dvr_vpp_mode_enum</A> {
    <A name="dvr_common_html_Types__DVR_VPP_MODE_SLATERAL">DVR_VPP_MODE_SLATERAL</A>,
    <A name="dvr_common_html_Types__DVR_VPP_MODE_ANALYTICS">DVR_VPP_MODE_ANALYTICS</A>
} ; 
</PRE>
<DIV CLASS="descr">
<P>
Video pre-processing modes. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_VPP_MODE_SLATERAL">DVR_VPP_MODE_SLATERAL</A>     Run VPP in Stretch-lateral-filter mode. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_VPP_MODE_ANALYTICS">DVR_VPP_MODE_ANALYTICS</A>    Run VPP in analytics mode. 
</P>
<P>
<STRONG>NOTE</STRONG>: These flags are deprecated. They are ignored by the firmware 
and will be removed in a future release. Use VPP actions to control 
video preprocessing (see <A HREF="#dvr_common_html_Types__dvr_vpp_action_enum">dvr_vpp_action_enum</A>). 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_vpp_action_enum"></a>
<PRE class="cdef">
enum <A HREF="#dvr_common_html_Types__dvr_vpp_action_enum">dvr_vpp_action_enum</A> {
    <A name="dvr_common_html_Types__DVR_VPP_ACTION_ANALYTIC">DVR_VPP_ACTION_ANALYTIC</A>,
    <A name="dvr_common_html_Types__DVR_VPP_ACTION_DEINTERLACE">DVR_VPP_ACTION_DEINTERLACE</A>,
    <A name="dvr_common_html_Types__DVR_VPP_ACTION_MEDIAN_FILTER">DVR_VPP_ACTION_MEDIAN_FILTER</A>,
    <A name="dvr_common_html_Types__DVR_VPP_ACTION_SLATERAL">DVR_VPP_ACTION_SLATERAL</A>
} ; 
</PRE>
<DIV CLASS="descr">
<P>
Video preprocessing actions supported. Each action is independent of 
the others. Action flags must be or-ed together to specify a combined 
set of actions. 
</P>
<P>
<STRONG>NOTE</STRONG>: Some actions may impact the frame rate when enabled. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_VPP_ACTION_ANALYTIC">DVR_VPP_ACTION_ANALYTIC</A>       Enables VPP analytics. If this action 
is disabled then motion detection, night detection, blind detection 
and privacy blocking will all be disabled. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_VPP_ACTION_DEINTERLACE">DVR_VPP_ACTION_DEINTERLACE</A>    Enables deinterlacing. If this action 
is disabled then the picture will remain in interlaced format, with 2 
separate fields. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_VPP_ACTION_MEDIAN_FILTER">DVR_VPP_ACTION_MEDIAN_FILTER</A>  Enables median filtering as a part of 
deinterlacing. If this action is disabled then the two fields will be 
weaved together but no filtering will be performed. If deinterlacing 
is disabled, this action will have no effect. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_VPP_ACTION_SLATERAL">DVR_VPP_ACTION_SLATERAL</A>       Enables Stretch-lateral noise filtering. 
</P>
<P>
<STRONG>NOTE</STRONG>: The default preprocessing configuration at startup is set to 
( <A HREF="#dvr_common_html_Types__DVR_VPP_ACTION_ANALYTIC">DVR_VPP_ACTION_ANALYTIC</A> | <A HREF="#dvr_common_html_Types__DVR_VPP_ACTION_DEINTERLACE">DVR_VPP_ACTION_DEINTERLACE</A> | <A HREF="#dvr_common_html_Types__DVR_VPP_ACTION_MEDIAN_FILTER">DVR_VPP_ACTION_MEDIAN_FILTER</A> | 
<A HREF="#dvr_common_html_Types__DVR_VPP_ACTION_SLATERAL">DVR_VPP_ACTION_SLATERAL</A> ). 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_rc_enum"></a>
<PRE class="cdef">
enum <A HREF="#dvr_common_html_Types__dvr_rc_enum">dvr_rc_enum</A> {
    <A name="dvr_common_html_Types__DVR_RC_NONE">DVR_RC_NONE</A>,
    <A name="dvr_common_html_Types__DVR_RC_VBR">DVR_RC_VBR</A>,
    <A name="dvr_common_html_Types__DVR_RC_CBR">DVR_RC_CBR</A>,
    <A name="dvr_common_html_Types__DVR_RC_CQP"><A HREF="#dvr_common_html_Types__DVR_RC_CQ">DVR_RC_CQ</A>P</A>,
    <A name="dvr_common_html_Types__DVR_RC_CQ">DVR_RC_CQ</A>
} ; 
</PRE>
<DIV CLASS="descr">
<P>
Encoder rate-control algorithm selectors. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_RC_VBR">DVR_RC_VBR</A> generates a variable bit rate stream. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_RC_CBR">DVR_RC_CBR</A> generates a constant bit rate stream. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_RC_CQP">DVR_RC_CQP</A> generates a constant QP stream. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_RC_CQ">DVR_RC_CQ</A>  generates a constant quality stream. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_RC_CQP">DVR_RC_CQP</A> is not supported at this time. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_job_action_enum"></a>
<PRE class="cdef">
enum <A HREF="#dvr_common_html_Types__dvr_job_action_enum">dvr_job_action_enum</A> {
    <A name="dvr_common_html_Types__DVR_JOB_CREATE">DVR_JOB_CREATE</A>,
    <A name="dvr_common_html_Types__DVR_JOB_DESTROY">DVR_JOB_DESTROY</A>,
    <A name="dvr_common_html_Types__DVR_JOB_RESET">DVR_JOB_RESET</A>
} ; 
</PRE>
<DIV CLASS="descr">
<P>
Defines job control constants. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_JOB_CREATE">DVR_JOB_CREATE</A>    creates a new job. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_JOB_DESTROY">DVR_JOB_DESTROY</A>   destroys an existing job. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_JOB_RESET">DVR_JOB_RESET</A>     resets a job to its default configuration. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_osd_pos_enum"></a>
<PRE class="cdef">
enum <A HREF="#dvr_common_html_Types__dvr_osd_pos_enum">dvr_osd_pos_enum</A> {
    <A name="dvr_common_html_Types__DVR_OSD_POS_TL">DVR_OSD_POS_TL</A>,
    <A name="dvr_common_html_Types__DVR_OSD_POS_BL">DVR_OSD_POS_BL</A>,
    <A name="dvr_common_html_Types__DVR_OSD_POS_TR">DVR_OSD_POS_TR</A>,
    <A name="dvr_common_html_Types__DVR_OSD_POS_BR">DVR_OSD_POS_BR</A>,
    <A name="dvr_common_html_Types__DVR_OSD_POS_CUSTOM">DVR_OSD_POS_CUSTOM</A>
} ; 
</PRE>
<DIV CLASS="descr">
<P>
Defines the on-screen display style. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_OSD_POS_TL">DVR_OSD_POS_TL</A>     puts OSD at top-left corner. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_OSD_POS_BL">DVR_OSD_POS_BL</A>     puts OSD at bottom-left corner. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_OSD_POS_TR">DVR_OSD_POS_TR</A>     puts OSD at top-right corner. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_OSD_POS_BR">DVR_OSD_POS_BR</A>     puts OSD at bottom-right corner. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_OSD_POS_CUSTOM">DVR_OSD_POS_CUSTOM</A> puts OSD at the specified location on the screen. 
This item can only be used in conjunction with <A HREF="#dvr_common_html_Types__DVR_SET_OSD_EX">DVR_SET_OSD_EX</A> message. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_osd_dts_enum"></a>
<PRE class="cdef">
enum <A HREF="#dvr_common_html_Types__dvr_osd_dts_enum">dvr_osd_dts_enum</A> {
    <A name="dvr_common_html_Types__DVR_OSD_DTS_NONE">DVR_OSD_DTS_NONE</A>,
    <A name="dvr_common_html_Types__DVR_OSD_DTS_DEBUG">DVR_OSD_DTS_DEBUG</A>,
    <A name="dvr_common_html_Types__DVR_OSD_DTS_MDY_12H">DVR_OSD_DTS_MDY_12H</A>,
    <A name="dvr_common_html_Types__DVR_OSD_DTS_DMY_12H">DVR_OSD_DTS_DMY_12H</A>,
    <A name="dvr_common_html_Types__DVR_OSD_DTS_YMD_12H">DVR_OSD_DTS_YMD_12H</A>,
    <A name="dvr_common_html_Types__DVR_OSD_DTS_MDY_24H">DVR_OSD_DTS_MDY_24H</A>,
    <A name="dvr_common_html_Types__DVR_OSD_DTS_DMY_24H">DVR_OSD_DTS_DMY_24H</A>,
    <A name="dvr_common_html_Types__DVR_OSD_DTS_YMD_24H">DVR_OSD_DTS_YMD_24H</A>,
    <A name="dvr_common_html_Types__DVR_OSD_DTS_DEBUG_2">DVR_OSD_DTS_DEBUG_2</A>
} ; 
</PRE>
<DIV CLASS="descr">
<P>
Format of the date on OSD. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_OSD_DTS_NONE">DVR_OSD_DTS_NONE</A>     disables DTS. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_OSD_DTS_DEBUG">DVR_OSD_DTS_DEBUG</A>    enables a special debug display mode. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_OSD_DTS_MDY_12H">DVR_OSD_DTS_MDY_12H</A>  is <EM>MM-DD-YYYY HH:MM:SS am/pm</EM>. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_OSD_DTS_DMY_12H">DVR_OSD_DTS_DMY_12H</A>  is <EM>DD-MM-YYYY HH:MM:SS am/pm</EM>. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_OSD_DTS_YMD_12H">DVR_OSD_DTS_YMD_12H</A>  is <EM>YYYY-MM-DD HH:MM:SS am/pm</EM>. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_OSD_DTS_MDY_24H">DVR_OSD_DTS_MDY_24H</A>  is <EM>MM-DD-YYYY HH:MM:SS</EM>. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_OSD_DTS_DMY_24H">DVR_OSD_DTS_DMY_24H</A>  is <EM>DD-MM-YYYY HH:MM:SS</EM>. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_OSD_DTS_YMD_24H">DVR_OSD_DTS_YMD_24H</A>  is <EM>YYYY-MM-DD HH:MM:SS</EM>. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_data_type_enum"></a>
<PRE class="cdef">
enum <A HREF="#dvr_common_html_Types__dvr_data_type_enum">dvr_data_type_enum</A> {
    <A name="dvr_common_html_Types__DVR_DATA_RAW_VIDEO_Y">DVR_DATA_RAW_VIDEO_Y</A>,
    <A name="dvr_common_html_Types__DVR_DATA_RAW_VIDEO_U">DVR_DATA_RAW_VIDEO_U</A>,
    <A name="dvr_common_html_Types__DVR_DATA_RAW_VIDEO_V">DVR_DATA_RAW_VIDEO_V</A>,
    <A name="dvr_common_html_Types__DVR_DATA_RAW_AUDIO">DVR_DATA_RAW_AUDIO</A>,
    <A name="dvr_common_html_Types__DVR_DATA_H264_IDR">DVR_DATA_H264_IDR</A>,
    <A name="dvr_common_html_Types__DVR_DATA_H264_I">DVR_DATA_H264_I</A>,
    <A name="dvr_common_html_Types__DVR_DATA_H264_P">DVR_DATA_H264_P</A>,
    <A name="dvr_common_html_Types__DVR_DATA_H264_B">DVR_DATA_H264_B</A>,
    <A name="dvr_common_html_Types__DVR_DATA_H264_SPS">DVR_DATA_H264_SPS</A>,
    <A name="dvr_common_html_Types__DVR_DATA_H264_PPS">DVR_DATA_H264_PPS</A>,
    <A name="dvr_common_html_Types__DVR_DATA_JPEG">DVR_DATA_JPEG</A>,
    <A name="dvr_common_html_Types__DVR_DATA_G711">DVR_DATA_G711</A>,
    <A name="dvr_common_html_Types__DVR_DATA_MPEG4_I">DVR_DATA_MPEG4_I</A>,
    <A name="dvr_common_html_Types__DVR_DATA_MPEG4_P">DVR_DATA_MPEG4_P</A>,
    <A name="dvr_common_html_Types__DVR_DATA_MPEG4_B">DVR_DATA_MPEG4_B</A>,
    <A name="dvr_common_html_Types__DVR_DATA_MPEG4_VOL">DVR_DATA_MPEG4_VOL</A>,
    <A name="dvr_common_html_Types__DVR_DATA_G726_16K">DVR_DATA_G726_16K</A>,
    <A name="dvr_common_html_Types__DVR_DATA_G726_32K">DVR_DATA_G726_32K</A>,
    <A name="dvr_common_html_Types__DVR_DATA_MOTION_VALUES">DVR_DATA_MOTION_VALUES</A>,
    <A name="dvr_common_html_Types__DVR_DATA_RAW_VIDEO">DVR_DATA_RAW_VIDEO</A>,
    <A name="dvr_common_html_Types__DVR_DATA_UNKNOWN">DVR_DATA_UNKNOWN</A>
} ; 
</PRE>
<DIV CLASS="descr">
<P>
Type of data transfered between firmware and SDK. 
</P>
<P>
<STRONG>DVR_DATA_RAW_VIDEO_xxx</STRONG>   Y,U, and V component of a raw video frame. 
For interlaced video, a frame must contain the top field followed by 
the bottom field. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_DATA_RAW_AUDIO">DVR_DATA_RAW_AUDIO</A>       Raw audio PCM data. 
</P>
<P>
<STRONG>DVR_DATA_H264_xxx</STRONG>        NAL unit of H.264 bitstream. 
</P>
<P>
<STRONG>DVR_DATA_MPEG4_x</STRONG>         NAL unit of MPEG4 encoded bitstream. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_DATA_JPEG">DVR_DATA_JPEG</A>            JPEG-compressed image. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_DATA_G711">DVR_DATA_G711</A>            G.711-compressed audio data. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_DATA_G726_16K">DVR_DATA_G726_16K</A>        G.726-compressed audio data at 16 Kbits/sec. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_DATA_G726_32K">DVR_DATA_G726_32K</A>        G.726-compressed audio data at 32 Kbits/sec. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_DATA_MOTION_VALUES">DVR_DATA_MOTION_VALUES</A>   Macro block motion values per raw video frames. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_signal_type_enum"></a>
<PRE class="cdef">
enum <A HREF="#dvr_common_html_Types__dvr_signal_type_enum">dvr_signal_type_enum</A> {
    <A name="dvr_common_html_Types__DVR_SIGNAL_SENSOR_ACTIVATED">DVR_SIGNAL_SENSOR_ACTIVATED</A>,
    <A name="dvr_common_html_Types__DVR_SIGNAL_MOTION_DETECTED">DVR_SIGNAL_MOTION_DETECTED</A>,
    <A name="dvr_common_html_Types__DVR_SIGNAL_BLIND_DETECTED">DVR_SIGNAL_BLIND_DETECTED</A>,
    <A name="dvr_common_html_Types__DVR_SIGNAL_NIGHT_DETECTED">DVR_SIGNAL_NIGHT_DETECTED</A>,
    <A name="dvr_common_html_Types__DVR_SIGNAL_VIDEO_LOST">DVR_SIGNAL_VIDEO_LOST</A>,
    <A name="dvr_common_html_Types__DVR_SIGNAL_VIDEO_DETECTED">DVR_SIGNAL_VIDEO_DETECTED</A>,
    <A name="dvr_common_html_Types__DVR_SIGNAL_RUNTIME_ERROR">DVR_SIGNAL_RUNTIME_ERROR</A>,
    <A name="dvr_common_html_Types__DVR_SIGNAL_FATAL_ERROR">DVR_SIGNAL_FATAL_ERROR</A>,
    <A name="dvr_common_html_Types__DVR_SIGNAL_HEARTBEAT">DVR_SIGNAL_HEARTBEAT</A>,
    <A name="dvr_common_html_Types__DVR_SIGNAL_WATCHDOG_EXPIRED">DVR_SIGNAL_WATCHDOG_EXPIRED</A>
} ; 
</PRE>
<DIV CLASS="descr">
<P>
Defines signal types from board to host. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_SIGNAL_SENSOR_ACTIVATED">DVR_SIGNAL_SENSOR_ACTIVATED</A>  - sent when a sensor is activated or 
deactivated. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_SIGNAL_MOTION_DETECTED">DVR_SIGNAL_MOTION_DETECTED</A>   - sent when motion is detected. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_SIGNAL_BLIND_DETECTED">DVR_SIGNAL_BLIND_DETECTED</A>    - sent when the camera is blind. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_SIGNAL_NIGHT_DETECTED">DVR_SIGNAL_NIGHT_DETECTED</A>    - sent when the image is too dark. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_SIGNAL_VIDEO_LOST">DVR_SIGNAL_VIDEO_LOST</A>        - sent when the video signal from a 
camera is lost. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_SIGNAL_VIDEO_DETECTED">DVR_SIGNAL_VIDEO_DETECTED</A>    - sent when a video signal is detected 
on an input channel, where there was no signal before. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_SIGNAL_RUNTIME_ERROR">DVR_SIGNAL_RUNTIME_ERROR</A>     - indicates that a non-fatal runtime 
error has occurred on the board. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_SIGNAL_FATAL_ERROR">DVR_SIGNAL_FATAL_ERROR</A>       - indicates that a fatal error has 
occurred on the board. If this signal is received, the board must 
be reset. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_SIGNAL_HEARTBEAT">DVR_SIGNAL_HEARTBEAT</A>         - if the heartbeat function is enabled 
by the host, then this message will be sent once a second by the board 
as long as the firmware is operational. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_SIGNAL_WATCHDOG_EXPIRED">DVR_SIGNAL_WATCHDOG_EXPIRED</A>  - indicates that the watchdog timer has 
expired and the board is about to be reset. If the PC reset function 
is enabled then the host PC will also be reset. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_rawv_format_enum"></a>
<PRE class="cdef">
enum <A HREF="#dvr_common_html_Types__dvr_rawv_format_enum">dvr_rawv_format_enum</A> {
    <A name="dvr_common_html_Types__DVR_RAWV_FORMAT_YUV_4_2_0">DVR_RAWV_FORMAT_YUV_4_2_0</A> = 1,
    <A name="dvr_common_html_Types__DVR_RAWV_FORMAT_YUV_4_2_2">DVR_RAWV_FORMAT_YUV_4_2_2</A> = 2,
    <A name="dvr_common_html_Types__DVR_RAWV_FORMAT_YVU_4_2_0">DVR_RAWV_FORMAT_YVU_4_2_0</A> = 4
} ; 
</PRE>
<DIV CLASS="descr">
<P>
The following enum describe various raw video formats. 
Each enum value must correspond to a unique bit to be used in  
a bitmap field. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_RAWV_FORMAT_YUV_4_2_0">DVR_RAWV_FORMAT_YUV_4_2_0</A> - 4:2:0 YUV format. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_RAWV_FORMAT_YUV_4_2_2">DVR_RAWV_FORMAT_YUV_4_2_2</A> - 4:2:2 YUV format. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_RAWV_FORMAT_YVU_4_2_0">DVR_RAWV_FORMAT_YVU_4_2_0</A> - 4:2:0 YVU (YV12) format. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_message_enum"></a>
<PRE class="cdef">
enum <A HREF="#dvr_common_html_Types__dvr_message_enum">dvr_message_enum</A> {
    <A name="dvr_common_html_Types__DVR_GET_VER_INFO">DVR_GET_VER_INFO</A>,
    <A name="dvr_common_html_Types__DVR_REP_VER_INFO">DVR_REP_VER_INFO</A>,
    <A name="dvr_common_html_Types__DVR_GET_CODEC_INFO">DVR_GET_CODEC_INFO</A>,
    <A name="dvr_common_html_Types__DVR_REP_CODEC_INFO">DVR_REP_CODEC_INFO</A>,
    <A name="dvr_common_html_Types__DVR_GET_BOARD">DVR_GET_BOARD</A>,
    <A name="dvr_common_html_Types__DVR_SET_BOARD">DVR_SET_BOARD</A>,
    <A name="dvr_common_html_Types__DVR_REP_BOARD">DVR_REP_BOARD</A>,
    <A name="dvr_common_html_Types__DVR_GET_JOB">DVR_GET_JOB</A>,
    <A name="dvr_common_html_Types__DVR_SET_JOB">DVR_SET_JOB</A>,
    <A name="dvr_common_html_Types__DVR_REP_JOB">DVR_REP_JOB</A>,
    <A name="dvr_common_html_Types__DVR_GET_SMO">DVR_GET_SMO</A>,
    <A name="dvr_common_html_Types__DVR_SET_SMO">DVR_SET_SMO</A>,
    <A name="dvr_common_html_Types__DVR_REP_SMO">DVR_REP_SMO</A>,
    <A name="dvr_common_html_Types__DVR_GET_HMO">DVR_GET_HMO</A>,
    <A name="dvr_common_html_Types__DVR_SET_HMO">DVR_SET_HMO</A>,
    <A name="dvr_common_html_Types__DVR_REP_HMO">DVR_REP_HMO</A>,
    <A name="dvr_common_html_Types__DVR_GET_OSD">DVR_GET_OSD</A>,
    <A name="dvr_common_html_Types__DVR_SET_OSD">DVR_SET_OSD</A>,
    <A name="dvr_common_html_Types__DVR_REP_OSD">DVR_REP_OSD</A>,
    <A name="dvr_common_html_Types__DVR_GET_PR">DVR_GET_PR</A>,
    <A name="dvr_common_html_Types__DVR_SET_PR">DVR_SET_PR</A>,
    <A name="dvr_common_html_Types__DVR_REP_PR">DVR_REP_PR</A>,
    <A name="dvr_common_html_Types__DVR_GET_MD">DVR_GET_MD</A>,
    <A name="dvr_common_html_Types__DVR_SET_MD">DVR_SET_MD</A>,
    <A name="dvr_common_html_Types__DVR_REP_MD">DVR_REP_MD</A>,
    <A name="dvr_common_html_Types__DVR_GET_BD">DVR_GET_BD</A>,
    <A name="dvr_common_html_Types__DVR_SET_BD">DVR_SET_BD</A>,
    <A name="dvr_common_html_Types__DVR_REP_BD">DVR_REP_BD</A>,
    <A name="dvr_common_html_Types__DVR_GET_ND">DVR_GET_ND</A>,
    <A name="dvr_common_html_Types__DVR_SET_ND">DVR_SET_ND</A>,
    <A name="dvr_common_html_Types__DVR_REP_ND">DVR_REP_ND</A>,
    <A name="dvr_common_html_Types__DVR_GET_RELAYS">DVR_GET_RELAYS</A>,
    <A name="dvr_common_html_Types__DVR_SET_RELAYS">DVR_SET_RELAYS</A>,
    <A name="dvr_common_html_Types__DVR_REP_RELAYS">DVR_REP_RELAYS</A>,
    <A name="dvr_common_html_Types__DVR_GET_SENSORS">DVR_GET_SENSORS</A>,
    <A name="dvr_common_html_Types__DVR_SET_SENSORS">DVR_SET_SENSORS</A>,
    <A name="dvr_common_html_Types__DVR_REP_SENSORS">DVR_REP_SENSORS</A>,
    <A name="dvr_common_html_Types__DVR_GET_WATCHDOG">DVR_GET_WATCHDOG</A>,
    <A name="dvr_common_html_Types__DVR_SET_WATCHDOG">DVR_SET_WATCHDOG</A>,
    <A name="dvr_common_html_Types__DVR_REP_WATCHDOG">DVR_REP_WATCHDOG</A>,
    <A name="dvr_common_html_Types__DVR_GET_CONTROL">DVR_GET_CONTROL</A>,
    <A name="dvr_common_html_Types__DVR_SET_CONTROL">DVR_SET_CONTROL</A>,
    <A name="dvr_common_html_Types__DVR_REP_CONTROL">DVR_REP_CONTROL</A>,
    <A name="dvr_common_html_Types__DVR_GET_TIME">DVR_GET_TIME</A>,
    <A name="dvr_common_html_Types__DVR_SET_TIME">DVR_SET_TIME</A>,
    <A name="dvr_common_html_Types__DVR_REP_TIME">DVR_REP_TIME</A>,
    <A name="dvr_common_html_Types__DVR_GET_ENCODE">DVR_GET_ENCODE</A>,
    <A name="dvr_common_html_Types__DVR_SET_ENCODE">DVR_SET_ENCODE</A>,
    <A name="dvr_common_html_Types__DVR_REP_ENCODE">DVR_REP_ENCODE</A>,
    <A name="dvr_common_html_Types__DVR_GET_ENC_ALARM">DVR_GET_ENC_ALARM</A>,
    <A name="dvr_common_html_Types__DVR_SET_ENC_ALARM">DVR_SET_ENC_ALARM</A>,
    <A name="dvr_common_html_Types__DVR_REP_ENC_ALARM">DVR_REP_ENC_ALARM</A>,
    <A name="dvr_common_html_Types__DVR_GET_DECODE">DVR_GET_DECODE</A>,
    <A name="dvr_common_html_Types__DVR_SET_DECODE">DVR_SET_DECODE</A>,
    <A name="dvr_common_html_Types__DVR_REP_DECODE">DVR_REP_DECODE</A>,
    <A name="dvr_common_html_Types__DVR_SET_FONT_TABLE">DVR_SET_FONT_TABLE</A>,
    <A name="dvr_common_html_Types__DVR_REP_FONT_TABLE">DVR_REP_FONT_TABLE</A>,
    <A name="dvr_common_html_Types__DVR_GET_OSD_EX">DVR_GET_OSD_EX</A>,
    <A name="dvr_common_html_Types__DVR_SET_OSD_EX">DVR_SET_OSD_EX</A>,
    <A name="dvr_common_html_Types__DVR_REP_OSD_EX">DVR_REP_OSD_EX</A>,
    <A name="dvr_common_html_Types__DVR_GET_UART">DVR_GET_UART</A>,
    <A name="dvr_common_html_Types__DVR_SET_UART">DVR_SET_UART</A>,
    <A name="dvr_common_html_Types__DVR_REP_UART">DVR_REP_UART</A>,
    <A name="dvr_common_html_Types__DVR_GET_IOCTL">DVR_GET_IOCTL</A>,
    <A name="dvr_common_html_Types__DVR_SET_IOCTL">DVR_SET_IOCTL</A>,
    <A name="dvr_common_html_Types__DVR_REP_IOCTL">DVR_REP_IOCTL</A>,
    <A name="dvr_common_html_Types__DVR_GET_AUTH_KEY">DVR_GET_AUTH_KEY</A>,
    <A name="dvr_common_html_Types__DVR_SET_AUTH_KEY">DVR_SET_AUTH_KEY</A>,
    <A name="dvr_common_html_Types__DVR_REP_AUTH_KEY">DVR_REP_AUTH_KEY</A>,
    <A name="dvr_common_html_Types__DVR_SET_REGIONS_MAP">DVR_SET_REGIONS_MAP</A>,
    <A name="dvr_common_html_Types__DVR_REP_REGIONS_MAP">DVR_REP_REGIONS_MAP</A>,
    <A name="dvr_common_html_Types__DVR_SET_VIDEO_OUTPUT">DVR_SET_VIDEO_OUTPUT</A>,
    <A name="dvr_common_html_Types__DVR_REP_VIDEO_OUTPUT">DVR_REP_VIDEO_OUTPUT</A>,
    <A name="dvr_common_html_Types__DVR_GET_SMO_ATTRIB">DVR_GET_SMO_ATTRIB</A>,
    <A name="dvr_common_html_Types__DVR_REP_SMO_ATTRIB">DVR_REP_SMO_ATTRIB</A>,
    <A name="dvr_common_html_Types__DVR_SIG_HOST">DVR_SIG_HOST</A>,
    <A name="dvr_common_html_Types__DVR_FW_INTERNAL">DVR_FW_INTERNAL</A>
} ; 
</PRE>
<DIV CLASS="descr">
<P>
Message class shared between the DVR firmware and DVR SDK. 
</P>
<P>
The communication between firmware and DVR is done in a transaction 
style with agreed upon conventions.  Both firmware and SDK can 
originate a message transaction.  The receiver of the message must 
reply with requested data.  The first byte of the data 
contains the return status.  If the return status is not <A HREF="#dvr_common_html_Types__DVR_STATUS_OK">DVR_STATUS_OK</A>, 
it is used as an error code.  This error code is used to 
look up a string message for the user. 
</P>
<P>
The messages fall into two categories: 
</P>
<UL>
<LI>
Information messages for the host to find out specific attributes 
of the board.  These messages have the form DVR_GET_xxx and 
DVR_REP_xxx where the GET message is the request from the 
host, and the REP message is the reply from the board. 
</LI>
<LI>
Parameter-setting messages for the host to control the board 
functions.  These messages have the form DVR_SET_xxx and DVR_REP_xxx 
where the SET message is originated from the host, and REP is the 
reply from the board. 
</LI>
</UL>
<P>
The following set of messages are used to exchange information 
about the board.  A message from the SDK to the firmware represents a 
request, and a message from the firmware to the SDK is the response. 
</P>
<UL>
<LI>
<A HREF="#dvr_common_html_Types__DVR_GET_VER_INFO">DVR_GET_VER_INFO</A>, <A HREF="#dvr_common_html_Types__DVR_REP_VER_INFO">DVR_REP_VER_INFO</A> - Firmware version. 
The data associated with this message must 
be of type <A HREF="#dvr_common_html_Types__dvr_ver_info_t">dvr_ver_info_t</A>. 
</LI>
<LI>
<A HREF="#dvr_common_html_Types__DVR_GET_CODEC_INFO">DVR_GET_CODEC_INFO</A>, <A HREF="#dvr_common_html_Types__DVR_REP_CODEC_INFO">DVR_REP_CODEC_INFO</A> -  
These messages are used to get specific encoding and decoding 
capabilities of the board for a given resolution.  Multiple 
messages can be used to exchange the CODEC capability of a board 
for multiple resolutions.  As a general rule, the CPU time scales 
linearly with the number of encoding or decoding channels 
for a given resolution, but may not scale linearly with the number 
of pixles.  The data assoicated with this message must be of 
type <A HREF="#dvr_common_html_Types__dvr_codec_info_t">dvr_codec_info_t</A>. 
</LI>
</UL>
<P>
The following set of messages is used to configure the board 
for various jobs.   
</P>
<UL>
<LI>
<A HREF="#dvr_common_html_Types__DVR_GET_BOARD">DVR_GET_BOARD</A>, <A HREF="#dvr_common_html_Types__DVR_SET_BOARD">DVR_SET_BOARD</A>, <A HREF="#dvr_common_html_Types__DVR_REP_BOARD">DVR_REP_BOARD</A> - Get 
information about the board and configure the board. 
The data for this message is of type <A HREF="#dvr_common_html_Types__dvr_board_t">dvr_board_t</A>. 
</LI>
<LI>
<A HREF="#dvr_common_html_Types__DVR_GET_JOB">DVR_GET_JOB</A>, <A HREF="#dvr_common_html_Types__DVR_SET_JOB">DVR_SET_JOB</A>, <A HREF="#dvr_common_html_Types__DVR_REP_JOB">DVR_REP_JOB</A> - Configure a 
job on the board using the information in the message data of 
type <A HREF="#dvr_common_html_Types__dvr_job_t">dvr_job_t</A>.  The firmware cannot migrate a job from one 
chip to another once it is created.  So, it is important that 
real-time encoding jobs be created before other jobs. 
</LI>
<LI>
<A HREF="#dvr_common_html_Types__DVR_GET_SMO">DVR_GET_SMO</A>, <A HREF="#dvr_common_html_Types__DVR_SET_SMO">DVR_SET_SMO</A>, <A HREF="#dvr_common_html_Types__DVR_REP_SMO">DVR_REP_SMO</A> - Configure the PCIe 
card spot monitor for a particular encoding or decoding channel. 
The configuration data is of type <A HREF="#dvr_common_html_Types__dvr_smo_t">dvr_smo_t</A>. 
</LI>
<LI>
<A HREF="#dvr_common_html_Types__DVR_GET_HMO">DVR_GET_HMO</A>, <A HREF="#dvr_common_html_Types__DVR_SET_HMO">DVR_SET_HMO</A>, <A HREF="#dvr_common_html_Types__DVR_REP_HMO">DVR_REP_HMO</A> - Configure a 
particular video channel (incoming or decoded) for display on 
the host PC.  This raw video image will be transmitted to the 
host side.  The configuration data is of type <A HREF="#dvr_common_html_Types__dvr_hmo_t">dvr_hmo_t</A>. 
</LI>
<LI>
<A HREF="#dvr_common_html_Types__DVR_GET_OSD">DVR_GET_OSD</A>, <A HREF="#dvr_common_html_Types__DVR_SET_OSD">DVR_SET_OSD</A>, <A HREF="#dvr_common_html_Types__DVR_REP_OSD">DVR_REP_OSD</A> - Defines the on screen 
display.  The configuration data is of type <A HREF="#dvr_common_html_Types__dvr_osd_t">dvr_osd_t</A>. These messages 
will be obseleted after releae 3.4 and replaced with the  
<A HREF="#dvr_common_html_Types__DVR_GET_OSD_EX">DVR_GET_OSD_EX</A>, <A HREF="#dvr_common_html_Types__DVR_SET_OSD_EX">DVR_SET_OSD_EX</A>, <A HREF="#dvr_common_html_Types__DVR_REP_OSD_EX">DVR_REP_OSD_EX</A> messages. 
</LI>
<LI>
<A HREF="#dvr_common_html_Types__DVR_GET_PR">DVR_GET_PR</A>, <A HREF="#dvr_common_html_Types__DVR_SET_PR">DVR_SET_PR</A>, <A HREF="#dvr_common_html_Types__DVR_REP_PR">DVR_REP_PR</A> - Defines private regions 
to be blocked.  The configuration data is of type <A HREF="#dvr_common_html_Types__dvr_pr_t">dvr_pr_t</A>. 
</LI>
<LI>
<A HREF="#dvr_common_html_Types__DVR_GET_MD">DVR_GET_MD</A>, <A HREF="#dvr_common_html_Types__DVR_SET_MD">DVR_SET_MD</A>, <A HREF="#dvr_common_html_Types__DVR_REP_MD">DVR_REP_MD</A> - Configure the motion 
detection algorithm for a particular encoding or decoding channel. 
The configuration data is of type <A HREF="#dvr_common_html_Types__dvr_md_t">dvr_md_t</A>. 
</LI>
<LI>
<A HREF="#dvr_common_html_Types__DVR_GET_BD">DVR_GET_BD</A>, <A HREF="#dvr_common_html_Types__DVR_SET_BD">DVR_SET_BD</A>, <A HREF="#dvr_common_html_Types__DVR_REP_BD">DVR_REP_BD</A> - Configure the blind 
detection algorithm for a particular encoding or decoding channel. 
The configuration data is of type <A HREF="#dvr_common_html_Types__dvr_bd_t">dvr_bd_t</A>. 
</LI>
<LI>
<A HREF="#dvr_common_html_Types__DVR_GET_ND">DVR_GET_ND</A>, <A HREF="#dvr_common_html_Types__DVR_SET_ND">DVR_SET_ND</A>, <A HREF="#dvr_common_html_Types__DVR_REP_ND">DVR_REP_ND</A> - Configure the night 
detection algorithm for a particular encoding or decoding channel. 
The configuration data is of type <A HREF="#dvr_common_html_Types__dvr_nd_t">dvr_nd_t</A>. 
</LI>
<LI>
<A HREF="#dvr_common_html_Types__DVR_GET_ENCODE">DVR_GET_ENCODE</A>, <A HREF="#dvr_common_html_Types__DVR_SET_ENCODE">DVR_SET_ENCODE</A>, 
<A HREF="#dvr_common_html_Types__DVR_REP_ENCODE">DVR_REP_ENCODE</A> - Configure the encoder for a particular encoding 
channel.  The configuration data is of type <A HREF="#dvr_common_html_Types__dvr_encode_info_t">dvr_encode_info_t</A>. 
</LI>
<LI>
<A HREF="#dvr_common_html_Types__DVR_GET_ENC_ALARM">DVR_GET_ENC_ALARM</A>, <A HREF="#dvr_common_html_Types__DVR_SET_ENC_ALARM">DVR_SET_ENC_ALARM</A>, 
<A HREF="#dvr_common_html_Types__DVR_REP_ENC_ALARM">DVR_REP_ENC_ALARM</A> - Configure the encoder alarm settings for a 
particular encoding channel.  The configuration data is of type 
<A HREF="#dvr_common_html_Types__dvr_enc_alarm_info_t">dvr_enc_alarm_info_t</A>. 
</LI>
<LI>
<A HREF="#dvr_common_html_Types__DVR_GET_DECODE">DVR_GET_DECODE</A>, <A HREF="#dvr_common_html_Types__DVR_SET_DECODE">DVR_SET_DECODE</A>, 
<A HREF="#dvr_common_html_Types__DVR_REP_DECODE">DVR_REP_DECODE</A> - Configure the decoder for a particular decode 
channel.  The configuration data is of type <A HREF="#dvr_common_html_Types__dvr_decode_info_t">dvr_decode_info_t</A>. 
</LI>
<LI>
<A HREF="#dvr_common_html_Types__DVR_SET_FONT_TABLE">DVR_SET_FONT_TABLE</A>, <A HREF="#dvr_common_html_Types__DVR_REP_FONT_TABLE">DVR_REP_FONT_TABLE</A> - These messages are 
used to sent a new font table from host DVR to the DVR frimare 
or select an existing pre-defined font_table. There can only be 
one user defined font table at a time and wants it is sent any 
previously user defined font table will be erased and the new one 
is selected. 
NOTE: The font table messages are not in 3.2 release. 
</LI>
<LI>
<A HREF="#dvr_common_html_Types__DVR_GET_OSD_EX">DVR_GET_OSD_EX</A>, <A HREF="#dvr_common_html_Types__DVR_SET_OSD_EX">DVR_SET_OSD_EX</A>, <A HREF="#dvr_common_html_Types__DVR_REP_OSD_EX">DVR_REP_OSD_EX</A> - These 
messages are used to set/get OSD text, positions, and show 
state for each OSD definitions. Currently only 2 different 
OSD can be defined per channel. DVR_xxx_OSD_EX and DVR_xxx_OSD 
message can not be called at the same time for the same channel. 
Doing so, invalidate the previous call. 
</LI>
<LI>
<A HREF="#dvr_common_html_Types__DVR_GET_RELAYS">DVR_GET_RELAYS</A>, <A HREF="#dvr_common_html_Types__DVR_SET_RELAYS">DVR_SET_RELAYS</A>, <A HREF="#dvr_common_html_Types__DVR_REP_RELAYS">DVR_REP_RELAYS</A> - Configure 
relay outputs.  The configuration data is of type <A HREF="#dvr_common_html_Types__dvr_relay_t">dvr_relay_t</A>. 
</LI>
<LI>
<A HREF="#dvr_common_html_Types__DVR_GET_SENSORS">DVR_GET_SENSORS</A>, <A HREF="#dvr_common_html_Types__DVR_SET_SENSORS">DVR_SET_SENSORS</A>, <A HREF="#dvr_common_html_Types__DVR_REP_SENSORS">DVR_REP_SENSORS</A> - Configure 
sensor inputs.  The configuration data is of type <A HREF="#dvr_common_html_Types__dvr_sensor_t">dvr_sensor_t</A>. 
</LI>
<LI>
<A HREF="#dvr_common_html_Types__DVR_GET_WATCHDOG">DVR_GET_WATCHDOG</A>, <A HREF="#dvr_common_html_Types__DVR_SET_WATCHDOG">DVR_SET_WATCHDOG</A>, <A HREF="#dvr_common_html_Types__DVR_REP_WATCHDOG">DVR_REP_WATCHDOG</A> - 
Configure the watchdog timer.  The configuration data is of type 
<A HREF="#dvr_common_html_Types__dvr_watchdog_t">dvr_watchdog_t</A>.  The host is responsible for sending this 
message before the previous watchdog timer expires. 
</LI>
<LI>
<A HREF="#dvr_common_html_Types__DVR_GET_CONTROL">DVR_GET_CONTROL</A>, <A HREF="#dvr_common_html_Types__DVR_SET_CONTROL">DVR_SET_CONTROL</A>, <A HREF="#dvr_common_html_Types__DVR_REP_CONTROL">DVR_REP_CONTROL</A> - These messages 
are used to enable, disable, or get the status of a job. 
The configuration data is of type <A HREF="#dvr_common_html_Types__dvr_control_t">dvr_control_t</A>. 
</LI>
<LI>
<A HREF="#dvr_common_html_Types__DVR_GET_TIME">DVR_GET_TIME</A>, <A HREF="#dvr_common_html_Types__DVR_SET_TIME">DVR_SET_TIME</A>, <A HREF="#dvr_common_html_Types__DVR_REP_TIME">DVR_REP_TIME</A> - These messages 
are used to get the time of day on the board and to set the time of 
the day on the board based on PC host time. 
The configuration data is of type <A HREF="#dvr_common_html_Types__dvr_time_t">dvr_time_t</A>. 
</LI>
<LI>
<A HREF="#dvr_common_html_Types__DVR_GET_UART">DVR_GET_UART</A>, <A HREF="#dvr_common_html_Types__DVR_SET_UART">DVR_SET_UART</A> and <A HREF="#dvr_common_html_Types__DVR_REP_UART">DVR_REP_UART</A> - These messages 
are used to configure the RS-485 port and to send data out through 
the port. 
</LI>
<LI>
<A HREF="#dvr_common_html_Types__DVR_GET_IOCTL">DVR_GET_IOCTL</A>, <A HREF="#dvr_common_html_Types__DVR_SET_IOCTL">DVR_SET_IOCTL</A>, and <A HREF="#dvr_common_html_Types__DVR_REP_IOCTL">DVR_REP_IOCTL</A> - These are 
used to get and set device-specific parameters for various onboard 
devices. 
</LI>
<LI>
<A HREF="#dvr_common_html_Types__DVR_GET_AUTH_KEY">DVR_GET_AUTH_KEY</A>, <A HREF="#dvr_common_html_Types__DVR_REP_AUTH_KEY">DVR_REP_AUTH_KEY</A> - These are used to get the 
security authentication key from the board. The data structure associated 
with these messages is <A HREF="#dvr_common_html_Types__dvr_auth_key_t">dvr_auth_key_t</A>; 
</LI>
<LI>
<A HREF="#dvr_common_html_Types__DVR_SET_AUTH_KEY">DVR_SET_AUTH_KEY</A> - Setting the authentication key is not  
supported at this time. 
</LI>
<LI>
<A HREF="#dvr_common_html_Types__DVR_SET_REGIONS_MAP">DVR_SET_REGIONS_MAP</A>, <A HREF="#dvr_common_html_Types__DVR_REP_REGIONS_MAP">DVR_REP_REGIONS_MAP</A> - 
Configure the regions map for motion/blind/night detection as well 
as privacy blocking, for an encoding or decoding channel. 
The configuration data is of type <A HREF="#dvr_common_html_Types__dvr_regions_map_t">dvr_regions_map_t</A>. 
</LI>
<LI>
<A HREF="#dvr_common_html_Types__DVR_SET_VIDEO_OUTPUT">DVR_SET_VIDEO_OUTPUT</A>, <A HREF="#dvr_common_html_Types__DVR_REP_VIDEO_OUTPUT">DVR_REP_VIDEO_OUTPUT</A> - 
These are used to configure the firmware to start accepting raw 
video frame to display on specified SMO port. 
</LI>
<LI>
<A HREF="#dvr_common_html_Types__DVR_GET_SMO_ATTRIB">DVR_GET_SMO_ATTRIB</A>, <A HREF="#dvr_common_html_Types__DVR_REP_SMO_ATTRIB">DVR_REP_SMO_ATTRIB</A> - 
Get the current attributes setting of the requested Spot Monitor 
display. 
</LI>
</UL>
<P>
The following message is for the board to signal the host about an event. 
</P>
<UL>
<LI>
<A HREF="#dvr_common_html_Types__DVR_SIG_HOST">DVR_SIG_HOST</A> signals the host that an event just happened and 
needs the host's attention.  The data associated with this 
message must be of type <A HREF="#dvr_common_html_Types__dvr_sig_host_t">dvr_sig_host_t</A>. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_ver_info_t"></a>
<PRE class="cdef">
typedef struct dvr_ver_info_struct {
    <A HREF="#dvr_common_html_Types__dvr_status_e">dvr_status_e</A> status:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> version_major;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> version_minor;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> version_bug;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> build_year;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> build_month;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> build_day;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> board_revision;
    <A HREF="#dvr_common_html_Types__dvr_chip_rev_e">dvr_chip_rev_e</A> chip_revision:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> board_sub_rev;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> version_build;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> bootloader_ver_major;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> bootloader_ver_minor;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> bsp_ver_major;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> bsp_ver_minor;
} <A HREF="#dvr_common_html_Types__dvr_ver_info_t">dvr_ver_info_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This structure is associated with the messages 
<A HREF="#dvr_common_html_Types__DVR_GET_VER_INFO">DVR_GET_VER_INFO</A> and <A HREF="#dvr_common_html_Types__DVR_REP_VER_INFO">DVR_REP_VER_INFO</A>. 
</P>
<P>
<EM>status</EM> should always be <A HREF="#dvr_common_html_Types__DVR_STATUS_OK">DVR_STATUS_OK</A>. 
</P>
<P>
<EM>version_major</EM> is the major release version number. 
</P>
<P>
<EM>version_minor</EM> is the minor release version number. 
</P>
<P>
<EM>version_bug</EM> is the bug release version number. 
</P>
<P>
<EM>version_build</EM> is the build version number. 
</P>
<P>
The complete firmware version is <EM>&lt;major&gt;.&lt;minor&gt;.&lt;build&gt;.&lt;bug&gt;</EM>. 
</P>
<P>
<EM>board_revision</EM> is the revision  number of Stretch DVR PCIe board. 
</P>
<P>
<EM>chip_revision</EM> is the S6 chip revision used in the board_revision. 
See <A HREF="#dvr_common_html_Types__dvr_chip_rev_e">dvr_chip_rev_e</A> for all the different chip revisions. 
</P>
<P>
<EM>board_sub_rev</EM> is the sub-revision number of Stretch DVR PCIe board. 
</P>
<P>
<EM>bootloader_ver_major</EM> is the major version number of bootloader. 
</P>
<P>
<EM>bootloader_ver_minor</EM> is the minor version number of bootloader. 
</P>
<P>
<EM>bsp_ver_major</EM> is the major version number of BSP. 
</P>
<P>
<EM>bsp_ver_minor</EM> is the minor version number of BSP. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_codec_info_t"></a>
<PRE class="cdef">
typedef struct dvr_codec_info_struct {
    <A HREF="#dvr_common_html_Types__dvr_status_e">dvr_status_e</A> status:8;
    <A HREF="#dvr_common_html_Types__dvr_vc_format_e">dvr_vc_format_e</A> video_encode_format:8;
    <A HREF="#dvr_common_html_Types__dvr_ac_format_e">dvr_ac_format_e</A> audio_encode_format:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved1;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> camera_type;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> encode_fps;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> decode_fps;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> reserved2;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved3;
} <A HREF="#dvr_common_html_Types__dvr_codec_info_t">dvr_codec_info_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This structure is associated with the messages 
<A HREF="#dvr_common_html_Types__DVR_GET_CODEC_INFO">DVR_GET_CODEC_INFO</A> and <A HREF="#dvr_common_html_Types__DVR_REP_CODEC_INFO">DVR_REP_CODEC_INFO</A>. 
</P>
<P>
For a message from the SDK to the firmware, 
it is a request  for encoding and decoding capabilities of the 
board for a given resolution.  Fields <EM>encode_fps</EM> and <EM>decode_fps</EM> 
are ignored in this case.  For a message from the firmware to the SDK, 
the data specifies the resolution <EM>camera_type</EM> and total number of  
frames to encode <EM>encode_fps</EM> or to decode <EM>decode_fps</EM>. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_board_t"></a>
<PRE class="cdef">
typedef struct dvr_board_struct {
    <A HREF="#dvr_common_html_Types__dvr_status_e">dvr_status_e</A> status:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> board_id;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> num_cameras;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> num_sensors;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> num_relays;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> num_smos;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> camera_info;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> camera_type;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved1;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved2;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved3;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> num_encoders;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> num_decoders;
    union {
        <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> audio_supported;
        <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> h264_skip_SCE;
    } u1;
} <A HREF="#dvr_common_html_Types__dvr_board_t">dvr_board_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This structure is associated with the messages 
<A HREF="#dvr_common_html_Types__DVR_GET_BOARD">DVR_GET_BOARD</A>, <A HREF="#dvr_common_html_Types__DVR_SET_BOARD">DVR_SET_BOARD</A>, and <A HREF="#dvr_common_html_Types__DVR_REP_BOARD">DVR_REP_BOARD</A>.   
</P>
<UL>
<LI>
<EM>status</EM> - status of the reply. 
</LI>
<LI>
<EM>board_id</EM> - This field is specified by the DVR SDK 
to give the board a unique ID number. 
</LI>
<LI>
<EM>num_cameras</EM> - Number of cameras supported by the board. 
</LI>
<LI>
<EM>num_sensors</EM> - Number of sensors available on the board. 
</LI>
<LI>
<EM>num_relays</EM> - Number of relays available on the board. 
</LI>
<LI>
<EM>num_smos</EM> - Number of spot monitors supported by the board. 
In the current version, this number must be 0 or 1. 
</LI>
<LI>
<EM>camera_info</EM> - Specifies what cameras are supported by the board. 
It is a bit-wise or of camera types, such as <A HREF="#dvr_common_html_Defines__DVR_VSTD_D1_PAL">DVR_VSTD_D1_PAL</A> 
or <A HREF="#dvr_common_html_Defines__DVR_VSTD_D1_NTSC">DVR_VSTD_D1_NTSC</A>. 
</LI>
<LI>
<EM>camera_type</EM> - This field is specified by the DVR application. 
It must be one of the supported camera types specified in 
<EM>camera_info</EM>. All the cameras connected to a board must 
of the same type. (i.e. you cannot mix NTSC and PAL cameras 
connected to a board). 
</LI>
<LI>
<EM>num_encoders</EM> - Number of encoders supported by the board. 
</LI>
<LI>
<EM>num_decoders</EM> - Number of decoders supported by the board. 
</LI>
<LI>
<EM>audio_supported</EM> - Number of audio channels supported by the 
board. Zero indicates no audio support. 
</LI>
<LI>
<EM>h264_skip_SCE</EM> - This field is valid only for the <A HREF="#dvr_common_html_Types__DVR_SET_BOARD">DVR_SET_BOARD</A> 
command. If set to <A HREF="#sdvr_sdk_html_Defines__true">true</A>, the firmware will skip start code emulation 
for H.264 encoding. If SCE is required, it will have to be done by 
the host SDK. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_job_t"></a>
<PRE class="cdef">
typedef struct dvr_job_struct {
    <A HREF="#dvr_common_html_Types__dvr_status_e">dvr_status_e</A> status:8;
    <A HREF="#dvr_common_html_Types__dvr_job_type_e">dvr_job_type_e</A> job_type:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> job_id;
    <A HREF="#dvr_common_html_Types__dvr_job_action_e">dvr_job_action_e</A> control:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> camera_type;
    <A HREF="#dvr_common_html_Types__dvr_ac_format_e">dvr_ac_format_e</A> audio_format:8;
    <A HREF="#dvr_common_html_Types__dvr_vpp_mode_e">dvr_vpp_mode_e</A> vpp_mode:8;
    <A HREF="#dvr_common_html_Types__dvr_vc_format_e">dvr_vc_format_e</A> video_format:8;
    <A HREF="#dvr_common_html_Types__dvr_vc_format_e">dvr_vc_format_e</A> video_format_2:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> reserved2;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved3;
} <A HREF="#dvr_common_html_Types__dvr_job_t">dvr_job_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This structure is associated with the messages 
<A HREF="#dvr_common_html_Types__DVR_GET_JOB">DVR_GET_JOB</A>, <A HREF="#dvr_common_html_Types__DVR_SET_JOB">DVR_SET_JOB</A> and <A HREF="#dvr_common_html_Types__DVR_REP_JOB">DVR_REP_JOB</A>.   
</P>
<UL>
<LI>
<EM>status</EM> - Status of the reply. 
</LI>
<LI>
<EM>job_type</EM> - Must be one of <A HREF="#dvr_common_html_Types__DVR_JOB_CAMERA_ENCODE">DVR_JOB_CAMERA_ENCODE</A>, 
<A HREF="#dvr_common_html_Types__DVR_JOB_HOST_ENCODE">DVR_JOB_HOST_ENCODE</A>, or <A HREF="#dvr_common_html_Types__DVR_JOB_HOST_DECODE">DVR_JOB_HOST_DECODE</A>. 
</LI>
<LI>
<EM>job_id</EM> - A unique job ID.  The default is the camera number 
for the encoder job, and a sequentially assigned number for all 
other jobs. 
</LI>
<LI>
<EM>control</EM> - Specifies what to do with the job, for example, 
<A HREF="#dvr_common_html_Types__DVR_JOB_CREATE">DVR_JOB_CREATE</A>. 
</LI>
<LI>
<EM>camera_type</EM> - For job type <A HREF="#dvr_common_html_Types__DVR_JOB_CAMERA_ENCODE">DVR_JOB_CAMERA_ENCODE</A>, this  
specifies how to configure the input camera, and must be 
consistent with the information returned by <A HREF="#dvr_common_html_Types__DVR_GET_BOARD">DVR_GET_BOARD</A>. 
For job type <A HREF="#dvr_common_html_Types__DVR_JOB_HOST_DECODE">DVR_JOB_HOST_DECODE</A>, this specifies the video 
resolution of the stream to be decoded. 
</LI>
<LI>
<EM>audio_format</EM> - Audio CODEC format. Must be one of the valid 
<A HREF="#dvr_common_html_Types__dvr_ac_format_enum">dvr_ac_format_enum</A> values. 
</LI>
<LI>
<EM>vpp_mode</EM> - Video preprocessing mode. This is deprecated and is 
ignored by the firmware. Use <A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_VPP_CONTROL">DVR_IOCTL_CODE_VPP_CONTROL</A> to set 
video preprocessing modes. 
</LI>
<LI>
<EM>video_format</EM> - Video CODEC format for primary encoded stream. 
Must be one of the valid <A HREF="#dvr_common_html_Types__dvr_vc_format_enum">dvr_vc_format_enum</A> values. 
</LI>
<LI>
<EM>video_format_2</EM> - Video CODEC format for secondary encoded stream. 
Must be one of the valid <A HREF="#dvr_common_html_Types__dvr_vc_format_enum">dvr_vc_format_enum</A> values. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_smo_t"></a>
<PRE class="cdef">
typedef struct dvr_smo_struct {
    <A HREF="#dvr_common_html_Types__dvr_status_e">dvr_status_e</A> status:8;
    <A HREF="#dvr_common_html_Types__dvr_job_type_e">dvr_job_type_e</A> job_type:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> job_id;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> port_num;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> position_x;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> position_y;
    <A HREF="#dvr_common_html_Types__dvr_video_res_e">dvr_video_res_e</A> output_res:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> seconds;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> enable;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> check_only;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved2;
} <A HREF="#dvr_common_html_Types__dvr_smo_t">dvr_smo_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This structure is associated with the messages 
<A HREF="#dvr_common_html_Types__DVR_GET_SMO">DVR_GET_SMO</A>, <A HREF="#dvr_common_html_Types__DVR_SET_SMO">DVR_SET_SMO</A> and <A HREF="#dvr_common_html_Types__DVR_REP_SMO">DVR_REP_SMO</A>. 
</P>
<UL>
<LI>
<EM>status</EM> - Status of the reply. 
</LI>
<LI>
<EM>job_type</EM> - Must be one of <A HREF="#dvr_common_html_Types__DVR_JOB_CAMERA_ENCODE">DVR_JOB_CAMERA_ENCODE</A>, 
<A HREF="#dvr_common_html_Types__DVR_JOB_HOST_ENCODE">DVR_JOB_HOST_ENCODE</A>, or <A HREF="#dvr_common_html_Types__DVR_JOB_HOST_DECODE">DVR_JOB_HOST_DECODE</A>. 
</LI>
<LI>
<EM>job_id</EM> - A unique job ID. 
</LI>
<LI>
<EM>port_num</EM> - Zero based SMO port number. 
</LI>
<LI>
<EM>position_x</EM>,<EM>position_y</EM> - X and Y coordinates for the top left 
corner of the display image. The display image for this channel 
will be tiled into the SMO display at this position. The top left 
corner of the SMO display is (0,0). 
<STRONG>NOTE</STRONG>: X and Y coordinates must be even numbers. If not, the set 
command will fail. 
</LI>
<LI>
<EM>output_res</EM> - Must be a valid enum of type <A HREF="#dvr_common_html_Types__dvr_video_res_e">dvr_video_res_e</A>. 
The image is resized according to this enum before being sent 
to the SMO for display. The default is <A HREF="#dvr_common_html_Types__DVR_VIDEO_RES_QCIF">DVR_VIDEO_RES_QCIF</A>. 
<STRONG>NOTE</STRONG>: Currently, only <A HREF="#dvr_common_html_Types__DVR_VIDEO_RES_FULL">DVR_VIDEO_RES_FULL</A>, <A HREF="#dvr_common_html_Types__DVR_VIDEO_RES_CIF">DVR_VIDEO_RES_CIF</A>, 
and <A HREF="#dvr_common_html_Types__DVR_VIDEO_RES_QCIF">DVR_VIDEO_RES_QCIF</A> are supported. 
</LI>
<LI>
<EM>seconds</EM> - Number of seconds to display the image before skipping 
to the next channel. This is to support multiple channels sharing 
the same display tile in the SMO display. Each channel will display 
for the specified <EM>seconds</EM> in round-robin order. 
<STRONG>NOTE</STRONG>: This feature is currently not implemented, so this field 
is ignored by the firmware. 
</LI>
<LI>
<EM>enable</EM> - Enable SMO when set to 1. 
</LI>
<LI>
<EM>check_only</EM> - Only check to see if SMO creation would succeed. 
Don't actually create anything.  Used internally by the firmware. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_hmo_t"></a>
<PRE class="cdef">
typedef struct dvr_hmo_struct {
    <A HREF="#dvr_common_html_Types__dvr_status_e">dvr_status_e</A> status:8;
    <A HREF="#dvr_common_html_Types__dvr_job_type_e">dvr_job_type_e</A> job_type:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> job_id;
    <A HREF="#dvr_common_html_Types__dvr_video_res_e">dvr_video_res_e</A> output_res:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> frame_rate;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> enable;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> audio_enable;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved1;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved2;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved3;
} <A HREF="#dvr_common_html_Types__dvr_hmo_t">dvr_hmo_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This structure is associated with the messages 
<A HREF="#dvr_common_html_Types__DVR_GET_HMO">DVR_GET_HMO</A>, <A HREF="#dvr_common_html_Types__DVR_SET_HMO">DVR_SET_HMO</A>, and <A HREF="#dvr_common_html_Types__DVR_REP_HMO">DVR_REP_HMO</A>. 
</P>
<UL>
<LI>
<EM>status</EM> - Status of the reply. 
</LI>
<LI>
<EM>job_type</EM> - Must be one of <A HREF="#dvr_common_html_Types__DVR_JOB_CAMERA_ENCODE">DVR_JOB_CAMERA_ENCODE</A>, 
<A HREF="#dvr_common_html_Types__DVR_JOB_HOST_ENCODE">DVR_JOB_HOST_ENCODE</A>, or <A HREF="#dvr_common_html_Types__DVR_JOB_HOST_DECODE">DVR_JOB_HOST_DECODE</A>. 
</LI>
<LI>
<EM>job_id</EM> - A unique job ID. 
</LI>
<LI>
<EM>output_res</EM> - Must be a valid enum of type <A HREF="#dvr_common_html_Types__dvr_video_res_e">dvr_video_res_e</A>. 
The image is resized according to this enum before being sent 
to the host. The default is <A HREF="#dvr_common_html_Types__DVR_VIDEO_RES_QCIF">DVR_VIDEO_RES_QCIF</A>. 
</LI>
<LI>
<EM>enable</EM> - enables HMO when set to 1. 
</LI>
<LI>
<EM>audio_enable</EM> - enables HMO audio when set to 1. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_osd_t"></a>
<PRE class="cdef">
typedef struct dvr_osd_struct {
    <A HREF="#dvr_common_html_Types__dvr_status_e">dvr_status_e</A> status:8;
    <A HREF="#dvr_common_html_Types__dvr_job_type_e">dvr_job_type_e</A> job_type:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> job_id;
    <A HREF="#dvr_common_html_Types__dvr_osd_pos_e">dvr_osd_pos_e</A> position:8;
    <A HREF="#dvr_common_html_Types__dvr_osd_dts_e">dvr_osd_dts_e</A> format:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> enable;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> title[10];
} <A HREF="#dvr_common_html_Types__dvr_osd_t">dvr_osd_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This structure is associated with the messages 
<A HREF="#dvr_common_html_Types__DVR_GET_OSD">DVR_GET_OSD</A>, <A HREF="#dvr_common_html_Types__DVR_SET_OSD">DVR_SET_OSD</A>, and <A HREF="#dvr_common_html_Types__DVR_REP_OSD">DVR_REP_OSD</A>. 
</P>
<P>
NOTE: These messages and the data structure will be obseleted and 
replaces with <A HREF="#dvr_common_html_Types__DVR_GET_OSD_EX">DVR_GET_OSD_EX</A>, <A HREF="#dvr_common_html_Types__DVR_SET_OSD_EX">DVR_SET_OSD_EX</A>, and <A HREF="#dvr_common_html_Types__DVR_REP_OSD_EX">DVR_REP_OSD_EX</A>. 
</P>
<UL>
<LI>
<EM>status</EM> - Status of the reply. 
</LI>
<LI>
<EM>job_type</EM> - Must be one of <A HREF="#dvr_common_html_Types__DVR_JOB_CAMERA_ENCODE">DVR_JOB_CAMERA_ENCODE</A>, 
<A HREF="#dvr_common_html_Types__DVR_JOB_HOST_ENCODE">DVR_JOB_HOST_ENCODE</A>, or <A HREF="#dvr_common_html_Types__DVR_JOB_HOST_DECODE">DVR_JOB_HOST_DECODE</A>. 
</LI>
<LI>
<EM>job_id</EM> - A unique job ID. 
</LI>
<LI>
<EM>position</EM> - OSD position, for example, <A HREF="#dvr_common_html_Types__DVR_OSD_POS_TL">DVR_OSD_POS_TL</A>. 
</LI>
<LI>
<EM>format</EM> - DTS format, for example, <A HREF="#dvr_common_html_Types__DVR_OSD_DTS_MDY_12H">DVR_OSD_DTS_MDY_12H</A>. 
</LI>
<LI>
<EM>enable</EM> - Set to 1 to turn on and to 0 to turn off OSD. 
OSD configuration is maintained while it is off. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_font_table_t"></a>
<PRE class="cdef">
typedef struct dvr_font_table_struct {
    <A HREF="#dvr_common_html_Types__dvr_status_e">dvr_status_e</A> status:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> opcode;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> font_index;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> font_format;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> port_id;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> osdheight;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> osdnglyph;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> reserved1;
    union {
        <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> osdyysize;
        <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> bufsize;
    } u1;
} <A HREF="#dvr_common_html_Types__dvr_font_table_t">dvr_font_table_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This structure is associated with the <A HREF="#dvr_common_html_Types__DVR_SET_FONT_TABLE">DVR_SET_FONT_TABLE</A> 
and <A HREF="#dvr_common_html_Types__DVR_REP_FONT_TABLE">DVR_REP_FONT_TABLE</A> messages. 
</P>
<UL>
<LI>
<EM>status</EM> - Status of the reply. 
</LI>
<LI>
<EM>opcode</EM> - The code defining the operation to be performed. 
Always set by the host. 
</LI>
<LI>
<EM>font_index</EM> - Index of the font being downloaded / selected. 
Index 0 is the default font that is built into the firmware. 
Values 0-7 are reserved by Stretch. User fonts must have index 
values between 8 and 15. 
</LI>
<LI>
<EM>font_format</EM> - The format of the font table that is being set. 
Currently <STRONG>DVR_FT_FORMAT_BMP_4_2_0</STRONG> is the only supported format. 
This field is assumed to be set by the host only when the opcode 
is <A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_START">DVR_FONT_OPCODE_START</A>. 
</LI>
<LI>
<EM>port_id</EM> - The SCT port ID that should be used by the firmware 
to download the font data. This field is assumed to be set by the 
host only when the opcode is <A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_START">DVR_FONT_OPCODE_START</A>. 
</LI>
<LI>
<EM>osdheight</EM> - The height of all the characters in the font table. 
Set only when the op_code is <A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_START">DVR_FONT_OPCODE_START</A>. 
</LI>
<LI>
<EM>osdnglyph</EM> - The number of characters (glyphs) that are to be 
downloaded. Set only when the opcode is <A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_START">DVR_FONT_OPCODE_START</A>. 
</LI>
<LI>
<EM>osdyysize</EM> - The size of the buffer required to store all the 
Y fields of the YUV character bitmaps. Set only when the opcode 
is <A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_START">DVR_FONT_OPCODE_START</A>. 
</LI>
<LI>
<EM>bufsize</EM> - The size of the buffer being sent. Set only if the 
opcode is one of the <EM>DVR_FONT_OPCODE_BUF_XXX</EM> codes. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_osd_ex_t"></a>
<PRE class="cdef">
typedef struct dvr_osd_ex_struct {
    <A HREF="#dvr_common_html_Types__dvr_status_e">dvr_status_e</A> status:8;
    <A HREF="#dvr_common_html_Types__dvr_job_type_e">dvr_job_type_e</A> job_type:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> job_id;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> op_code;
    union {
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> osd_id;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> translucent;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> position_ctrl;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> x_TL;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> y_TL;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> dts_format;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> smo_port;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> reserved2;
        } config;
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> osd_id;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> state;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> smo_port;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved1;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved2;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved3;
        } show;
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> osd_id;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> length;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> data[4];
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> smo_port;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved1;
        } text;
    } u1;
} <A HREF="#dvr_common_html_Types__dvr_osd_ex_t">dvr_osd_ex_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This structure is associated with the messages 
<A HREF="#dvr_common_html_Types__DVR_GET_OSD_EX">DVR_GET_OSD_EX</A>, <A HREF="#dvr_common_html_Types__DVR_SET_OSD_EX">DVR_SET_OSD_EX</A>, and <A HREF="#dvr_common_html_Types__DVR_REP_OSD_EX">DVR_REP_OSD_EX</A>. 
</P>
<UL>
<LI>
<EM>status</EM> - Status of the reply. 
</LI>
<LI>
<EM>job_type</EM> - Must be one of <A HREF="#dvr_common_html_Types__DVR_JOB_CAMERA_ENCODE">DVR_JOB_CAMERA_ENCODE</A>, 
<A HREF="#dvr_common_html_Types__DVR_JOB_HOST_ENCODE">DVR_JOB_HOST_ENCODE</A>, or <A HREF="#dvr_common_html_Types__DVR_JOB_HOST_DECODE">DVR_JOB_HOST_DECODE</A>. 
</LI>
<LI>
<EM>job_id</EM> - A unique job ID. 
</LI>
<LI>
<EM>op_code</EM> - The currently selected operation on the  
given OSD line ID. 
</LI>
<LI>
<EM>config</EM> - This union is associated to opcode 
<A HREF="#dvr_common_html_Defines__DVR_OSD_OPCODE_CONFIG">DVR_OSD_OPCODE_CONFIG</A> in order to configure one 
OSD item. 
</LI>
<UL>
<LI>
<EM>osd_id</EM>  - The OSD identifier to be configured. 
id zero correspond to the 1st OSD, 1 to the 2nd, etc. 
Currently only 2 OSDs can be defined. 
</LI>
<LI>
<EM>translucent</EM> - This field specifies the intensity of 
translucent when overlay OSD text is on the active video. 
0 means least translucent, 255 most  translucent. 
</LI>
<LI>
<EM>postion_ctrl</EM> - You can select the location of OSD 
text to be displayed using of the pre-define location in 
<A HREF="#dvr_common_html_Types__dvr_osd_pos_enum">dvr_osd_pos_enum</A> or specify a custom define location. 
</LI>
<LI>
<EM>x_TL</EM>, <EM>y_TL</EM> - The top left coordinates of the OSD 
test if the custom <STRONG>postion_ctrl</STRONG> is specified, otherwise 
these fields are ignored. 
</LI>
<LI>
<EM>dts_format</EM> - The format of date/time to optionally 
be appended to the end end of OSD text. 
</LI>
<LI>
<EM>smo_port</EM> - Setting this field to 0xFF causes the OSD settings to  
apply to HMO, encoder, and all the spot monitor displays. 
A value of zero causes the OSD setting to apply to HMO and encoder 
but not any of the sport monitor displays. 
Otherwise, the setting applies to the specific spot monitor displays. 
</LI>
</UL>
<LI>
<EM>show</EM> - This union is associated to opcode 
<A HREF="#dvr_common_html_Defines__DVR_OSD_OPCODE_SHOW">DVR_OSD_OPCODE_SHOW</A> in order to show or hide the given OSD 
ID for the current job. 
</LI>
<UL>
<LI>
<EM>osd_id</EM>  - The OSD identifier to set its show state. 
</LI>
<LI>
<EM>state</EM>  - Show state of the currently selected OSD id. 
zero means to hide. Otherwise, show the osd text. 
</LI>
<LI>
<EM>smo_port</EM> - Setting this field to 0xFF causes the OSD text to  
be shown or hidden on HMO, encoder, and all the spot monitor displays. 
A value of zero causes the OSD text to be shown or hidden on HMO and encoder 
but not any of the sport monitor displays. 
Otherwise, the OSD text will be shown or hidden on the specific spot monitor  
displays. 
</LI>
</UL>
<LI>
<EM>text</EM> - This union is associated to opcode 
<A HREF="#dvr_common_html_Defines__DVR_OSD_OPCODE_TEXT">DVR_OSD_OPCODE_TEXT</A> in order to set the OSD text of the given OSD 
ID for the current job. The OSD text is a unicode short string. 
It can be divided into multiple of 4 text and sent to the  
firmware. 
</LI>
<UL>
<LI>
<EM>osd_id</EM>  - The OSD identifier to set its display text. 
</LI>
<LI>
<EM>length</EM> - The total length of OSD display text. 
The maximum OSD display text size is 256. 
</LI>
<LI>
<EM>data[4]</EM> - Array of unsigned short unicode containing the 
nth 4 string of the OSD text. The maximum size of an OSD 
text is 256 unsigned short. 
</LI>
<LI>
<EM>smo_port</EM> - Setting this field to 0xFF causes the OSD text to  
be changes on HMO, encoder, and all the spot monitor displays. 
A value of zero causes the OSD text to be changed on HMO and encoder 
but not any of the sport monitor displays. 
Otherwise, the OSD text will be changed on the specific spot monitor  
displays. 
</LI>
</UL>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_auth_key_t"></a>
<PRE class="cdef">
typedef struct dvr_auth_key_struct {
    <A HREF="#dvr_common_html_Types__dvr_status_e">dvr_status_e</A> status:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> board_id;
    union {
        <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> read_offset;
        <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> read_length;
    } u1;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> total_length;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> data[12];
} <A HREF="#dvr_common_html_Types__dvr_auth_key_t">dvr_auth_key_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This structure is associated with the messages 
<A HREF="#dvr_common_html_Types__DVR_GET_AUTH_KEY">DVR_GET_AUTH_KEY</A>, <A HREF="#dvr_common_html_Types__DVR_REP_AUTH_KEY">DVR_REP_AUTH_KEY</A>. 
</P>
<UL>
<LI>
<EM>status</EM> - Status of the reply. 
</LI>
<LI>
<EM>board_id</EM> - The board identifier. 
</LI>
<LI>
<EM>read_offset</EM> - For the GET command, this is offset of the key 
to read from. For example, setting this to zero is a command to 
read the first 12 bytes of the key. 
</LI>
<LI>
<EM>read_length</EM> - For the REP command, this specifies the number 
of bytes actually copied into the data field. This value will 
always be less than or equal to 12. 
</LI>
<LI>
<EM>total_length</EM> - For the REP command, this specifies the total 
length of the key in bytes. Currently the maximum key length 
is 256 bits, or 32 bytes. For the GET command, this field is 
unused. 
</LI>
<LI>
<EM>data</EM> - Array of unsigned chars in which the key fragments 
are returned. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_regions_map_t"></a>
<PRE class="cdef">
typedef struct dvr_regions_map_struct {
    <A HREF="#dvr_common_html_Types__dvr_status_e">dvr_status_e</A> status:8;
    <A HREF="#dvr_common_html_Types__dvr_job_type_e">dvr_job_type_e</A> job_type:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> job_id;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> opcode;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> region_type;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved1;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> reserved2;
    union {
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> threshold1;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> threshold2;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> threshold3;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> threshold4;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved3;
        } config;
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> enable_flag;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved3;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> reserved4;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved5;
        } enable;
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> map_size;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> overlay_num;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved3;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved4;
        } map;
    } u1;
} <A HREF="#dvr_common_html_Types__dvr_regions_map_t">dvr_regions_map_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This structure is associated with the <A HREF="#dvr_common_html_Types__DVR_SET_REGIONS_MAP">DVR_SET_REGIONS_MAP</A> 
and <A HREF="#dvr_common_html_Types__DVR_REP_REGIONS_MAP">DVR_REP_REGIONS_MAP</A> messages. It is used to send a different 
regions map for alarm detection and privacy blocking, as well as, 
configuring them. 
</P>
<P>
Common Fields: 
</P>
<UL>
<LI>
<EM>status</EM> - Status of the reply. 
</LI>
<LI>
<EM>job_type</EM> - Must be one of <A HREF="#dvr_common_html_Types__DVR_JOB_CAMERA_ENCODE">DVR_JOB_CAMERA_ENCODE</A>, 
<A HREF="#dvr_common_html_Types__DVR_JOB_HOST_ENCODE">DVR_JOB_HOST_ENCODE</A>, or <A HREF="#dvr_common_html_Types__DVR_JOB_HOST_DECODE">DVR_JOB_HOST_DECODE</A>. 
</LI>
<LI>
<EM>job_id</EM> - A unique job ID. 
</LI>
<LI>
<EM>opcode</EM> - The code defining the operation to be performed. 
Always set by the host. 
</LI>
<LI>
<EM>region_type</EM> - The region map type to be affected by the opcode. 
</LI>
</UL>
<P>
Config Command Fields: 
</P>
<UL>
<LI>
<EM>threshold1</EM> - Alarm threshold for overlay number 1 of the specified 
region type. 
</LI>
<LI>
<EM>threshold2</EM> - Alarm threshold for overlay number 1 of the specified 
region type. 
</LI>
<LI>
<EM>threshold3</EM> - Alarm threshold for overlay number 1 of the specified 
region type. 
</LI>
<LI>
<EM>threshold4</EM> - Alarm threshold for overlay number 1 of the specified 
region type. 
</LI>
<LI>
<STRONG>NOTE</STRONG>: Currently, overlay numbers 2-4 are valid only for region type 
<A HREF="#dvr_common_html_Defines__DVR_REGION_TYPE_MD">DVR_REGION_TYPE_MD</A>. For all others, these are ignored. 
</LI>
</UL>
<P>
Enable Command Fields: 
</P>
<UL>
<LI>
<EM>enable_flag</EM> - Set to 1 to enable alarm detection, set to zero to 
disable alarm detection. 
</LI>
</UL>
<P>
Map Command Fields: 
</P>
<UL>
<LI>
<EM>map_size</EM> - The size of the regions map. This size is always the 
same as the D1 size video frame for the current video standard. 
This field must be set by the host for <A HREF="#dvr_common_html_Defines__DVR_REGION_OPCODE_START">DVR_REGION_OPCODE_START</A> 
and <A HREF="#dvr_common_html_Defines__DVR_REGION_OPCODE_FINISH">DVR_REGION_OPCODE_FINISH</A>. 
</LI>
<LI>
<EM>overlay_num</EM> - The region overlay number to set its ROI map. 
Value of zero (0) in this field means the ROI map which is being 
sent includes all the overlay ROI for the current region type. 
Otherwise, it is the nth overlay number. 
For region_type of <A HREF="#dvr_common_html_Defines__DVR_REGION_TYPE_MD">DVR_REGION_TYPE_MD</A>: the valid 
range is 0 - 4. For all other region_type the valid value is 0 or 1. 
This field must be set by the host for <A HREF="#dvr_common_html_Defines__DVR_REGION_OPCODE_START">DVR_REGION_OPCODE_START</A> 
and <A HREF="#dvr_common_html_Defines__DVR_REGION_OPCODE_FINISH">DVR_REGION_OPCODE_FINISH</A>. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_pr_t"></a>
<PRE class="cdef">
typedef struct dvr_pr_struct {
    <A HREF="#dvr_common_html_Types__dvr_status_e">dvr_status_e</A> status:8;
    <A HREF="#dvr_common_html_Types__dvr_job_type_e">dvr_job_type_e</A> job_type:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> job_id;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> op_code;
    union {
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> enable;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved1;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> reserved2;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved3;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved4;
        } ctrl;
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> index;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> enable;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> x_TL;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> y_TL;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> x_BR;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> y_BR;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> reserved1;
        } reg;
    } u1;
} <A HREF="#dvr_common_html_Types__dvr_pr_t">dvr_pr_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This structure is associated with the messages 
<A HREF="#dvr_common_html_Types__DVR_GET_PR">DVR_GET_PR</A>, <A HREF="#dvr_common_html_Types__DVR_SET_PR">DVR_SET_PR</A>, and <A HREF="#dvr_common_html_Types__DVR_REP_PR">DVR_REP_PR</A>. 
</P>
<UL>
<LI>
<EM>status</EM> - Status of the reply. 
</LI>
<LI>
<EM>job_type</EM> - Must be one of <A HREF="#dvr_common_html_Types__DVR_JOB_CAMERA_ENCODE">DVR_JOB_CAMERA_ENCODE</A>, 
<A HREF="#dvr_common_html_Types__DVR_JOB_HOST_ENCODE">DVR_JOB_HOST_ENCODE</A>, or <A HREF="#dvr_common_html_Types__DVR_JOB_HOST_DECODE">DVR_JOB_HOST_DECODE</A>. 
</LI>
<LI>
<EM>job_id</EM> - A unique job ID. 
</LI>
<LI>
<EM>enable</EM> - Set to 1 to enable and to 0 to disable motion detection. 
The default is 0. 
</LI>
<LI>
<EM>num_region</EM> - Number of private regions. A value of 1 means only 
blank out the first region. A value of 2 means blank out 
both regions. 
</LI>
<LI>
<EM>x00,y00,x01,y01</EM> - First rectangular region to be blanked 
for privacy. 
</LI>
<LI>
<EM>x10,y10,x11,y11</EM> - Second rectangular region to be blanked 
for privacy. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_md_t"></a>
<PRE class="cdef">
typedef struct dvr_md_struct {
    <A HREF="#dvr_common_html_Types__dvr_status_e">dvr_status_e</A> status:8;
    <A HREF="#dvr_common_html_Types__dvr_job_type_e">dvr_job_type_e</A> job_type:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> job_id;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> op_code;
    union {
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> enable;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> threshold;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> reserved2;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved3;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved4;
        } ctrl;
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> index;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> enable;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> x_TL;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> y_TL;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> x_BR;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> y_BR;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> reserved1;
        } reg;
    } u1;
} <A HREF="#dvr_common_html_Types__dvr_md_t">dvr_md_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This structure is associated with the messages 
<A HREF="#dvr_common_html_Types__DVR_GET_MD">DVR_GET_MD</A>, <A HREF="#dvr_common_html_Types__DVR_SET_MD">DVR_SET_MD</A>, and <A HREF="#dvr_common_html_Types__DVR_REP_MD">DVR_REP_MD</A>. 
</P>
<UL>
<LI>
<EM>status</EM> - Status of the reply. 
</LI>
<LI>
<EM>job_type</EM> - Must be one of <A HREF="#dvr_common_html_Types__DVR_JOB_CAMERA_ENCODE">DVR_JOB_CAMERA_ENCODE</A>, 
<A HREF="#dvr_common_html_Types__DVR_JOB_HOST_ENCODE">DVR_JOB_HOST_ENCODE</A>, or <A HREF="#dvr_common_html_Types__DVR_JOB_HOST_DECODE">DVR_JOB_HOST_DECODE</A>. 
</LI>
<LI>
<EM>job_id</EM> - A unique job ID. 
</LI>
<LI>
<EM>threshold</EM> - Motion detection threshold.  The valid range is 
0 - 99. Default is 15. 
</LI>
<LI>
<EM>enable</EM> - Set to 1 to enable and to 0 to disable motion detection. 
</LI>
<LI>
<EM>num_region</EM> - Number of regions to be used.  0 
implies the whole image, 1 uses the first region, 
and 2 uses both regions. 
</LI>
<LI>
<EM>x00,y00,x01,y01</EM> - First rectangular region to be used 
for detecting motion. 
</LI>
<LI>
<EM>x10,y10,x11,y11</EM> - Second rectangular region to be used 
for detecting motion. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_bd_t"></a>
<PRE class="cdef">
typedef struct dvr_bd_struct {
    <A HREF="#dvr_common_html_Types__dvr_status_e">dvr_status_e</A> status:8;
    <A HREF="#dvr_common_html_Types__dvr_job_type_e">dvr_job_type_e</A> job_type:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> job_id;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> op_code;
    union {
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> enable;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> threshold;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> reserved2;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved3;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved4;
        } ctrl;
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> index;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> enable;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> x_TL;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> y_TL;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> x_BR;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> y_BR;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> reserved1;
        } reg;
    } u1;
} <A HREF="#dvr_common_html_Types__dvr_bd_t">dvr_bd_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This structure is associated with the messages 
<A HREF="#dvr_common_html_Types__DVR_GET_BD">DVR_GET_BD</A>, <A HREF="#dvr_common_html_Types__DVR_SET_BD">DVR_SET_BD</A>, and <A HREF="#dvr_common_html_Types__DVR_REP_BD">DVR_REP_BD</A>. 
</P>
<UL>
<LI>
<EM>status</EM> - Status of the reply. 
</LI>
<LI>
<EM>job_type</EM> - Must be one of <A HREF="#dvr_common_html_Types__DVR_JOB_CAMERA_ENCODE">DVR_JOB_CAMERA_ENCODE</A>, 
<A HREF="#dvr_common_html_Types__DVR_JOB_HOST_ENCODE">DVR_JOB_HOST_ENCODE</A>, or <A HREF="#dvr_common_html_Types__DVR_JOB_HOST_DECODE">DVR_JOB_HOST_DECODE</A>. 
</LI>
<LI>
<EM>job_id</EM> - A unique job ID. 
</LI>
<LI>
<EM>threshold</EM> - Blind detection threshold.  The valid range is 
0 - 99. Default is 50. 
</LI>
<LI>
<EM>enable</EM> - Set to 1 to enable and to 0 to disable blind detection. 
</LI>
<LI>
<EM>num_region</EM> - Number of regions to be used.  0 
implies the whole image, 1 uses the first region, 
and 2 uses both regions. 
</LI>
<LI>
<EM>x00,y00,x01,y01</EM> - First rectangular region to be used 
for blind detection. 
</LI>
<LI>
<EM>x10,y10,x11,y11</EM> - Second rectangular region to be used 
for blind detection. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_nd_t"></a>
<PRE class="cdef">
typedef struct dvr_nd_struct {
    <A HREF="#sdvr_sdk_html_Types__sx_int8">sx_int8</A> status;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> job_type;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> job_id;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> enable;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> threshold;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved0;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> reserved1;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved2;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved3;
} <A HREF="#dvr_common_html_Types__dvr_nd_t">dvr_nd_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This structure is associated with the messages 
<A HREF="#dvr_common_html_Types__DVR_GET_ND">DVR_GET_ND</A>, <A HREF="#dvr_common_html_Types__DVR_SET_ND">DVR_SET_ND</A>, and <A HREF="#dvr_common_html_Types__DVR_REP_ND">DVR_REP_ND</A>. 
</P>
<UL>
<LI>
<EM>status</EM> - Status of the reply. 
</LI>
<LI>
<EM>job_type</EM> - Must be one of <A HREF="#dvr_common_html_Types__DVR_JOB_CAMERA_ENCODE">DVR_JOB_CAMERA_ENCODE</A>, 
<A HREF="#dvr_common_html_Types__DVR_JOB_HOST_ENCODE">DVR_JOB_HOST_ENCODE</A>, or <A HREF="#dvr_common_html_Types__DVR_JOB_HOST_DECODE">DVR_JOB_HOST_DECODE</A>. 
</LI>
<LI>
<EM>job_id</EM> - A unique job ID. 
</LI>
<LI>
<EM>enable</EM> - Set to 1 to enable and to 0 to disable night detection. 
The default is 0. 
</LI>
<LI>
<EM>threshold</EM> - Night detection threshold. The valid range is 
0 - 255. Default is 40. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_encode_info_t"></a>
<PRE class="cdef">
typedef struct dvr_encode_info_struct {
    <A HREF="#dvr_common_html_Types__dvr_status_e">dvr_status_e</A> status:8;
    <A HREF="#dvr_common_html_Types__dvr_job_type_e">dvr_job_type_e</A> job_type:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> job_id;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> stream_id;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> record_frame_rate;
    <A HREF="#dvr_common_html_Types__dvr_video_res_e">dvr_video_res_e</A> record_res:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> enable;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved1;
    union {
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved2;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved3;
        } none;
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> avg_bitrate;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> max_bitrate;
            <A HREF="#dvr_common_html_Types__dvr_rc_e">dvr_rc_e</A> rate_control:8;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> gop_size;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> quality;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved2;
        } h264;
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> quality;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> jpeg_style;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved2;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved3;
        } jpeg;
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> avg_bitrate;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> max_bitrate;
            <A HREF="#dvr_common_html_Types__dvr_rc_e">dvr_rc_e</A> rate_control:8;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> gop_size;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> quality;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved2;
        } mpeg4;
    } u1;
} <A HREF="#dvr_common_html_Types__dvr_encode_info_t">dvr_encode_info_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This structure is associated with the following messages: 
<A HREF="#dvr_common_html_Types__DVR_GET_ENCODE">DVR_GET_ENCODE</A>, <A HREF="#dvr_common_html_Types__DVR_SET_ENCODE">DVR_SET_ENCODE</A>, and <A HREF="#dvr_common_html_Types__DVR_REP_ENCODE">DVR_REP_ENCODE</A>. 
</P>
<P>
Common fields: 
</P>
<UL>
<LI>
<EM>status</EM> - Status of the reply. This field is only valid for 
a <A HREF="#dvr_common_html_Types__DVR_REP_ENCODE">DVR_REP_ENCODE</A> message. 
</LI>
<LI>
<EM>job_type</EM> - Must be <A HREF="#dvr_common_html_Types__DVR_JOB_CAMERA_ENCODE">DVR_JOB_CAMERA_ENCODE</A>. 
</LI>
<LI>
<EM>job_id</EM> - A unique job ID. 
</LI>
<LI>
<EM>stream_id</EM> - The stream identifier, specifies which encode 
stream is being queried or configured. Currently, must be  
0 (primary) or 1 (secondary). 
</LI>
<LI>
<EM>record_frame_rate</EM> - Recording frame rate, must be between 1 
and the maximum allowed by the video standard (25 for PAL and 
30 for NTSC). 
</LI>
<LI>
<EM>record_res</EM> - The video resolution to record at. Must be a 
valid enum of type <A HREF="#dvr_common_html_Types__dvr_video_res_e">dvr_video_res_e</A>. Not all values of  
<A HREF="#dvr_common_html_Types__dvr_video_res_e">dvr_video_res_e</A> may be supported by all boards. Selecting 
any value other than <A HREF="#dvr_common_html_Types__DVR_VIDEO_RES_FULL">DVR_VIDEO_RES_FULL</A>, <A HREF="#dvr_common_html_Types__DVR_VIDEO_RES_CIF">DVR_VIDEO_RES_CIF</A>, 
or <A HREF="#dvr_common_html_Types__DVR_VIDEO_RES_QCIF">DVR_VIDEO_RES_QCIF</A> can have an impact on performance due 
to additional rescaling performed prior to encoding. 
</LI>
<LI>
<EM>enable</EM> - Set to 1 to enable or to 0 to disable the encode 
stream. 
</LI>
</UL>
<P>
H.264-specific fields: 
</P>
<UL>
<LI>
<EM>avg_bitrate</EM> - Average bit rate to be maintained, in Kbps. 
Only applicable to <STRONG>DVR_H264_RC_VBR</STRONG> and <STRONG>DVR_H264_RC_CBR</STRONG>, 
ignored for other RC modes. 
</LI>
<LI>
<EM>max_bitrate</EM> - Maximum bit rate allowed, in Kbps. Ignored 
for <STRONG>DVR_H264_RC_CBR</STRONG>. 
</LI>
<LI>
<EM>rate_control</EM> - Rate control algorithm. Must be one of 
<STRONG>DVR_H264_RC_VBR</STRONG>, <STRONG>DVR_H264_RC_CBR</STRONG>, or <STRONG>DVR_H264_RC_CQ</STRONG>. 
</LI>
<LI>
<EM>gop_size</EM> - Number of pictures in a GOP. It is recommended 
that this value be set to have one GOP per second of video. 
</LI>
<LI>
<EM>quality</EM> - Quality level, must be between 0 and 100. This is 
applicable only for <STRONG>DVR_H264_RC_CQ</STRONG> mode, and is ignored for 
other RC modes. 
</LI>
</UL>
<P>
MJPEG-specific fields: 
</P>
<UL>
<LI>
<EM>quality</EM> - Specifies the quality of compression. A higher number 
implies better quality. Must be between 10 to 300. 
</LI>
<LI>
<EM>jpeg_style</EM> - Controls frame header generation. Must be set to 
either 0 (for motion JPEG frame header) or 1 (for image style  
frame header). 
</LI>
</UL>
<P>
MPEG4-specific fields: 
</P>
<UL>
<LI>
<EM>avg_bitrate</EM> - Average bit rate to be maintained, in Kbps. 
Only applicable to <STRONG>DVR_MPEG4_RC_VBR</STRONG> and <STRONG>DVR_MPEG4_RC_CBR</STRONG>, 
ignored for other RC modes. 
</LI>
<LI>
<EM>max_bitrate</EM> - Maximum bit rate allowed, in Kbps. Ignored 
for <STRONG>DVR_MPEG4_RC_CBR</STRONG>. 
</LI>
<LI>
<EM>rate_control</EM> - Rate control algorithm. Must be one of 
<STRONG>DVR_MPEG4_RC_VBR</STRONG> or <STRONG>DVR_MPEG4_RC_CBR</STRONG>. 
</LI>
<LI>
<EM>gop_size</EM> - Number of pictures in a GOP. It is recommended 
that this value be set to have one GOP per second of video. 
</LI>
<LI>
<EM>quality</EM> - Quality level, must be between 0 (best) and 7 (worst). 
The recommended (and default) value is 3. Only applicable to 
<STRONG>DVR_MPEG4_RC_VBR</STRONG>, ignored for other modes. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_enc_alarm_info_t"></a>
<PRE class="cdef">
typedef struct dvr_enc_alarm_info_struct {
    <A HREF="#dvr_common_html_Types__dvr_status_e">dvr_status_e</A> status:8;
    <A HREF="#dvr_common_html_Types__dvr_job_type_e">dvr_job_type_e</A> job_type:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> job_id;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> stream_id;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> record_frame_rate;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> min_on_seconds;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> min_off_seconds;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> enable;
    union {
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved1;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved2;
        } none;
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> avg_bitrate;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> max_bitrate;
            <A HREF="#dvr_common_html_Types__dvr_rc_e">dvr_rc_e</A> rate_control:8;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> gop_size;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> quality;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved1;
        } h264;
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> quality;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> jpeg_style;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved1;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved2;
        } jpeg;
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> avg_bitrate;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> max_bitrate;
            <A HREF="#dvr_common_html_Types__dvr_rc_e">dvr_rc_e</A> rate_control:8;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> gop_size;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> quality;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved1;
        } mpeg4;
    } u1;
} <A HREF="#dvr_common_html_Types__dvr_enc_alarm_info_t">dvr_enc_alarm_info_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This structure is associated with the following messages: 
<STRONG>DVR_GET_ALARM</STRONG>, <STRONG>DVR_SET_ALARM</STRONG>, and <STRONG>DVR_REP_ALARM</STRONG>. 
</P>
<P>
Common fields: 
</P>
<UL>
<LI>
<EM>status</EM> - Status of the reply. This field is only valid for 
a <A HREF="#dvr_common_html_Types__DVR_REP_ENC_ALARM">DVR_REP_ENC_ALARM</A> message. 
</LI>
<LI>
<EM>job_type</EM> - Must be <A HREF="#dvr_common_html_Types__DVR_JOB_CAMERA_ENCODE">DVR_JOB_CAMERA_ENCODE</A>. 
</LI>
<LI>
<EM>job_id</EM> - A unique job ID. 
</LI>
<LI>
<EM>stream_id</EM> - The stream identifier, specifies which encode 
stream is being queried or configured. Currently, must be  
0 (primary) or 1 (secondary). 
</LI>
<LI>
<EM>record_frame_rate</EM> - Recording frame rate, must be between 1 
and the maximum allowed by the video standard (25 for PAL and 
30 for NTSC). 
</LI>
<LI>
<EM>min_on_seconds</EM>,<EM>min_off_seconds</EM> - Minimum number of seconds 
to remain in alarm mode (normal mode) before returning to normal 
mode (alarm mode).  This is to prevent the alarm being on and off 
too frequently. 
</LI>
<LI>
<EM>enable</EM> - Set to 1 to enable or to 0 to disable the encode 
stream. 
</LI>
</UL>
<P>
H.264-specific fields: 
</P>
<UL>
<LI>
<EM>avg_bitrate</EM> - Average bit rate to be maintained, in Kbps. 
Only applicable to <STRONG>DVR_H264_RC_VBR</STRONG> and <STRONG>DVR_H264_RC_CBR</STRONG>, 
ignored for other RC modes. 
</LI>
<LI>
<EM>max_bitrate</EM> - Maximum bit rate allowed, in Kbps. Ignored 
for <STRONG>DVR_H264_RC_CBR</STRONG>. 
</LI>
<LI>
<EM>rate_control</EM> - Rate control algorithm. Must be one of 
<STRONG>DVR_H264_RC_VBR</STRONG>, <STRONG>DVR_H264_RC_CBR</STRONG>, or <STRONG>DVR_H264_RC_CQ</STRONG>. 
</LI>
<LI>
<EM>gop_size</EM> - Number of pictures in a GOP. It is recommended 
that this value be set to have one GOP per second of video. 
</LI>
<LI>
<EM>quality</EM> - Quality level, must be between 0 and 100. This is 
applicable only for <STRONG>DVR_H264_RC_CQ</STRONG> mode, and is ignored for 
other RC modes. 
</LI>
</UL>
<P>
MJPEG-specific fields: 
</P>
<UL>
<LI>
<EM>quality</EM> - Specifies the quality of compression. A higher number 
implies better quality. Must be between 10 to 300. 
</LI>
<LI>
<EM>jpeg_style</EM> - Controls frame header generation. Must be set to 
either 0 (for motion JPEG frame header) or 1 (for image style  
frame header). 
</LI>
</UL>
<P>
MPEG4-specific fields: 
</P>
<UL>
<LI>
<EM>avg_bitrate</EM> - Average bit rate to be maintained, in Kbps. 
Only applicable to <STRONG>DVR_MPEG4_RC_VBR</STRONG> and <STRONG>DVR_MPEG4_RC_CBR</STRONG>, 
ignored for other RC modes. 
</LI>
<LI>
<EM>max_bitrate</EM> - Maximum bit rate allowed, in Kbps. Ignored 
for <STRONG>DVR_MPEG4_RC_CBR</STRONG>. 
</LI>
<LI>
<EM>rate_control</EM> - Rate control algorithm. Must be one of 
<STRONG>DVR_MPEG4_RC_VBR</STRONG> or <STRONG>DVR_MPEG4_RC_CBR</STRONG>. 
</LI>
<LI>
<EM>gop_size</EM> - Number of pictures in a GOP. It is recommended 
that this value be set to have one GOP per second of video. 
</LI>
<LI>
<EM>quality</EM> - Quality level, must be between 0 (best) and 7 (worst). 
The recommended (and default) value is 3. Only applicable to 
<STRONG>DVR_MPEG4_RC_VBR</STRONG>, ignored for other modes. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_decode_info_t"></a>
<PRE class="cdef">
typedef struct dvr_decode_info_struct {
    <A HREF="#dvr_common_html_Types__dvr_status_e">dvr_status_e</A> status:8;
    <A HREF="#dvr_common_html_Types__dvr_job_type_e">dvr_job_type_e</A> job_type:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> job_id;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> enable;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> width;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> height;
    union {
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved3;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved4;
        } h264;
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved3;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved4;
        } jpeg;
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved3;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved4;
        } mpeg4;
    } u1;
} <A HREF="#dvr_common_html_Types__dvr_decode_info_t">dvr_decode_info_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This structure is associated with the following messages: 
<A HREF="#dvr_common_html_Types__DVR_GET_DECODE">DVR_GET_DECODE</A>, <A HREF="#dvr_common_html_Types__DVR_SET_DECODE">DVR_SET_DECODE</A>, and <A HREF="#dvr_common_html_Types__DVR_REP_DECODE">DVR_REP_DECODE</A>. 
</P>
<P>
Common fields: 
</P>
<UL>
<LI>
<EM>status</EM> - Status of the reply. This field is only valid for 
a <A HREF="#dvr_common_html_Types__DVR_REP_DECODE">DVR_REP_DECODE</A> message. 
</LI>
<LI>
<EM>job_type</EM> - Must be <A HREF="#dvr_common_html_Types__DVR_JOB_HOST_DECODE">DVR_JOB_HOST_DECODE</A>. 
</LI>
<LI>
<EM>job_id</EM> - A unique job ID. 
</LI>
<LI>
<EM>enable</EM> - Set to 1 to enable or to 0 to disable the decoder. 
</LI>
<LI>
<EM>width</EM> - Width in pixels of the encoded frames. 
</LI>
<LI>
<EM>height</EM> - Height in pixels of the encoded frames. 
</LI>
</UL>
<P>
<STRONG>NOTE</STRONG>: Width and height combinations must match one of the supported 
video resolutions. These parameters can be changed every time the job 
is being enabled. 
</P>
<P>
H.264-specific fields: 
</P>
<UL>
<LI>
None. 
</LI>
</UL>
<P>
MJPEG-specific fields: 
</P>
<UL>
<LI>
None. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_relay_t"></a>
<PRE class="cdef">
typedef struct dvr_relay_struct {
    <A HREF="#dvr_common_html_Types__dvr_status_e">dvr_status_e</A> status:8;
    <A HREF="#sdvr_sdk_html_Types__sx_int8">sx_int8</A> reserved0;
    <A HREF="#sdvr_sdk_html_Types__sx_int16">sx_int16</A> reserved1;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> relay_status;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved3;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved4;
} <A HREF="#dvr_common_html_Types__dvr_relay_t">dvr_relay_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This structure is associated with the messages 
<A HREF="#dvr_common_html_Types__DVR_GET_RELAYS">DVR_GET_RELAYS</A>, <A HREF="#dvr_common_html_Types__DVR_SET_RELAYS">DVR_SET_RELAYS</A>, and <A HREF="#dvr_common_html_Types__DVR_REP_RELAYS">DVR_REP_RELAYS</A>. 
</P>
<UL>
<LI>
<EM>status</EM> - Status of the reply. 
</LI>
<LI>
<EM>relay_status</EM> - This is a bit field, one bit per relay output: 
</LI>
<UL>
<LI>
For <A HREF="#dvr_common_html_Types__DVR_GET_RELAYS">DVR_GET_RELAYS</A>, this field is unused. 
</LI>
<LI>
For <A HREF="#dvr_common_html_Types__DVR_REP_RELAYS">DVR_REP_RELAYS</A>, this field reflects the status of the 
relay outputs. If a bit is 1, the corresponding relay is on; 
if the bit is 0, the relay is off. 
</LI>
<LI>
For <A HREF="#dvr_common_html_Types__DVR_SET_RELAYS">DVR_SET_RELAYS</A>, this field specifies the new states of 
the relay outputs. 
</LI>
</UL>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_sensor_t"></a>
<PRE class="cdef">
typedef struct dvr_sensor_struct {
    <A HREF="#dvr_common_html_Types__dvr_status_e">dvr_status_e</A> status:8;
    <A HREF="#sdvr_sdk_html_Types__sx_int8">sx_int8</A> reserved0;
    <A HREF="#sdvr_sdk_html_Types__sx_int16">sx_int16</A> reserved1;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> sensor_status;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> sensor_enable;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> edge_triggered;
} <A HREF="#dvr_common_html_Types__dvr_sensor_t">dvr_sensor_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This structure is associated with the messages 
<A HREF="#dvr_common_html_Types__DVR_GET_SENSORS">DVR_GET_SENSORS</A>, <A HREF="#dvr_common_html_Types__DVR_SET_SENSORS">DVR_SET_SENSORS</A>, and <A HREF="#dvr_common_html_Types__DVR_REP_SENSORS">DVR_REP_SENSORS</A>. 
</P>
<UL>
<LI>
<EM>status</EM> - Status of the reply. 
</LI>
<LI>
<EM>sensor_status</EM> - For <A HREF="#dvr_common_html_Types__DVR_REP_SENSORS">DVR_REP_SENSORS</A>, this reports the states 
of the sensors, one bit per sensor input. 
</LI>
<LI>
<EM>sensor_enable</EM> - For <A HREF="#dvr_common_html_Types__DVR_SET_SENSORS">DVR_SET_SENSORS</A>, this specifies the set of 
sensors to enable. If a bit is set to 1, the corresponding sensor 
is enabled. 
</LI>
<LI>
<EM>edge_triggered</EM> - For <A HREF="#dvr_common_html_Types__DVR_SET_SENSORS">DVR_SET_SENSORS</A>, this specifies the trigger 
mode. Set to 1 for edge triggered and to 0 for level sensitive, one 
bit per sensor input. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_watchdog_t"></a>
<PRE class="cdef">
typedef struct dvr_watchdog_struct {
    <A HREF="#dvr_common_html_Types__dvr_status_e">dvr_status_e</A> status:8;
    <A HREF="#sdvr_sdk_html_Types__sx_int8">sx_int8</A> reserved0;
    <A HREF="#sdvr_sdk_html_Types__sx_int16">sx_int16</A> reserved1;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> enable;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> msec;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved3;
} <A HREF="#dvr_common_html_Types__dvr_watchdog_t">dvr_watchdog_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This structure is associated with the messages 
<A HREF="#dvr_common_html_Types__DVR_GET_WATCHDOG">DVR_GET_WATCHDOG</A>, <A HREF="#dvr_common_html_Types__DVR_SET_WATCHDOG">DVR_SET_WATCHDOG</A>, and <A HREF="#dvr_common_html_Types__DVR_REP_WATCHDOG">DVR_REP_WATCHDOG</A>. 
</P>
<UL>
<LI>
<EM>status</EM> - status of the reply. 
</LI>
<LI>
<EM>enable</EM> - Enables the watchdog timer if set to a nonzero value, 
disables the timer if set to zero. Once enabled, the timer must 
be refreshed at intervals not exceeding the specified timeout. 
For <A HREF="#dvr_common_html_Types__DVR_REP_WATCHDOG">DVR_REP_WATCHDOG</A> messages, this field indicates the current 
enable state of the watchdog timer. 
</LI>
<LI>
<EM>msec</EM> - Specifies the watchdog timeout period. The valid range is 
1 to 10,000 msec. If this field is zero and the enable flag is set 
then the timeout period defaults to 10,000 msec (10 sec). If the  
enable flag is not set, this field is ignored. 
For <A HREF="#dvr_common_html_Types__DVR_REP_WATCHDOG">DVR_REP_WATCHDOG</A> messages, this field is always zero. 
</LI>
<LI>
<STRONG>NOTE</STRONG>: Once the watchdog function is enabled, successive 
<A HREF="#dvr_common_html_Types__DVR_SET_WATCHDOG">DVR_SET_WATCHDOG</A> commands must be sent to the board before 
the previous timeout expires. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_control_t"></a>
<PRE class="cdef">
typedef struct dvr_control_struct {
    <A HREF="#dvr_common_html_Types__dvr_status_e">dvr_status_e</A> status:8;
    <A HREF="#dvr_common_html_Types__dvr_job_type_e">dvr_job_type_e</A> job_type:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> job_id;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> enable;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved1;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved2;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved3;
} <A HREF="#dvr_common_html_Types__dvr_control_t">dvr_control_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This structure is associated with the messages 
<A HREF="#dvr_common_html_Types__DVR_GET_CONTROL">DVR_GET_CONTROL</A>, <A HREF="#dvr_common_html_Types__DVR_SET_CONTROL">DVR_SET_CONTROL</A>, and <A HREF="#dvr_common_html_Types__DVR_REP_CONTROL">DVR_REP_CONTROL</A>. 
</P>
<UL>
<LI>
<EM>status</EM> - Status of the reply. 
</LI>
<LI>
<EM>job_type</EM> - Must be one of <A HREF="#dvr_common_html_Types__DVR_JOB_CAMERA_ENCODE">DVR_JOB_CAMERA_ENCODE</A>, 
<A HREF="#dvr_common_html_Types__DVR_JOB_HOST_ENCODE">DVR_JOB_HOST_ENCODE</A>, or <A HREF="#dvr_common_html_Types__DVR_JOB_HOST_DECODE">DVR_JOB_HOST_DECODE</A>. 
</LI>
<LI>
<EM>job_id</EM> - A unique job ID. 
</LI>
<LI>
<EM>enable</EM> - Set to none-zero value to enable and to 0 to 
disables the job. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_time_t"></a>
<PRE class="cdef">
typedef struct dvr_time_struct {
    <A HREF="#dvr_common_html_Types__dvr_status_e">dvr_status_e</A> status:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved0;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> reserved1;
    <A HREF="#sdvr_sdk_html_Types__sx_int32">sx_int32</A> tv_sec;
    <A HREF="#sdvr_sdk_html_Types__sx_int32">sx_int32</A> tv_usec;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved3;
} <A HREF="#dvr_common_html_Types__dvr_time_t">dvr_time_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This structure is associated with the messages 
<A HREF="#dvr_common_html_Types__DVR_GET_TIME">DVR_GET_TIME</A>, <A HREF="#dvr_common_html_Types__DVR_SET_TIME">DVR_SET_TIME</A>, and <A HREF="#dvr_common_html_Types__DVR_REP_TIME">DVR_REP_TIME</A>. 
</P>
<UL>
<LI>
<EM>status</EM> - Status of the reply. 
</LI>
<LI>
<EM>tv_sec</EM>, <EM>tv_usec</EM> - Number of seconds and microseconds 
since Epoch. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_data_header_t"></a>
<PRE class="cdef">
typedef struct dvr_data_header_struct {
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> signature;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> version;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> hdr_size;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> board_id;
    <A HREF="#dvr_common_html_Types__dvr_job_type_e">dvr_job_type_e</A> job_type:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> job_id;
    <A HREF="#dvr_common_html_Types__dvr_data_type_e">dvr_data_type_e</A> data_type:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> motion_value;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> blind_value;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> night_value;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> state_flags;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> stream_id;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved2;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> reserved3;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> data_size;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> ts;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> ts_high;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> mval[4];
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> bval[4];
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> nval[4];
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> active_width;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> padded_width;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> active_height;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> padded_height;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> seq_number;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> frame_number;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> drop_count;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved4[3];
    <A HREF="#dvr_common_html_Types__dvr_rawv_format_e">dvr_rawv_format_e</A> yuv_format:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> y_data_size;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> u_data_size;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> v_data_size;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> y_data_offset;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> u_data_offset;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> v_data_offset;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> uv_active_width;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> uv_padded_width;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> uv_active_height;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> uv_padded_height;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved[39];
} <A HREF="#dvr_common_html_Types__dvr_data_header_t">dvr_data_header_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This structure describes the contents of every data buffer 
exchanged between the host and the firmware. Every data buffer must 
begin with this structure at its head. 
</P>
<UL>
<LI>
<EM>signature</EM> - The header signature. This is used to detect a 
valid header. Must always be set to <A HREF="#dvr_common_html_Defines__DVR_DATA_HDR_SIG">DVR_DATA_HDR_SIG</A>. 
</LI>
<LI>
<EM>version</EM> - Indicates the header version. Must be set to the 
current header version <A HREF="#dvr_common_html_Defines__DVR_DATA_HDR_VER">DVR_DATA_HDR_VER</A>. 
</LI>
<LI>
<EM>hdr_size</EM> - Size of the header in bytes. Must be equal to 
<A HREF="#dvr_common_html_Defines__DVR_DATA_HDR_LEN">DVR_DATA_HDR_LEN</A>. 
</LI>
<LI>
<EM>board_id</EM> - The board identifier. 
</LI>
<LI>
<EM>job_type</EM> - The job type. 
</LI>
<LI>
<EM>job_id</EM> - The ID of the job that generated this buffer, or 
the job that is the recipient of this buffer. 
</LI>
<LI>
<EM>data_type</EM> - Indicates the type of data. Must be one of the 
valid <A HREF="#dvr_common_html_Types__dvr_data_type_enum">dvr_data_type_enum</A> values. 
</LI>
<LI>
<EM>motion_value</EM> - Current motion detect parameter value. 
The value is between 0 and 255. 
</LI>
<LI>
<EM>blind_value</EM> - Current blind detect parameter value. 
The value is between 0 and 255. 
</LI>
<LI>
<EM>night_value</EM> - Current night detect parameter value. 
The value is between 0 and 255. 
</LI>
<LI>
<EM>state_flags</EM> - Set of one-bit state flags about the state of 
the job. 
</LI>
<LI>
<EM>stream_id</EM> - For encoder jobs, this specifies the stream ID 
of the encode stream that generated this data. For all other 
cases, this should be set to 0. 
</LI>
<LI>
<EM>data_size</EM> - Size of the data buffer in bytes. 
</LI>
<LI>
<EM>ts</EM> - Low 32 bits of hardware-generated timestamp associated 
with the data. 
</LI>
<LI>
<EM>ts_high</EM> - High 32 bits of hardware-generated timestamp. 
<STRONG>NOTE</STRONG>: This field is valid only in firmware build versions 3.1.1 
or later. 
</LI>
<LI>
<EM>mval</EM> - Motion detect values for up to four regions of interest. 
mval[0] is the same as <EM>motion_value</EM>. 
</LI>
<LI>
<EM>bval</EM> - Blind detect values for up to four regions of interest. 
mval[0] is the same as <EM>blind_value</EM>. 
</LI>
<LI>
<EM>nval</EM> - Night detect values for up to four regions of interest. 
mval[0] is the same as <EM>night_value</EM>. 
</LI>
<LI>
<EM>active_width</EM> - Active width of video frame buffer. This field is 
valid only for raw and encoded video frames. 
</LI>
<LI>
<EM>padded_width</EM> - Padded width of video frame buffer. This field is 
valid only for raw and encoded video frames. 
</LI>
<LI>
<EM>active_height</EM> - Active height of video frame buffer. This field is 
valid only for raw and encoded video frames. 
</LI>
<LI>
<EM>padded_height</EM> - Padded height of video frame buffer. This field is 
valid only for raw and encoded video frames. 
</LI>
<LI>
<EM>seq_number</EM> - Frame sequence number. This field is valid only 
for raw and encoded video frames. Each board_id/job_id/stream 
combination will have independent sequence numbering. The raw 
and encoded video streams from the same job will have independent 
sequence numbering. The sequence number starts from 1 and is reset 
when the stream is disabled. 
</LI>
<LI>
<EM>frame_number</EM> - Number of frames seen on this channel so far. 
This field is valid only for raw and encoded video frames. The 
frame number and sequence number will be identical when the  
stream is being run at full frame rate and no frames are dropped. 
The counter is reset when the stream is disabled. 
</LI>
<LI>
<EM>drop_count</EM> - Number of frames drop detected by the firmware on the 
current stream. The drop count is reset when the stream is disabled. 
</LI>
<LI>
The following fields are only used in receiving raw YUV frames 
from the host DVR Application: 
</LI>
<UL>
<LI>
<EM>yuv_format</EM> - The current YUV format. 
</LI>
<LI>
<EM>y_data_size</EM> - The size of the Y data in bytes. 
</LI>
<LI>
<EM>u_data_size</EM> - The size of the U data in bytes. 
</LI>
<LI>
<EM>v_data_size</EM> - The size of the V data in bytes. 
</LI>
<LI>
<EM>y_data_offset</EM> -  The offset of Y data of a raw frame   
relative from the start of the header 
</LI>
<LI>
<EM>u_data_offset</EM> -  The offset of U data of a raw frame   
relative from the start of the header 
</LI>
<LI>
<EM>v_data_offset</EM> -  The offset of V data of a raw frame   
relative from the start of the header 
</LI>
</UL>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_sig_host_t"></a>
<PRE class="cdef">
typedef struct dvr_sig_host_struct {
    <A HREF="#dvr_common_html_Types__dvr_signal_type_e">dvr_signal_type_e</A> sig_type:8;
    <A HREF="#dvr_common_html_Types__dvr_job_type_e">dvr_job_type_e</A> job_type:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> job_id;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved1;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> signal_data;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> extra_data;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved3;
} <A HREF="#dvr_common_html_Types__dvr_sig_host_t">dvr_sig_host_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This structure defines the data associated with message 
<A HREF="#dvr_common_html_Types__DVR_SIG_HOST">DVR_SIG_HOST</A> from the board to the host. 
</P>
<UL>
<LI>
<EM>sig_type</EM> - Type of signal, e.g. <A HREF="#dvr_common_html_Types__DVR_SIGNAL_SENSOR_ACTIVATED">DVR_SIGNAL_SENSOR_ACTIVATED</A>. 
</LI>
<LI>
<EM>job_type</EM> - Must be one of <A HREF="#dvr_common_html_Types__DVR_JOB_CAMERA_ENCODE">DVR_JOB_CAMERA_ENCODE</A>, 
<A HREF="#dvr_common_html_Types__DVR_JOB_HOST_ENCODE">DVR_JOB_HOST_ENCODE</A>, or <A HREF="#dvr_common_html_Types__DVR_JOB_HOST_DECODE">DVR_JOB_HOST_DECODE</A>. 
</LI>
<LI>
<EM>job_id</EM> - A unique job ID. 
</LI>
<LI>
<EM>signal_data</EM> - Information associated with the particlar signal 
type. 
</LI>
<UL>
<LI>
For <A HREF="#dvr_common_html_Types__DVR_SIGNAL_SENSOR_ACTIVATED">DVR_SIGNAL_SENSOR_ACTIVATED</A>, it is the sensor status. 
</LI>
<LI>
For <A HREF="#dvr_common_html_Types__DVR_SIGNAL_MOTION_DETECTED">DVR_SIGNAL_MOTION_DETECTED</A>,  it is the motion value. 
</LI>
<LI>
For <A HREF="#dvr_common_html_Types__DVR_SIGNAL_BLIND_DETECTED">DVR_SIGNAL_BLIND_DETECTED</A>,   it is the blind value. 
</LI>
<LI>
For <A HREF="#dvr_common_html_Types__DVR_SIGNAL_NIGHT_DETECTED">DVR_SIGNAL_NIGHT_DETECTED</A>,   it is the night value. 
</LI>
<LI>
For <A HREF="#dvr_common_html_Types__DVR_SIGNAL_VIDEO_LOST">DVR_SIGNAL_VIDEO_LOST</A>,       there is no data. 
</LI>
<LI>
For <A HREF="#dvr_common_html_Types__DVR_SIGNAL_VIDEO_DETECTED">DVR_SIGNAL_VIDEO_DETECTED</A>,   there is no data. 
</LI>
<LI>
For <A HREF="#dvr_common_html_Types__DVR_SIGNAL_RUNTIME_ERROR">DVR_SIGNAL_RUNTIME_ERROR</A>,    it is the error code. 
</LI>
<LI>
For <A HREF="#dvr_common_html_Types__DVR_SIGNAL_FATAL_ERROR">DVR_SIGNAL_FATAL_ERROR</A>,      it is the error code. 
</LI>
<LI>
For <A HREF="#dvr_common_html_Types__DVR_SIGNAL_HEARTBEAT">DVR_SIGNAL_HEARTBEAT</A>,        it is the board id. 
</LI>
<LI>
For <A HREF="#dvr_common_html_Types__DVR_SIGNAL_WATCHDOG_EXPIRED">DVR_SIGNAL_WATCHDOG_EXPIRED</A>, there is no data. 
</LI>
</UL>
<LI>
<EM>extra_data</EM> - Extra information associated with the signal, if any. 
</LI>
<UL>
<LI>
For <A HREF="#dvr_common_html_Types__DVR_SIGNAL_RUNTIME_ERROR">DVR_SIGNAL_RUNTIME_ERROR</A>,    it is the extended error code. 
</LI>
<LI>
For <A HREF="#dvr_common_html_Types__DVR_SIGNAL_FATAL_ERROR">DVR_SIGNAL_FATAL_ERROR</A>,      it is the extended error code. 
</LI>
</UL>
</UL>
<P>
<STRONG>NOTE</STRONG>: For messages such as <A HREF="#dvr_common_html_Types__DVR_SIGNAL_WATCHDOG_EXPIRED">DVR_SIGNAL_WATCHDOG_EXPIRED</A>, job_type 
and job_id are not meaningful, and are always zero. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_uart_t"></a>
<PRE class="cdef">
typedef struct dvr_uart_struct {
    <A HREF="#dvr_common_html_Types__dvr_status_e">dvr_status_e</A> status:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> cmd;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> reserved1;
    union {
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> baud_rate;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> data_bits;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> stop_bits;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> parity_enable;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> parity_even;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved2;
        } config;
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> count;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> data[11];
        } output;
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> count;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> data[11];
        } input;
    } u1;
} <A HREF="#dvr_common_html_Types__dvr_uart_t">dvr_uart_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This structure is used for <A HREF="#dvr_common_html_Types__DVR_GET_UART">DVR_GET_UART</A>, <A HREF="#dvr_common_html_Types__DVR_SET_UART">DVR_SET_UART</A> 
and <A HREF="#dvr_common_html_Types__DVR_REP_UART">DVR_REP_UART</A> messages. 
</P>
<P>
Common Fields: 
</P>
<UL>
<LI>
<EM>status</EM> - Status of the reply. 
</LI>
<LI>
<EM>cmd</EM> - Command code, either <STRONG>DVR_UART_CONFIG</STRONG> or <STRONG>DVR_UART_OUTPUT</STRONG>. 
Only valid for <A HREF="#dvr_common_html_Types__DVR_SET_UART">DVR_SET_UART</A> messages. 
</LI>
</UL>
<P>
Config Command Fields: 
</P>
<UL>
<LI>
<EM>baud_rate</EM> - The output baud rate. Must be between 50 and 115200. 
</LI>
<LI>
<EM>data_bits</EM> - Number of data bits. Valid values are 5-8. 
</LI>
<LI>
<EM>stop_bits</EM> - Number of stop bits. Valid values are 1 and 2. 
</LI>
<LI>
<EM>parity_enable</EM> - If this field is set to zero, parity is disabled. 
If set to a nonzero value, parity is enabled. 
</LI>
<LI>
<EM>parity_even</EM> - If this field is set to zero, odd parity is used. 
If set to a nonzero value, even parity is used. This field is 
ignored if parity is disabled. 
</LI>
</UL>
<P>
Output Command Fields: 
</P>
<UL>
<LI>
<EM>count</EM> - Number of bytes to transmit. Must be between 1 and 11. 
</LI>
<LI>
<EM>data</EM> - The data bytes to transmit. The number of valid bytes in 
the array is determined by the <EM>count</EM> field. 
</LI>
</UL>
<P>
Input Command Fields: 
</P>
<UL>
<LI>
<EM>count</EM> - For <A HREF="#dvr_common_html_Types__DVR_GET_UART">DVR_GET_UART</A>, specifies the maximum number of bytes 
to read. For <A HREF="#dvr_common_html_Types__DVR_REP_UART">DVR_REP_UART</A>, specifies the actual number of bytes 
read, which can be less than the number requested. 
</LI>
<LI>
<EM>data</EM> - For <A HREF="#dvr_common_html_Types__DVR_REP_UART">DVR_REP_UART</A>, contains the bytes read, if any. 
The number of valid bytes is determined by the <EM>count</EM> field. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_term_enum"></a>
<PRE class="cdef">
enum <A HREF="#dvr_common_html_Types__dvr_term_enum">dvr_term_enum</A> {
    <A name="dvr_common_html_Types__DVR_TERM_75OHM">DVR_TERM_75OHM</A>,
    <A name="dvr_common_html_Types__DVR_TERM_HIGH_IMPEDANCE">DVR_TERM_HIGH_IMPEDANCE</A>
} ; 
</PRE>
<DIV CLASS="descr">
<P>
Enumerated type describing various camera input impedance  
termination used with <STRONG>DVR_IOCTL_CODE_CAMERA_SETTINGS</STRONG> for 
termination field. 
</P>
<UL>
<LI>
<A HREF="#dvr_common_html_Types__DVR_TERM_75OHM">DVR_TERM_75OHM</A> - 75 ohm impedance termination. 
</LI>
<LI>
<A HREF="#dvr_common_html_Types__DVR_TERM_HIGH_IMPEDANCE">DVR_TERM_HIGH_IMPEDANCE</A> - High impedance termination. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_led_type_enum"></a>
<PRE class="cdef">
enum <A HREF="#dvr_common_html_Types__dvr_led_type_enum">dvr_led_type_enum</A> {
    <A name="dvr_common_html_Types__DVR_LED_TYPE_RECORD">DVR_LED_TYPE_RECORD</A>,
    <A name="dvr_common_html_Types__DVR_LED_TYPE_ALARM">DVR_LED_TYPE_ALARM</A>
} ; 
</PRE>
<DIV CLASS="descr">
<P>
Enumerated type describing various LED types. 
</P>
<UL>
<LI>
<A HREF="#dvr_common_html_Types__DVR_LED_TYPE_RECORD">DVR_LED_TYPE_RECORD</A> - A group of LEDs indicating the current state of 
recording. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_LED_TYPE_ALARM">SDVR_LED_TYPE_ALARM</A> - A group of LEDs indicating the current state 
of the alarms. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_ioctl_t"></a>
<PRE class="cdef">
typedef struct dvr_ioctl_struct {
    <A HREF="#dvr_common_html_Types__dvr_status_e">dvr_status_e</A> status:8;
    <A HREF="#dvr_common_html_Types__dvr_job_type_e">dvr_job_type_e</A> job_type:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> job_id;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> ioctl_code;
    union {
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> flags;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> reserved2;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> hue;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> sat;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> brt;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> cont;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> sharp;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved3;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> reserved4;
        } img_ctrl;
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> device_id;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reg_num;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> val;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved2;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved3;
        } reg;
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> port;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> reserved2;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved3;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved4;
        } chan;
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> frequency;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved1;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> reserved2;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved3;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved4;
        } motion;
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> value;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved1;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> reserved2;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved3;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved4;
        } gain_mode;
        struct {
            <A HREF="#dvr_common_html_Types__dvr_term_e">dvr_term_e</A> value:8;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved1;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> reserved2;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved3;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved4;
        } termination;
        struct {
            <A HREF="#dvr_common_html_Types__dvr_led_type_e">dvr_led_type_e</A> type:8;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> number;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> enable;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved1;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved2;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved3;
        } led;
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> actions;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved1;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved2;
        } vpp_ctrl;
        struct {
            <A HREF="#dvr_common_html_Types__dvr_rawv_format_e">dvr_rawv_format_e</A> format:8;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved1;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> reserved2;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved3;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved4;
        } rawv_format;
    } u1;
} <A HREF="#dvr_common_html_Types__dvr_ioctl_t">dvr_ioctl_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This structure is used by the <A HREF="#dvr_common_html_Types__DVR_GET_IOCTL">DVR_GET_IOCTL</A>, <A HREF="#dvr_common_html_Types__DVR_SET_IOCTL">DVR_SET_IOCTL</A>, 
and <A HREF="#dvr_common_html_Types__DVR_REP_IOCTL">DVR_REP_IOCTL</A> messages. 
</P>
<P>
Common Fields: 
</P>
<UL>
<LI>
<EM>status</EM> - Status of the reply. 
</LI>
<LI>
<EM>job_type</EM> - Must be <A HREF="#dvr_common_html_Types__DVR_JOB_CAMERA_ENCODE">DVR_JOB_CAMERA_ENCODE</A>, except for per-board 
ioctl commands. For these, the field is ignored. 
</LI>
<LI>
<EM>job_id</EM> - A unique job ID. Ignored for per-board ioctl commands. 
</LI>
<LI>
<EM>ioctl_code</EM> - The IOCTL command code. 
</LI>
</UL>
<P>
Image Control Fields (used with <A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_IMG_CONTROL">DVR_IOCTL_CODE_IMG_CONTROL</A>): 
</P>
<UL>
<LI>
<EM>flags</EM> - Bit field specifying which of the following fields is 
valid. 
</LI>
<LI>
<EM>hue</EM> - Value to set for hue control (for set), current value of 
hue control (for get). 
</LI>
<LI>
<EM>sat</EM> - Value to set for saturation control (for set), current 
value of saturation control (for get). 
</LI>
<LI>
<EM>brt</EM> - Value to set for brightness control (for set), current 
value of brightness control (for get). 
</LI>
<LI>
<EM>cont</EM> - Value to set for contrast control (for set), current 
value of contrast control (for get). 
</LI>
<LI>
<EM>sharp</EM> - Value to set for sharpness control (for set), current 
value of sharpness control (for get). 
</LI>
</UL>
<P>
Register R/W Fields (used with <A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_DECODER_REGS">DVR_IOCTL_CODE_DECODER_REGS</A>): 
</P>
<UL>
<LI>
<EM>device_id</EM> - Device ID of the decoder to access. 
</LI>
<LI>
<EM>reg_num</EM> - Register number to read or write. 
</LI>
<LI>
<EM>val</EM> - Value to write, or value read back. 
</LI>
</UL>
<P>
Channel control fields (used with <A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_OPEN_CHAN">DVR_IOCTL_CODE_OPEN_CHAN</A> etc.): 
This port ID is per board not per channel. 
</P>
<UL>
<LI>
<EM>port</EM> - The SCT port number to use for the channel. 
</LI>
</UL>
<P>
Motion control fields (used with <A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_MOTION_FRAME_FREQ">DVR_IOCTL_CODE_MOTION_FRAME_FREQ</A>): 
</P>
<UL>
<LI>
<EM>frequency</EM> - How often to send the motion value frames. 
0 means never, 1 means every frame, and so on. Note that 
even if this is set to zero, a motion value frame will be 
sent every time the motion alarm threshold is exceeded. 
</LI>
</UL>
<P>
Gain mode field (used with <A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_GAIN_MODE">DVR_IOCTL_CODE_GAIN_MODE</A>): 
</P>
<UL>
<LI>
<EM>value</EM> - Gain setting value.  
This value will be passed through as-is to the hardware. 
</LI>
</UL>
<P>
Video preprocessing control field (used with <A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_VPP_CONTROL">DVR_IOCTL_CODE_VPP_CONTROL</A>): 
</P>
<UL>
<LI>
<EM>actions</EM> - Bitfield of VPP actions to control preprocessing 
behavior. Set the corresponding action flags to enable the  
actions, clear the flags to disable them. 
</LI>
</UL>
<P>
Termination value field (used with <A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_TERMINATION">DVR_IOCTL_CODE_TERMINATION</A>): 
</P>
<UL>
<LI>
<EM>value</EM> - Enumerated constant defining the termination value. 
</LI>
</UL>
<P>
LED enable status field (used with <A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_LED">DVR_IOCTL_CODE_LED</A>): 
</P>
<UL>
<LI>
<EM>type</EM> - The type of LED to set its enable status. 
</LI>
<LI>
<EM>number</EM> - A zero based LED number within the LED type group. 
</LI>
<LI>
<EM>enable</EM> - Set to <A HREF="#sdvr_sdk_html_Defines__true">true</A> to turn the LED on, <A HREF="#sdvr_sdk_html_Defines__false">false</A> to turn it off. 
</LI>
</UL>
<P>
Raw video format field (used with <A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_RAWV_FORMAT">DVR_IOCTL_CODE_RAWV_FORMAT</A>): 
</P>
<UL>
<LI>
<EM>format</EM> - The raw video output format. Must be one of the 
<A HREF="#dvr_common_html_Types__dvr_rawv_format_e">dvr_rawv_format_e</A> values. The default format at startup is 
<A HREF="#dvr_common_html_Types__DVR_RAWV_FORMAT_YUV_4_2_0">DVR_RAWV_FORMAT_YUV_4_2_0</A>. 
</LI>
</UL>
<P>
All reserved fields must be set to zero. 
</P>
<P>
<STRONG>NOTE</STRONG>: Default values for image control parameters are dependent 
on the type of hardware used. To obtain the defaults for a specific 
board, use the <A HREF="#dvr_common_html_Types__DVR_GET_IOCTL">DVR_GET_IOCTL</A> command to read the parameters before 
changing any of them. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_videoout_t"></a>
<PRE class="cdef">
typedef struct dvr_videoout_struct {
    <A HREF="#dvr_common_html_Types__dvr_status_e">dvr_status_e</A> status:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> opcode;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> smo_port_num;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved;
    union {
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> sct_port_id;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> video_format;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> reserved1;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved2;
        } start;
    } u1;
} <A HREF="#dvr_common_html_Types__dvr_videoout_t">dvr_videoout_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This structure is used by the <A HREF="#dvr_common_html_Types__DVR_SET_VIDEO_OUTPUT">DVR_SET_VIDEO_OUTPUT</A> 
and <A HREF="#dvr_common_html_Types__DVR_REP_VIDEO_OUTPUT">DVR_REP_VIDEO_OUTPUT</A> messages. 
</P>
<P>
Common Fields: 
</P>
<UL>
<LI>
<EM>status</EM> - Status of the reply. 
</LI>
<LI>
<EM>opcode</EM> - The VOUT command code. 
</LI>
<LI>
<EM>smo_port_num</EM> - The zero based SMO port number 
</LI>
</UL>
<P>
Fields (used with <A HREF="#dvr_common_html_Defines__DVR_VOUT_OPCODE_START">DVR_VOUT_OPCODE_START</A>): 
</P>
<UL>
<LI>
<EM>sct_port_id</EM> - The SCT port ID that should be used by the firmware 
to receive YUV frames to be displayed on the given SMO.  
This field is assumed to be set by the 
host only when the opcode is <A HREF="#dvr_common_html_Defines__DVR_VOUT_OPCODE_START">DVR_VOUT_OPCODE_START</A>. 
</LI>
<LI>
<EM>video_format</EM> - The raw video format that is going to be  
received from the host DVR Application. 
see <STRONG>dvr_rawv_formats_e</STRONG>. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_smo_capabilities_e"></a>
<PRE class="cdef">
enum <A HREF="#dvr_common_html_Types__dvr_smo_capabilities_e">dvr_smo_capabilities_e</A> {
    <A name="dvr_common_html_Types__DVR_SMO_CAP_OUTPUT">DVR_SMO_CAP_OUTPUT</A> = 1,
    <A name="dvr_common_html_Types__DVR_SMO_CAP_OSD">DVR_SMO_CAP_OSD</A> = 2,
    <A name="dvr_common_html_Types__DVR_SMO_CAP_ALPHA_BLENDING">DVR_SMO_CAP_ALPHA_BLENDING</A> = 4,
    <A name="dvr_common_html_Types__DVR_SMO_CAP_TILING">DVR_SMO_CAP_TILING</A> = 8,
    <A name="dvr_common_html_Types__DVR_SMO_CAP_ANALOG">DVR_SMO_CAP_ANALOG</A> = 16
} ; 
</PRE>
<DIV CLASS="descr">
<P>
The following enum describes various supported SMO capabilities. 
Each feature is supported by the SMO port if the corresponding bit is set. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_SMO_CAP_OUTPUT">DVR_SMO_CAP_OUTPUT</A> - Supports outputing of DVR Host Application  
generated raw video. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_SMO_CAP_OSD">DVR_SMO_CAP_OSD</A> - Supports OSD text that is displayed only on this SMO port. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_SMO_CAP_ALPHA_BLENDING">DVR_SMO_CAP_ALPHA_BLENDING</A> - Supports alpha blending of OSD. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_SMO_CAP_TILING">DVR_SMO_CAP_TILING</A> - Supports tiling of video, streaming from different 
Cameras or host output on this SMO display. 
</P>
<P>
<A HREF="#dvr_common_html_Types__DVR_SMO_CAP_ANALOG">DVR_SMO_CAP_ANALOG</A> - Supports one analog camera input. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Types__dvr_smo_attrib_t"></a>
<PRE class="cdef">
typedef struct dvr_smo_attrib_struct {
    <A HREF="#dvr_common_html_Types__dvr_status_e">dvr_status_e</A> status:8;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> smo_port_num;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> video_formats;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> width;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> height;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> cap_flags;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> reserved1;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved2;
} <A HREF="#dvr_common_html_Types__dvr_smo_attrib_t">dvr_smo_attrib_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This structure is associated with the messages 
<A HREF="#dvr_common_html_Types__DVR_GET_SMO_ATTRIB">DVR_GET_SMO_ATTRIB</A> and <A HREF="#dvr_common_html_Types__DVR_REP_SMO_ATTRIB">DVR_REP_SMO_ATTRIB</A>.   
</P>
<UL>
<LI>
<EM>status</EM> - Status of the reply. 
</LI>
<LI>
<EM>smo_port_num</EM> - The SMO port number to get its capablities. 
</LI>
<LI>
<EM>video_formats</EM> - A bit map to indicate supported raw video formats. 
see <STRONG>dvr_rawv_formats_e</STRONG>. 
</LI>
<LI>
<EM>width</EM> - The width of the SMO display. 
</LI>
<LI>
<EM>height</EM> - The number of lines of the SMO display 
</LI>
<LI>
<EM>cap_flags</EM> - A bit map specifing all the capabilities of the  
requested SMO port. See <A HREF="#dvr_common_html_Types__dvr_smo_capabilities_e">dvr_smo_capabilities_e</A>. 
</LI>
</UL>
</DIV>

</DIV>

<!-- SEC_TYPES_CLOSE -->

<!-- SEC_DEFINES_START -->

<a name="dvr_common_html_Top__Defines"></a>
<H2>2.10 &nbsp; Defines</H2>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Defines__DDR_DIAG_WRITEREAD_FAIL"></a>
<a name="dvr_common_html_Defines__DDR_DIAG_ADDRLINES_FAIL"></a>
<a name="dvr_common_html_Defines__DDR_DIAG_BITFLIP_FAIL"></a>
<a name="dvr_common_html_Defines__DDR_DIAG_DMA_FAIL"></a>
<a name="dvr_common_html_Defines__DDR_DIAG_READ_DMA_FAIL"></a>
<PRE class="cdef">
#define <A HREF="#dvr_common_html_Defines__DDR_DIAG_WRITEREAD_FAIL">DDR_DIAG_WRITEREAD_FAIL</A>
#define <A HREF="#dvr_common_html_Defines__DDR_DIAG_ADDRLINES_FAIL">DDR_DIAG_ADDRLINES_FAIL</A>
#define <A HREF="#dvr_common_html_Defines__DDR_DIAG_BITFLIP_FAIL">DDR_DIAG_BITFLIP_FAIL</A>
#define <A HREF="#dvr_common_html_Defines__DDR_DIAG_DMA_FAIL">DDR_DIAG_DMA_FAIL</A>
#define <A HREF="#dvr_common_html_Defines__DDR_DIAG_READ_DMA_FAIL">DDR_DIAG_READ_DMA_FAIL</A>
</PRE>
<DIV CLASS="descr">
<P>
Boot-loader DDR diagnostic test errors: 
</P>
<UL>
<LI>
<EM>DDR_DIAG_WRITEREAD_FAIL</EM> - DDR write/read test failed 
</LI>
<LI>
<EM>DDR_DIAG_ADDRLINES_FAIL</EM> - DDR address lines test failed 
</LI>
<LI>
<EM>DDR_DIAG_BITFLIP_FAIL</EM> - DDR bit-flip test failed 
</LI>
<LI>
<EM>DDR_DIAG_DMA_FAIL</EM> - DDR DMA test failed 
</LI>
<LI>
<EM>DDR_DIAG_READ_DMA_FAIL</EM> - DDR read/DMA test failed 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Defines__PLL_TEST_MHZ_ERR"></a>
<a name="dvr_common_html_Defines__PLL_TEST_SYS_PLL_ERR"></a>
<a name="dvr_common_html_Defines__PLL_TEST_IO_PLL_ERR"></a>
<a name="dvr_common_html_Defines__PLL_TEST_AIM_PLL_ERR"></a>
<a name="dvr_common_html_Defines__PLL_TEST_DP0_PLL_ERR"></a>
<a name="dvr_common_html_Defines__PLL_TEST_DP2_PLL_ERR"></a>
<a name="dvr_common_html_Defines__PLL_TEST_DDR_DLL_ERR"></a>
<PRE class="cdef">
#define <A HREF="#dvr_common_html_Defines__PLL_TEST_MHZ_ERR">PLL_TEST_MHZ_ERR</A>
#define <A HREF="#dvr_common_html_Defines__PLL_TEST_SYS_PLL_ERR">PLL_TEST_SYS_PLL_ERR</A>
#define <A HREF="#dvr_common_html_Defines__PLL_TEST_IO_PLL_ERR">PLL_TEST_IO_PLL_ERR</A>
#define <A HREF="#dvr_common_html_Defines__PLL_TEST_AIM_PLL_ERR">PLL_TEST_AIM_PLL_ERR</A>
#define <A HREF="#dvr_common_html_Defines__PLL_TEST_DP0_PLL_ERR">PLL_TEST_DP0_PLL_ERR</A>
#define <A HREF="#dvr_common_html_Defines__PLL_TEST_DP2_PLL_ERR">PLL_TEST_DP2_PLL_ERR</A>
#define <A HREF="#dvr_common_html_Defines__PLL_TEST_DDR_DLL_ERR">PLL_TEST_DDR_DLL_ERR</A>
</PRE>
<DIV CLASS="descr">
<P>
PLL diagnostic test errors: 
</P>
<UL>
<LI>
<EM>PLL_TEST_MHZ_ERR</EM> - Processor speed test failed 
</LI>
<LI>
<EM>PLL_TEST_SYS_PLL_ERR</EM> - PLL_SYS test failed 
</LI>
<LI>
<EM>PLL_TEST_IO_PLL_ERR</EM> - PLL_IO test failed 
</LI>
<LI>
<EM>PLL_TEST_AIM_PLL_ERR</EM> - PLL_AIM test failed 
</LI>
<LI>
<EM>PLL_TEST_DP0_PLL_ERR</EM> - PLL_DP0 test failed 
</LI>
<LI>
<EM>PLL_TEST_DP2_PLL_ERR</EM> - PLL_DP2 test failed 
</LI>
<LI>
<EM>PLL_TEST_DDR_DLL_ERR</EM> - DLL_DDR test failed 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Defines__SPI_TEST_READ_ERR"></a>
<a name="dvr_common_html_Defines__SPI_TEST_ERASE_ERR"></a>
<a name="dvr_common_html_Defines__SPI_TEST_PROG_ERR"></a>
<a name="dvr_common_html_Defines__SPI_TEST_UNLOCK_ERR"></a>
<a name="dvr_common_html_Defines__SPI_TEST_COMPARE_ERR"></a>
<a name="dvr_common_html_Defines__SPI_TEST_MAINT_ERR"></a>
<a name="dvr_common_html_Defines__SPI_TEST_MISC_ERR"></a>
<PRE class="cdef">
#define <A HREF="#dvr_common_html_Defines__SPI_TEST_READ_ERR">SPI_TEST_READ_ERR</A>
#define <A HREF="#dvr_common_html_Defines__SPI_TEST_ERASE_ERR">SPI_TEST_ERASE_ERR</A>
#define <A HREF="#dvr_common_html_Defines__SPI_TEST_PROG_ERR">SPI_TEST_PROG_ERR</A>
#define <A HREF="#dvr_common_html_Defines__SPI_TEST_UNLOCK_ERR">SPI_TEST_UNLOCK_ERR</A>
#define <A HREF="#dvr_common_html_Defines__SPI_TEST_COMPARE_ERR">SPI_TEST_COMPARE_ERR</A>
#define <A HREF="#dvr_common_html_Defines__SPI_TEST_MAINT_ERR">SPI_TEST_MAINT_ERR</A>
#define <A HREF="#dvr_common_html_Defines__SPI_TEST_MISC_ERR">SPI_TEST_MISC_ERR</A>
</PRE>
<DIV CLASS="descr">
<P>
SPI flash diagnostic test errors: 
</P>
<UL>
<LI>
<EM>SPI_TEST_READ_ERR</EM> - Flash read error 
</LI>
<LI>
<EM>SPI_TEST_ERASE_ERR</EM> - Flash erase error 
</LI>
<LI>
<EM>SPI_TEST_PROG_ERR</EM> - Flash program error 
</LI>
<LI>
<EM>SPI_TEST_UNLOCK_ERR</EM> - Flash unlock error 
</LI>
<LI>
<EM>SPI_TEST_COMPARE_ERR</EM> - Flash data miscompare error 
</LI>
<LI>
<EM>SPI_TEST_MAINT_ERR</EM> - Flash maintenance command error 
</LI>
<LI>
<EM>SPI_TEST_MISC_ERR</EM> - Miscellaneous flash error 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Defines__TWI_EEPROM_TEST_READ_ERR"></a>
<a name="dvr_common_html_Defines__TWI_EEPROM_TEST_WRITE_ERR"></a>
<a name="dvr_common_html_Defines__TWI_EEPROM_TEST_INIT_ERR"></a>
<a name="dvr_common_html_Defines__TWI_EEPROM_TEST_COMPARE_ERR"></a>
<a name="dvr_common_html_Defines__TWI_EEPROM_TEST_WP_COMPARE_ERR"></a>
<PRE class="cdef">
#define <A HREF="#dvr_common_html_Defines__TWI_EEPROM_TEST_READ_ERR">TWI_EEPROM_TEST_READ_ERR</A>
#define <A HREF="#dvr_common_html_Defines__TWI_EEPROM_TEST_WRITE_ERR">TWI_EEPROM_TEST_WRITE_ERR</A>
#define <A HREF="#dvr_common_html_Defines__TWI_EEPROM_TEST_INIT_ERR">TWI_EEPROM_TEST_INIT_ERR</A>
#define <A HREF="#dvr_common_html_Defines__TWI_EEPROM_TEST_COMPARE_ERR">TWI_EEPROM_TEST_COMPARE_ERR</A>
#define <A HREF="#dvr_common_html_Defines__TWI_EEPROM_TEST_WP_COMPARE_ERR">TWI_EEPROM_TEST_WP_COMPARE_ERR</A>
</PRE>
<DIV CLASS="descr">
<P>
TWI EEPROM diagnostic test errors: 
</P>
<UL>
<LI>
<EM>TWI_EEPROM_TEST_READ_ERR</EM> - TWI EEPROM read error 
</LI>
<LI>
<EM>TWI_EEPROM_TEST_WRITE_ERR</EM> - TWI EEPROM write error 
</LI>
<LI>
<EM>TWI_EEPROM_TEST_INIT_ERR</EM> - TWI EEPROM initialization error 
</LI>
<LI>
<EM>TWI_EEPROM_TEST_COMPARE_ERR</EM> - TWI EEPROM data miscompare error 
</LI>
<LI>
<EM>TWI_EEPROM_TEST_WP_COMPARE_ERR</EM> - TWI EEPROM write-protect error 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Defines__EPSON_REG_TEST_INIT_ERR"></a>
<a name="dvr_common_html_Defines__EPSON_REG_TEST_WALKING_ERR"></a>
<PRE class="cdef">
#define <A HREF="#dvr_common_html_Defines__EPSON_REG_TEST_INIT_ERR">EPSON_REG_TEST_INIT_ERR</A>
#define <A HREF="#dvr_common_html_Defines__EPSON_REG_TEST_WALKING_ERR">EPSON_REG_TEST_WALKING_ERR</A>
</PRE>
<DIV CLASS="descr">
<P>
Epson diagnostic test errors: 
</P>
<UL>
<LI>
<EM>EPSON_REG_TEST_INIT_ERR</EM> - Epson test initialization error 
</LI>
<LI>
<EM>EPSON_REG_TEST_WALKING_ERR</EM> - Epson register bit-walk error 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Defines__DECODER_AUDIO_TEST_INIT_ERR"></a>
<a name="dvr_common_html_Defines__DECODER_AUDIO_TEST_NO_AUDIO_ERR"></a>
<a name="dvr_common_html_Defines__TW2815_REG_TEST_ERR"></a>
<a name="dvr_common_html_Defines__TW2864_REG_TEST_ERR"></a>
<a name="dvr_common_html_Defines__DECODER_VIDEO_TEST_INIT_ERR"></a>
<a name="dvr_common_html_Defines__DECODER_VIDEO_TEST_NO_VIDEO_ERR"></a>
<a name="dvr_common_html_Defines__DECODER_VIDEO_TEST_TIMEOUT"></a>
<a name="dvr_common_html_Defines__DECODER_VIDDET_TEST_INIT_ERR"></a>
<a name="dvr_common_html_Defines__DECODER_VIDDET_TEST_UNKNOWN_CHIP"></a>
<a name="dvr_common_html_Defines__DECODER_VIDDET_TEST_NO_INPUT_ERR"></a>
<a name="dvr_common_html_Defines__DECODER_VIDDET_TEST_CONFLICT_ERR"></a>
<a name="dvr_common_html_Defines__DECODER_VIDDET_TEST_NO_SYNC_ERR"></a>
<a name="dvr_common_html_Defines__DECODER_AUDDET_TEST_NO_SYNC_ERR"></a>
<a name="dvr_common_html_Defines__DECODER_UNIQUE_VIDEO_TEST_ERR"></a>
<a name="dvr_common_html_Defines__NVP1104_REG_TEST_ERR"></a>
<a name="dvr_common_html_Defines__NVP1114_REG_TEST_ERR"></a>
<a name="dvr_common_html_Defines__DECODER_AUDIO_TEST_TIMEOUT"></a>
<a name="dvr_common_html_Defines__DECODER_UNIQUE_AUDIO_TEST_ERR"></a>
<PRE class="cdef">
#define <A HREF="#dvr_common_html_Defines__DECODER_AUDIO_TEST_INIT_ERR">DECODER_AUDIO_TEST_INIT_ERR</A>
#define <A HREF="#dvr_common_html_Defines__DECODER_AUDIO_TEST_NO_AUDIO_ERR">DECODER_AUDIO_TEST_NO_AUDIO_ERR</A>
#define <A HREF="#dvr_common_html_Defines__TW2815_REG_TEST_ERR">TW2815_REG_TEST_ERR</A>
#define <A HREF="#dvr_common_html_Defines__TW2864_REG_TEST_ERR">TW2864_REG_TEST_ERR</A>
#define <A HREF="#dvr_common_html_Defines__DECODER_VIDEO_TEST_INIT_ERR">DECODER_VIDEO_TEST_INIT_ERR</A>
#define <A HREF="#dvr_common_html_Defines__DECODER_VIDEO_TEST_NO_VIDEO_ERR">DECODER_VIDEO_TEST_NO_VIDEO_ERR</A>
#define <A HREF="#dvr_common_html_Defines__DECODER_VIDEO_TEST_TIMEOUT">DECODER_VIDEO_TEST_TIMEOUT</A>
#define <A HREF="#dvr_common_html_Defines__DECODER_VIDDET_TEST_INIT_ERR">DECODER_VIDDET_TEST_INIT_ERR</A>
#define <A HREF="#dvr_common_html_Defines__DECODER_VIDDET_TEST_UNKNOWN_CHIP">DECODER_VIDDET_TEST_UNKNOWN_CHIP</A>
#define <A HREF="#dvr_common_html_Defines__DECODER_VIDDET_TEST_NO_INPUT_ERR">DECODER_VIDDET_TEST_NO_INPUT_ERR</A>
#define <A HREF="#dvr_common_html_Defines__DECODER_VIDDET_TEST_CONFLICT_ERR">DECODER_VIDDET_TEST_CONFLICT_ERR</A>
#define <A HREF="#dvr_common_html_Defines__DECODER_VIDDET_TEST_NO_SYNC_ERR">DECODER_VIDDET_TEST_NO_SYNC_ERR</A>
#define <A HREF="#dvr_common_html_Defines__DECODER_AUDDET_TEST_NO_SYNC_ERR">DECODER_AUDDET_TEST_NO_SYNC_ERR</A>
#define <A HREF="#dvr_common_html_Defines__DECODER_UNIQUE_VIDEO_TEST_ERR">DECODER_UNIQUE_VIDEO_TEST_ERR</A>
#define <A HREF="#dvr_common_html_Defines__NVP1104_REG_TEST_ERR">NVP1104_REG_TEST_ERR</A>
#define <A HREF="#dvr_common_html_Defines__NVP1114_REG_TEST_ERR">NVP1114_REG_TEST_ERR</A>
#define <A HREF="#dvr_common_html_Defines__DECODER_AUDIO_TEST_TIMEOUT">DECODER_AUDIO_TEST_TIMEOUT</A>
#define <A HREF="#dvr_common_html_Defines__DECODER_UNIQUE_AUDIO_TEST_ERR">DECODER_UNIQUE_AUDIO_TEST_ERR</A>
</PRE>
<DIV CLASS="descr">
<P>
Decoder diagnostic test errors: 
</P>
<UL>
<LI>
<EM>DECODER_AUDIO_TEST_INIT_ERR</EM> - Decoder audio test init error 
</LI>
<LI>
<EM>DECODER_AUDIO_TEST_NO_AUDIO_ERR</EM> - Decoder audio not received error 
</LI>
<LI>
<EM>TW2815_REG_TEST_ERR</EM> - Decoder register test error 
</LI>
<LI>
<EM>TW2864_REG_TEST_ERR</EM> - Decoder register test error 
</LI>
<LI>
<EM>DECODER_VIDEO_TEST_INIT_ERR</EM> - Decoder video test init error 
</LI>
<LI>
<EM>DECODER_VIDEO_TEST_NO_VIDEO_ERR</EM> - Decoder video not received error 
</LI>
<LI>
<EM>DECODER_VIDEO_TEST_TIMEOUT</EM> - Decoder video test timeout error 
</LI>
<LI>
<EM>DECODER_VIDDET_TEST_INIT_ERR</EM> - Decoder A/V detection: init error 
</LI>
<LI>
<EM>DECODER_VIDDET_TEST_UNKNOWN_CHIP</EM> - Decoder A/V detection: unknown  
chip error 
</LI>
<LI>
<EM>DECODER_VIDDET_TEST_NO_INPUT_ERR</EM> - Decoder A/V detection: input  
signal not detected error 
</LI>
<LI>
<EM>DECODER_VIDDET_TEST_CONFLICT_ERR</EM> - Decoder A/V detection: video 
standard conflict error 
</LI>
<LI>
<EM>DECODER_VIDDET_TEST_NO_SYNC_ERR</EM> - Decoder A/V detection: no video 
sync error 
</LI>
<LI>
<EM>DECODER_AUDDET_TEST_NO_SYNC_ERR</EM> - Decoder A/V detection: no audio 
sync error 
</LI>
<LI>
<EM>DECODER_UNIQUE_VIDEO_TEST_ERR</EM> - Video inputs are not unique 
</LI>
<LI>
<EM>NVP1104_REG_TEST_ERR</EM> - Nextchip register test error 
</LI>
<LI>
<EM>NVP1114_REG_TEST_ERR</EM> - Nextchip register test error 
</LI>
<LI>
<EM>DECODER_AUDIO_TEST_TIMEOUT</EM> - Decoder audio test timeout error 
</LI>
<LI>
<EM>DECODER_UNIQUE_AUDIO_TEST_ERR</EM> - Audio inputs are not unique 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Defines__PCIE_EYEMASK_TEST_NO_CBB"></a>
<a name="dvr_common_html_Defines__PCIE_EYEMASK_TEST_ERR"></a>
<a name="dvr_common_html_Defines__PCIE_EYEMASK_TEST_TIMEOUT"></a>
<PRE class="cdef">
#define <A HREF="#dvr_common_html_Defines__PCIE_EYEMASK_TEST_NO_CBB">PCIE_EYEMASK_TEST_NO_CBB</A>
#define <A HREF="#dvr_common_html_Defines__PCIE_EYEMASK_TEST_ERR">PCIE_EYEMASK_TEST_ERR</A>
#define <A HREF="#dvr_common_html_Defines__PCIE_EYEMASK_TEST_TIMEOUT">PCIE_EYEMASK_TEST_TIMEOUT</A>
</PRE>
<DIV CLASS="descr">
<P>
PCIe diagnostic test errors: 
</P>
<UL>
<LI>
<EM>PCIE_EYEMASK_TEST_NO_CBB</EM> - PCIe did not detect the CBB test board. 
</LI>
<LI>
<EM>PCIE_EYEMASK_TEST_ERR</EM> - PCIe eyemask test failure. 
</LI>
<LI>
<EM>PCIE_EYEMASK_TEST_TIMEOUT</EM> - PCIe eyemask test timeout. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Defines__AIM_TEST_ERRORS"></a>
<PRE class="cdef">
#define <A HREF="#dvr_common_html_Defines__AIM_TEST_ERRORS">AIM_TEST_ERRORS</A>
</PRE>
<DIV CLASS="descr">
<P>
AIM diagnostic test errors: 
</P>
<UL>
<LI>
<EM>AIM_TEST_ERRORS</EM> - AIM errors were detected during the test. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Defines__ASWITCH_ENABLE_ERR"></a>
<a name="dvr_common_html_Defines__SMO_ENABLE_ERR"></a>
<a name="dvr_common_html_Defines__VOUT_ENABLE_ERR"></a>
<PRE class="cdef">
#define <A HREF="#dvr_common_html_Defines__ASWITCH_ENABLE_ERR">ASWITCH_ENABLE_ERR</A>
#define <A HREF="#dvr_common_html_Defines__SMO_ENABLE_ERR">SMO_ENABLE_ERR</A>
#define <A HREF="#dvr_common_html_Defines__VOUT_ENABLE_ERR">VOUT_ENABLE_ERR</A>
</PRE>
<DIV CLASS="descr">
<P>
SMO output test errors: 
</P>
<UL>
<LI>
<EM>ASWITCH_ENABLE_ERR</EM> - Analog switch output enable error 
</LI>
<LI>
<EM>SMO_ENABLE_ERR</EM> - SMO output enable error 
</LI>
<LI>
<EM>VOUT_ENABLE_ERR</EM> - VOUT output enable error 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Defines__IOBOARD_LOOPBACK_ERR"></a>
<a name="dvr_common_html_Defines__IOBOARD_CAMTERM_ERR"></a>
<a name="dvr_common_html_Defines__IOBOARD_ALARMIN_ERR"></a>
<a name="dvr_common_html_Defines__IOBOARD_ALARMOUT_ERR"></a>
<a name="dvr_common_html_Defines__IOBOARD_ALARMOUTRELAY_ERR"></a>
<a name="dvr_common_html_Defines__IOBOARD_LED_ERR"></a>
<PRE class="cdef">
#define <A HREF="#dvr_common_html_Defines__IOBOARD_LOOPBACK_ERR">IOBOARD_LOOPBACK_ERR</A>
#define <A HREF="#dvr_common_html_Defines__IOBOARD_CAMTERM_ERR">IOBOARD_CAMTERM_ERR</A>
#define <A HREF="#dvr_common_html_Defines__IOBOARD_ALARMIN_ERR">IOBOARD_ALARMIN_ERR</A>
#define <A HREF="#dvr_common_html_Defines__IOBOARD_ALARMOUT_ERR">IOBOARD_ALARMOUT_ERR</A>
#define <A HREF="#dvr_common_html_Defines__IOBOARD_ALARMOUTRELAY_ERR">IOBOARD_ALARMOUTRELAY_ERR</A>
#define <A HREF="#dvr_common_html_Defines__IOBOARD_LED_ERR">IOBOARD_LED_ERR</A>
</PRE>
<DIV CLASS="descr">
<P>
I/O board test errors (not run in field diagnostics): 
</P>
<UL>
<LI>
<EM>IOBOARD_LOOPBACK_ERR</EM> - I/O board loopback test error 
</LI>
<LI>
<EM>IOBOARD_CAMTERM_ERR</EM> - Camera termination test error 
</LI>
<LI>
<EM>IOBOARD_ALARMIN_ERR</EM> - Alarm input test error 
</LI>
<LI>
<EM>IOBOARD_ALARMOUT_ERR</EM> - Alarm output test error 
</LI>
<LI>
<EM>IOBOARD_ALARMOUTRELAY_ERR</EM> - Alarm output relay test error 
</LI>
<LI>
<EM>IOBOARD_LED_ERR</EM> - LED test error 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Defines__GLOBAL_RESET_TEST_ERR"></a>
<PRE class="cdef">
#define <A HREF="#dvr_common_html_Defines__GLOBAL_RESET_TEST_ERR">GLOBAL_RESET_TEST_ERR</A>
</PRE>
<DIV CLASS="descr">
<P>
Global reset errors (not run in field diagnostics): 
</P>
<UL>
<LI>
<EM>GLOBAL_RESET_TEST_ERR</EM> - Global reset test error 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Defines__DVR_VSTD_UNKNOWN"></a>
<a name="dvr_common_html_Defines__DVR_VSTD_D1_PAL"></a>
<a name="dvr_common_html_Defines__DVR_VSTD_D1_NTSC"></a>
<a name="dvr_common_html_Defines__DVR_VSTD_CIF_PAL"></a>
<a name="dvr_common_html_Defines__DVR_VSTD_CIF_NTSC"></a>
<a name="dvr_common_html_Defines__DVR_VSTD_2CIF_PAL"></a>
<a name="dvr_common_html_Defines__DVR_VSTD_2CIF_NTSC"></a>
<a name="dvr_common_html_Defines__DVR_VSTD_4CIF_PAL"></a>
<a name="dvr_common_html_Defines__DVR_VSTD_4CIF_NTSC"></a>
<a name="dvr_common_html_Defines__DVR_VSTD_QCIF_PAL"></a>
<a name="dvr_common_html_Defines__DVR_VSTD_QCIF_NTSC"></a>
<PRE class="cdef">
#define <A HREF="#dvr_common_html_Defines__DVR_VSTD_UNKNOWN">DVR_VSTD_UNKNOWN</A>
#define <A HREF="#dvr_common_html_Defines__DVR_VSTD_D1_PAL">DVR_VSTD_D1_PAL</A>
#define <A HREF="#dvr_common_html_Defines__DVR_VSTD_D1_NTSC">DVR_VSTD_D1_NTSC</A>
#define <A HREF="#dvr_common_html_Defines__DVR_VSTD_CIF_PAL">DVR_VSTD_CIF_PAL</A>
#define <A HREF="#dvr_common_html_Defines__DVR_VSTD_CIF_NTSC">DVR_VSTD_CIF_NTSC</A>
#define <A HREF="#dvr_common_html_Defines__DVR_VSTD_2CIF_PAL">DVR_VSTD_2CIF_PAL</A>
#define <A HREF="#dvr_common_html_Defines__DVR_VSTD_2CIF_NTSC">DVR_VSTD_2CIF_NTSC</A>
#define <A HREF="#dvr_common_html_Defines__DVR_VSTD_4CIF_PAL">DVR_VSTD_4CIF_PAL</A>
#define <A HREF="#dvr_common_html_Defines__DVR_VSTD_4CIF_NTSC">DVR_VSTD_4CIF_NTSC</A>
#define <A HREF="#dvr_common_html_Defines__DVR_VSTD_QCIF_PAL">DVR_VSTD_QCIF_PAL</A>
#define <A HREF="#dvr_common_html_Defines__DVR_VSTD_QCIF_NTSC">DVR_VSTD_QCIF_NTSC</A>
</PRE>
<DIV CLASS="descr">
<P>
Camera types:   
</P>
<UL>
<LI>
<A HREF="#dvr_common_html_Defines__DVR_VSTD_D1_PAL">DVR_VSTD_D1_PAL</A>    is defined as 704x576 at 25fps. 
</LI>
<LI>
<A HREF="#dvr_common_html_Defines__DVR_VSTD_D1_NTSC">DVR_VSTD_D1_NTSC</A>   is defined as 704x480 at 30fps. 
</LI>
<LI>
<A HREF="#dvr_common_html_Defines__DVR_VSTD_CIF_PAL">DVR_VSTD_CIF_PAL</A>   is defined as 352x288 at 25fps. 
</LI>
<LI>
<A HREF="#dvr_common_html_Defines__DVR_VSTD_CIF_NTSC">DVR_VSTD_CIF_NTSC</A>  is defined as 352x240 at 30fps. 
</LI>
<LI>
<A HREF="#dvr_common_html_Defines__DVR_VSTD_2CIF_PAL">DVR_VSTD_2CIF_PAL</A>  is defined as 704x288 at 25fps. 
</LI>
<LI>
<A HREF="#dvr_common_html_Defines__DVR_VSTD_2CIF_NTSC">DVR_VSTD_2CIF_NTSC</A> is defined as 704x240 at 30fps. 
</LI>
<LI>
<A HREF="#dvr_common_html_Defines__DVR_VSTD_4CIF_PAL">DVR_VSTD_4CIF_PAL</A>  is defined as 704x576 at 25fps. 
</LI>
<LI>
<A HREF="#dvr_common_html_Defines__DVR_VSTD_4CIF_NTSC">DVR_VSTD_4CIF_NTSC</A> is defined as 704x480 at 30fps. 
</LI>
<LI>
<A HREF="#dvr_common_html_Defines__DVR_VSTD_QCIF_PAL">DVR_VSTD_QCIF_PAL</A>  is defined as 176x144 at 25 fps. 
</LI>
<LI>
<A HREF="#dvr_common_html_Defines__DVR_VSTD_QCIF_NTSC">DVR_VSTD_QCIF_NTSC</A> is defined as 176x112 at 30 fps. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Defines__DVR_JOB_STATE_VIDEO_LOST"></a>
<a name="dvr_common_html_Defines__DVR_JOB_STATE_AUDIO_LOST"></a>
<PRE class="cdef">
#define <A HREF="#dvr_common_html_Defines__DVR_JOB_STATE_VIDEO_LOST">DVR_JOB_STATE_VIDEO_LOST</A>
#define <A HREF="#dvr_common_html_Defines__DVR_JOB_STATE_AUDIO_LOST">DVR_JOB_STATE_AUDIO_LOST</A>
</PRE>
<DIV CLASS="descr">
<P>
DVR job state flags. The flags are OR-ed together and sent to the 
host in every data buffer header. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_JOB_STATE_VIDEO_LOST">DVR_JOB_STATE_VIDEO_LOST</A> is set when the video signal is lost. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_JOB_STATE_AUDIO_LOST">DVR_JOB_STATE_AUDIO_LOST</A> is set when the audio signal is lost. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Defines__DVR_FONT_OPCODE_START"></a>
<a name="dvr_common_html_Defines__DVR_FONT_OPCODE_FINISH"></a>
<a name="dvr_common_html_Defines__DVR_FONT_OPCODE_SELECT"></a>
<a name="dvr_common_html_Defines__DVR_FONT_OPCODE_BUF_YY"></a>
<a name="dvr_common_html_Defines__DVR_FONT_OPCODE_BUF_UU"></a>
<a name="dvr_common_html_Defines__DVR_FONT_OPCODE_BUF_VV"></a>
<a name="dvr_common_html_Defines__DVR_FONT_OPCODE_BUF_UTF16"></a>
<a name="dvr_common_html_Defines__DVR_FONT_OPCODE_BUF_INDEX"></a>
<a name="dvr_common_html_Defines__DVR_FONT_OPCODE_BUF_WIDTH"></a>
<a name="dvr_common_html_Defines__DVR_FONT_OPCODE_COPY"></a>
<a name="dvr_common_html_Defines__DVR_FONT_OPCODE_COPY_DONE"></a>
<PRE class="cdef">
#define <A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_START">DVR_FONT_OPCODE_START</A> 1 
#define <A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_FINISH">DVR_FONT_OPCODE_FINISH</A> 2 
#define <A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_SELECT">DVR_FONT_OPCODE_SELECT</A> 3 
#define <A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_BUF_YY">DVR_FONT_OPCODE_BUF_YY</A> 4 
#define <A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_BUF_UU">DVR_FONT_OPCODE_BUF_UU</A> 5 
#define <A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_BUF_VV">DVR_FONT_OPCODE_BUF_VV</A> 6 
#define <A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_BUF_UTF16">DVR_FONT_OPCODE_BUF_UTF16</A> 7 
#define <A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_BUF_INDEX">DVR_FONT_OPCODE_BUF_INDEX</A> 8 
#define <A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_BUF_WIDTH">DVR_FONT_OPCODE_BUF_WIDTH</A> 9 
#define <A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_COPY">DVR_FONT_OPCODE_COPY</A> 10 
#define <A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_COPY_DONE">DVR_FONT_OPCODE_COPY_DONE</A> 11 
</PRE>
<DIV CLASS="descr">
<P>
Font table related Opcodes. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_START">DVR_FONT_OPCODE_START</A> - Indicates that the host application is ready 
to start downloading font information for a new font. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_FINISH">DVR_FONT_OPCODE_FINISH</A> - Indicates that the download is complete 
and the connection should be closed. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_SELECT">DVR_FONT_OPCODE_SELECT</A> - Indicates that a new font index is to be 
selected. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_BUF_YY">DVR_FONT_OPCODE_BUF_YY</A> - Indicates that the download for the font 
bitmap Y buffers is about to start. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_BUF_UU">DVR_FONT_OPCODE_BUF_UU</A> - Indicates that the download for the font 
bitmap U buffers is about to start. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_BUF_VV">DVR_FONT_OPCODE_BUF_VV</A> - Indicates that the download for the font 
bitmap V buffers is about to start. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_BUF_UTF16">DVR_FONT_OPCODE_BUF_UTF16</A> - Indicates that the download for the 
UTF16 character codes is about to start. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_BUF_INDEX">DVR_FONT_OPCODE_BUF_INDEX</A> - Indicates that the download for the 
character indexes is about to start. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_BUF_WIDTH">DVR_FONT_OPCODE_BUF_WIDTH</A> - Indicates that the download for the 
character width values is about to start. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_COPY">DVR_FONT_OPCODE_COPY</A> - This opcode is used internally by the 
firmware. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_COPY_DONE">DVR_FONT_OPCODE_COPY_DONE</A> - This opcode is used internally by 
the firmware. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Defines__DVR_FONT_ENGLISH"></a>
<PRE class="cdef">
#define <A HREF="#dvr_common_html_Defines__DVR_FONT_ENGLISH">DVR_FONT_ENGLISH</A> 0 
</PRE>
<DIV CLASS="descr">
<P>
Stretch DVR pre-loaded font tables. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_FONT_ENGLISH">DVR_FONT_ENGLISH</A> - Default font for English (ASCII) character set. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Defines__DVR_FONT_FORMAT_YUV_4_2_0"></a>
<PRE class="cdef">
#define <A HREF="#dvr_common_html_Defines__DVR_FONT_FORMAT_YUV_4_2_0">DVR_FONT_FORMAT_YUV_4_2_0</A> 1 
</PRE>
<DIV CLASS="descr">
<P>
The format of the font table (i.e. bmp 4-2-0). 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_FONT_FORMAT_YUV_4_2_0">DVR_FONT_FORMAT_YUV_4_2_0</A> - The font table is constructed as YUV 
4-2-0 format. Currently, this is the only supported format. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Defines__DVR_OSD_OPCODE_CONFIG"></a>
<a name="dvr_common_html_Defines__DVR_OSD_OPCODE_SHOW"></a>
<a name="dvr_common_html_Defines__DVR_OSD_OPCODE_TEXT"></a>
<a name="dvr_common_html_Defines__DVR_OSD_OPCODE_CLEAR_TEXT"></a>
<PRE class="cdef">
#define <A HREF="#dvr_common_html_Defines__DVR_OSD_OPCODE_CONFIG">DVR_OSD_OPCODE_CONFIG</A> 1 
#define <A HREF="#dvr_common_html_Defines__DVR_OSD_OPCODE_SHOW">DVR_OSD_OPCODE_SHOW</A> 2 
#define <A HREF="#dvr_common_html_Defines__DVR_OSD_OPCODE_TEXT">DVR_OSD_OPCODE_TEXT</A> 3 
#define <A HREF="#dvr_common_html_Defines__DVR_OSD_OPCODE_CLEAR_TEXT">DVR_OSD_OPCODE_CLEAR_TEXT</A> 4 
</PRE>
<DIV CLASS="descr">
<P>
OSD commands Opcodes. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_OSD_OPCODE_CONFIG">DVR_OSD_OPCODE_CONFIG</A> - OSD opcode to configure displaying of  
each OSD line. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_OSD_OPCODE_SHOW">DVR_OSD_OPCODE_SHOW</A>   - OSD opcode to set the show status of 
each of the OSD line. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_OSD_OPCODE_TEXT">DVR_OSD_OPCODE_TEXT</A>   - OSD opcode to set the text for each 
one of the OSD line. This opcode is invalid in <A HREF="#dvr_common_html_Types__DVR_GET_OSD_EX">DVR_GET_OSD_EX</A>. 
NOTE: It is possible to receive multiple <A HREF="#dvr_common_html_Defines__DVR_OSD_OPCODE_TEXT">DVR_OSD_OPCODE_TEXT</A> 
messages for large texts. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_OSD_OPCODE_CLEAR_TEXT">DVR_OSD_OPCODE_CLEAR_TEXT</A> - OSD opcode to remove the OSD text. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Defines__DVRFW_OSD_LEN"></a>
<PRE class="cdef">
#define <A HREF="#dvr_common_html_Defines__DVRFW_OSD_LEN">DVRFW_OSD_LEN</A> 100 
</PRE>
<DIV CLASS="descr">
<P>
Maximum OSD text length. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Defines__DVR_AUTH_KEY_LEN"></a>
<PRE class="cdef">
#define <A HREF="#dvr_common_html_Defines__DVR_AUTH_KEY_LEN">DVR_AUTH_KEY_LEN</A>
</PRE>
<DIV CLASS="descr">
<P>
Defines the length of the authentication key in bytes. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Defines__DVR_REGION_OPCODE_START"></a>
<a name="dvr_common_html_Defines__DVR_REGION_OPCODE_FINISH"></a>
<a name="dvr_common_html_Defines__DVR_REGION_OPCODE_CONFIG"></a>
<a name="dvr_common_html_Defines__DVR_REGION_OPCODE_ENABLE"></a>
<PRE class="cdef">
#define <A HREF="#dvr_common_html_Defines__DVR_REGION_OPCODE_START">DVR_REGION_OPCODE_START</A> 1 
#define <A HREF="#dvr_common_html_Defines__DVR_REGION_OPCODE_FINISH">DVR_REGION_OPCODE_FINISH</A> 2 
#define <A HREF="#dvr_common_html_Defines__DVR_REGION_OPCODE_CONFIG">DVR_REGION_OPCODE_CONFIG</A> 3 
#define <A HREF="#dvr_common_html_Defines__DVR_REGION_OPCODE_ENABLE">DVR_REGION_OPCODE_ENABLE</A> 4 
</PRE>
<DIV CLASS="descr">
<P>
Region map related opcodes. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_REGION_OPCODE_START">DVR_REGION_OPCODE_START</A> - Indicates that the host application is 
ready to start downloading the region map for the given region type. 
The data is downloaded through the control data channel (opened via 
an IOCTL command). Each buffer size N bytes where N is the number of 
16x16 macroblocks in the current D1 picture frame. When transferring 
the regions map, each bit in the region map index corresponding to a 
region layer for the region type. The layer bit map start from the 
right to left, where the most rightmost bit indicates the first layer. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_REGION_OPCODE_FINISH">DVR_REGION_OPCODE_FINISH</A> - Indicates that the download is complete. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_REGION_OPCODE_CONFIG">DVR_REGION_OPCODE_CONFIG</A> - Indicates the we are configuring the  
region by setting one or more alarm thresholds for the region type. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_REGION_OPCODE_ENABLE">DVR_REGION_OPCODE_ENABLE</A> - Used to enable or disable the specified 
alarm, or privacy blocking. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Defines__DVR_REGION_TYPE_MD"></a>
<a name="dvr_common_html_Defines__DVR_REGION_TYPE_BD"></a>
<a name="dvr_common_html_Defines__DVR_REGION_TYPE_ND"></a>
<a name="dvr_common_html_Defines__DVR_REGION_TYPE_PR"></a>
<PRE class="cdef">
#define <A HREF="#dvr_common_html_Defines__DVR_REGION_TYPE_MD">DVR_REGION_TYPE_MD</A> 1 
#define <A HREF="#dvr_common_html_Defines__DVR_REGION_TYPE_BD">DVR_REGION_TYPE_BD</A> 2 
#define <A HREF="#dvr_common_html_Defines__DVR_REGION_TYPE_ND">DVR_REGION_TYPE_ND</A> 3 
#define <A HREF="#dvr_common_html_Defines__DVR_REGION_TYPE_PR">DVR_REGION_TYPE_PR</A> 4 
</PRE>
<DIV CLASS="descr">
<P>
Region type related Opcodes. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_REGION_TYPE_MD">DVR_REGION_TYPE_MD</A> - Indicates motion detection regions. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_REGION_TYPE_BD">DVR_REGION_TYPE_BD</A> - Indicates blind detection regions. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_REGION_TYPE_ND">DVR_REGION_TYPE_ND</A> - Indicates night detection regions. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_REGION_TYPE_PR">DVR_REGION_TYPE_PR</A> - Indicates privacy blocking regions. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Defines__DVR_REGION_MAP_MAX_SIZE"></a>
<PRE class="cdef">
#define <A HREF="#dvr_common_html_Defines__DVR_REGION_MAP_MAX_SIZE">DVR_REGION_MAP_MAX_SIZE</A> 2048 
</PRE>
<DIV CLASS="descr">
<P>
Maximum size of a region map in bytes. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Defines__DVR_VPP_OPCODE_CONTROL"></a>
<a name="dvr_common_html_Defines__DVR_VPP_OPCODE_REGIONS"></a>
<PRE class="cdef">
#define <A HREF="#dvr_common_html_Defines__DVR_VPP_OPCODE_CONTROL">DVR_VPP_OPCODE_CONTROL</A> 0 
#define <A HREF="#dvr_common_html_Defines__DVR_VPP_OPCODE_REGIONS">DVR_VPP_OPCODE_REGIONS</A> 1 
</PRE>
<DIV CLASS="descr">
<P>
Opcodes for commands that support regions. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_VPP_OPCODE_CONTROL">DVR_VPP_OPCODE_CONTROL</A>   Opcode for control messages. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_VPP_OPCODE_REGIONS">DVR_VPP_OPCODE_REGIONS</A>   Opcode for region messages. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Defines__DVR_DATA_HDR_SIG"></a>
<PRE class="cdef">
#define <A HREF="#dvr_common_html_Defines__DVR_DATA_HDR_SIG">DVR_DATA_HDR_SIG</A>
</PRE>
<DIV CLASS="descr">
<P>
Data header signature value. Only present in new-style header. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Defines__DVR_DATA_HDR_VER"></a>
<PRE class="cdef">
#define <A HREF="#dvr_common_html_Defines__DVR_DATA_HDR_VER">DVR_DATA_HDR_VER</A>
</PRE>
<DIV CLASS="descr">
<P>
Current data header version. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Defines__DVR_DATA_HDR_LEN"></a>
<PRE class="cdef">
#define <A HREF="#dvr_common_html_Defines__DVR_DATA_HDR_LEN">DVR_DATA_HDR_LEN</A>
</PRE>
<DIV CLASS="descr">
<P>
Data header size. Must always be a multiple of 16. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Defines__DVR_UART_CMD_CONFIG"></a>
<a name="dvr_common_html_Defines__DVR_UART_CMD_OUTPUT"></a>
<PRE class="cdef">
#define <A HREF="#dvr_common_html_Defines__DVR_UART_CMD_CONFIG">DVR_UART_CMD_CONFIG</A> 1 
#define <A HREF="#dvr_common_html_Defines__DVR_UART_CMD_OUTPUT">DVR_UART_CMD_OUTPUT</A> 2 
</PRE>
<DIV CLASS="descr">
<P>
Command codes for DVR RS-485 port control. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_UART_CMD_CONFIG">DVR_UART_CMD_CONFIG</A> - UART configuration command. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_UART_CMD_OUTPUT">DVR_UART_CMD_OUTPUT</A> - UART output command. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Defines__DVR_IOCTL_CODE_IMG_CONTROL"></a>
<a name="dvr_common_html_Defines__DVR_IOCTL_CODE_DECODER_REGS"></a>
<a name="dvr_common_html_Defines__DVR_IOCTL_CODE_OPEN_CHAN"></a>
<a name="dvr_common_html_Defines__DVR_IOCTL_CODE_CLOSE_CHAN"></a>
<a name="dvr_common_html_Defines__DVR_IOCTL_CODE_MOTION_FRAME_FREQ"></a>
<a name="dvr_common_html_Defines__DVR_IOCTL_CODE_VPP_CONTROL"></a>
<a name="dvr_common_html_Defines__DVR_IOCTL_CODE_GAIN_MODE"></a>
<a name="dvr_common_html_Defines__DVR_IOCTL_CODE_TERMINATION"></a>
<a name="dvr_common_html_Defines__DVR_IOCTL_CODE_LED"></a>
<a name="dvr_common_html_Defines__DVR_IOCTL_CODE_RAWV_FORMAT"></a>
<PRE class="cdef">
#define <A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_IMG_CONTROL">DVR_IOCTL_CODE_IMG_CONTROL</A> 1 
#define <A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_DECODER_REGS">DVR_IOCTL_CODE_DECODER_REGS</A> 2 
#define <A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_OPEN_CHAN">DVR_IOCTL_CODE_OPEN_CHAN</A> 3 
#define <A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_CLOSE_CHAN">DVR_IOCTL_CODE_CLOSE_CHAN</A> 4 
#define <A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_MOTION_FRAME_FREQ">DVR_IOCTL_CODE_MOTION_FRAME_FREQ</A> 5 
#define <A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_VPP_CONTROL">DVR_IOCTL_CODE_VPP_CONTROL</A> 7 
#define <A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_GAIN_MODE">DVR_IOCTL_CODE_GAIN_MODE</A> 9 
#define <A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_TERMINATION">DVR_IOCTL_CODE_TERMINATION</A> 10 
#define <A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_LED">DVR_IOCTL_CODE_LED</A> 11 
#define <A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_RAWV_FORMAT">DVR_IOCTL_CODE_RAWV_FORMAT</A> 12 
</PRE>
<DIV CLASS="descr">
<P>
Stretch DVR IOCTL codes. These codes are used by the 
<A HREF="#dvr_common_html_Types__DVR_GET_IOCTL">DVR_GET_IOCTL</A>, <A HREF="#dvr_common_html_Types__DVR_SET_IOCTL">DVR_SET_IOCTL</A>, and <A HREF="#dvr_common_html_Types__DVR_REP_IOCTL">DVR_REP_IOCTL</A> commands. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_IMG_CONTROL">DVR_IOCTL_CODE_IMG_CONTROL</A> - Used to get and set video decoder image 
control parameters. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_DECODER_REGS">DVR_IOCTL_CODE_DECODER_REGS</A> - Used to get and set video decoder 
registers. Provides low level access to decoder configuration. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_OPEN_CHAN">DVR_IOCTL_CODE_OPEN_CHAN</A> - Used to open a data channel between the 
host and the firmware for control data, e.g. region map data. Used 
only with the SET and REP commands. This command is per board. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_CLOSE_CHAN">DVR_IOCTL_CODE_CLOSE_CHAN</A> - Used to close the data channel between 
the host and the firmware. Used only with SET and REP commands. 
This command is per board. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_MOTION_FRAME_FREQ">DVR_IOCTL_CODE_MOTION_FRAME_FREQ</A> - Used to specify how often to send 
motion value frames. The default is zero. 1 means send for every raw 
video frame recieved, 2 means send every second frame, and so on. 
Used only with the SET and REP commands. 
This command is per board. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_VPP_CONTROL">DVR_IOCTL_CODE_VPP_CONTROL</A> - Controls video preprocessing actions. 
See <A HREF="#dvr_common_html_Types__dvr_vpp_action_enum">dvr_vpp_action_enum</A> for the supported actions. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_GAIN_MODE">DVR_IOCTL_CODE_GAIN_MODE</A> - TBD 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_TERMINATION">DVR_IOCTL_CODE_TERMINATION</A> - TBD 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_LED">DVR_IOCTL_CODE_LED</A> - Used to set/get the current enable status of 
different LEDs on the DVR Board. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_RAWV_FORMAT">DVR_IOCTL_CODE_RAWV_FORMAT</A> - Used to set the format of raw video output 
from the board. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Defines__DVR_ICFLAG_HUE"></a>
<a name="dvr_common_html_Defines__DVR_ICFLAG_SAT"></a>
<a name="dvr_common_html_Defines__DVR_ICFLAG_BRT"></a>
<a name="dvr_common_html_Defines__DVR_ICFLAG_CONT"></a>
<a name="dvr_common_html_Defines__DVR_ICFLAG_SHARP"></a>
<PRE class="cdef">
#define <A HREF="#dvr_common_html_Defines__DVR_ICFLAG_HUE">DVR_ICFLAG_HUE</A> 0x1 
#define <A HREF="#dvr_common_html_Defines__DVR_ICFLAG_SAT">DVR_ICFLAG_SAT</A> 0x2 
#define <A HREF="#dvr_common_html_Defines__DVR_ICFLAG_BRT">DVR_ICFLAG_BRT</A> 0x4 
#define <A HREF="#dvr_common_html_Defines__DVR_ICFLAG_CONT">DVR_ICFLAG_CONT</A> 0x8 
#define <A HREF="#dvr_common_html_Defines__DVR_ICFLAG_SHARP">DVR_ICFLAG_SHARP</A> 0x10 
</PRE>
<DIV CLASS="descr">
<P>
Flags for use with the <A HREF="#dvr_common_html_Types__DVR_SET_IOCTL">DVR_SET_IOCTL</A> command. These flags 
indicate which fields of the data structure are valid. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_ICFLAG_HUE">DVR_ICFLAG_HUE</A> - Use the hue parameter. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_ICFLAG_SAT">DVR_ICFLAG_SAT</A> - Use the saturation parameter. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_ICFLAG_BRT">DVR_ICFLAG_BRT</A> - Use the brightness parameter. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_ICFLAG_CONT">DVR_ICFLAG_CONT</A> - Use the contrast parameter. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_ICFLAG_SHARP">DVR_ICFLAG_SHARP</A> - Use the sharpness parameter. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Defines__DVR_VOUT_OPCODE_START"></a>
<a name="dvr_common_html_Defines__DVR_VOUT_OPCODE_STOP"></a>
<PRE class="cdef">
#define <A HREF="#dvr_common_html_Defines__DVR_VOUT_OPCODE_START">DVR_VOUT_OPCODE_START</A> 0x1 
#define <A HREF="#dvr_common_html_Defines__DVR_VOUT_OPCODE_STOP">DVR_VOUT_OPCODE_STOP</A> 0x2 
</PRE>
<DIV CLASS="descr">
<P>
Flags for use with the <A HREF="#dvr_common_html_Types__DVR_SET_VIDEO_OUTPUT">DVR_SET_VIDEO_OUTPUT</A> command. These flags 
indicate which fields of the data structure are valid. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_VOUT_OPCODE_START">DVR_VOUT_OPCODE_START</A> - Prepare SCT channel to start receiving 
YUV video to be displayed on the given SMO port number. After this 
message, DVR firmware accepts video frames from the DVR Host Application. 
</P>
<P>
<A HREF="#dvr_common_html_Defines__DVR_VOUT_OPCODE_STOP">DVR_VOUT_OPCODE_STOP</A> - The SMO SCT receive channel will be closed 
and no more SMO video frames will be accepted from the DVR Host 
Applicaiton. 
</P>
</DIV>

</DIV>

<!-- SEC_DEFINES_CLOSE -->

<!-- SEC_ROUTINES_START -->

<a name="dvr_common_html_Top__Routines"></a>
<H2>2.11 &nbsp; Routines</H2>

<a name="dvr_common_html_Routines__Miscellaneous"></a>
<H3>2.11.1 &nbsp; Miscellaneous</H3>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvr_common_html_Routines__DVR_JOB_NUM"></a>
<PRE class="cdef">
#define <A HREF="#dvr_common_html_Routines__DVR_JOB_NUM">DVR_JOB_NUM</A> (board_id, job_type, job_id) { ... }
</PRE>
<DIV CLASS="descr">
<P>
Defines the convention for mapping a job to a job number 
</P>
</DIV>

</DIV>

<!-- SEC_ROUTINES_CLOSE -->

<DIV style="page-break-before:always"></DIV>
<A NAME=dvrfw_html_start_of_file></A>

<H1>Common Header File Internal to the DVR Firmware &nbsp; (dvrfw)</H1>

<CENTER>Last modified on Mar 18, 2009 at 07:17 UTC</CENTER>

<!-- last_modified : Mar 18, 2009 at 07:17 UTC -->

<!-- package : dvrfw -->

<!-- short-description : Common Header File Internal to the DVR Firmware -->

<!-- contact_name :  -->

<!-- contact_email :  -->

<!-- copyright :  -->

<!-- cdoc-version : 2.4.5 -->
<!-- ANCHOR_TABLE
"Package"	"dvrfw"	"dvrfw.html"
"Section"	"Include"	"Top__Include"
"Section"	"Introduction"	"Top__Introduction"
"Section"	"Responsibility of the dvrfw_host_msg_proxy() Task"	"Top__Responsibility___of___the___dvrfw_host_msg_proxy_________Task"
"Section"	"Responsibility of the dvrfw_host_data_proxy() Task"	"Top__Responsibility___of___the___dvrfw_host_data_proxy_________Task"
"Section"	"Responsibility of the dvrfw_camera_encode() Task"	"Top__Responsibility___of___the___dvrfw_camera_encode_________Task"
"Section"	"Responsibility of the dvrfw_host_decode() Task"	"Top__Responsibility___of___the___dvrfw_host_decode_________Task"
"Section"	"Responsibility of the dvrfw_host_encode() Task"	"Top__Responsibility___of___the___dvrfw_host_encode_________Task"
"Section"	"Details of the dvrfw_smo_manager() task"	"Top__Details___of___the___dvrfw_smo_manager_________task"
"Section"	"Details of the dvrfw_stdout_manager() Task"	"Top__Details___of___the___dvrfw_stdout_manager_________Task"
"Section"	"Types"	"Top__Types"
"Typedef"	"bootloader_versions"	"Types__bootloader_versions"
"Section"	"Defines"	"Top__Defines"
"Define"	"DVRFW_VER_MAJOR"	"Defines__DVRFW_VER_MAJOR"
"Define"	"DVRFW_VER_MINOR"	"Defines__DVRFW_VER_MINOR"
"Define"	"DVRFW_VER_BUG"	"Defines__DVRFW_VER_BUG"
"Define"	"DVRFW_VER_BUILD"	"Defines__DVRFW_VER_BUILD"
"Section"	"Routines"	"Top__Routines"
"Section"	"Miscellaneous"	"Routines__Miscellaneous"
"Routine"	"dvrfw_host_msg_proxy"	"Routines__dvrfw_host_msg_proxy"
"Routine"	"dvrfw_host_data_proxy"	"Routines__dvrfw_host_data_proxy"
"Routine"	"dvrfw_host_encode"	"Routines__dvrfw_host_encode"
"Routine"	"dvrfw_host_decode"	"Routines__dvrfw_host_decode"
"Routine"	"dvrfw_camera_encode"	"Routines__dvrfw_camera_encode"
"Routine"	"dvrfw_smo_manager"	"Routines__dvrfw_smo_manager"
"Routine"	"dvrfw_vout_manager"	"Routines__dvrfw_vout_manager"
"Routine"	"dvrfw_io_manager"	"Routines__dvrfw_io_manager"
"Routine"	"dvrfw_stdout_manager"	"Routines__dvrfw_stdout_manager"
-->

<P>
</P>


<!-- SEC_DESCRIPTION_START -->

<a name="dvrfw_html_Top__Include"></a>
<H2>3.1 &nbsp; Include</H2>
<PRE class="ccode">
#include "dvrfw.h" 
</PRE>

<a name="dvrfw_html_Top__Introduction"></a>
<H2>3.2 &nbsp; Introduction</H2>
<P>
<A HREF="#dvrfw_html_start_of_file">dvrfw</A> documents the DVR firmware architecture.  The DVR firmware 
is a distributed multi-tasking application.  It uses Stretch SCPA 
as the underlying OS for communication between the tasks.  It uses 
<STRONG>sct</STRONG> for communication to and from the DVR SDK running on the host PC. 
</P>
<P>
The entire firmware consists of multiple tasks.  The root task 
runs on the boot master and is responsible for all communication 
with the host.  There are several types of jobs the firmware 
needs to do: 
</P>
<UL>
<LI>
Encode images captured from camera. 
</LI>
<LI>
Encode images supplied by the host. 
</LI>
<LI>
Decode bit streams supplied by the host. 
</LI>
<LI>
Manage spot monitor. 
</LI>
</UL>
<P>
On each chip, there is one task for each of the above job types. 
The list of distinct tasks are: 
</P>
<UL>
<LI>
<NOBR><A HREF="#dvrfw_html_Routines__dvrfw_host_msg_proxy">dvrfw_host_msg_proxy</A>()</NOBR> - The root task on PE0 as a message 
gateway to the host.  There is only one instance of this  
task in the entire system. 
</LI>
<LI>
<NOBR><A HREF="#dvrfw_html_Routines__dvrfw_host_data_proxy">dvrfw_host_data_proxy</A>()</NOBR> - The root task on PE0 as a data 
gateway to the host.  There is only one instance of this  
task in the entire system. 
</LI>
<LI>
<NOBR><A HREF="#dvrfw_html_Routines__dvrfw_camera_encode">dvrfw_camera_encode</A>()</NOBR> - Task to encoder images from the 
S6 data ports.  There is one instance of this task per PE. 
</LI>
<LI>
<NOBR><A HREF="#dvrfw_html_Routines__dvrfw_host_encode">dvrfw_host_encode</A>()</NOBR> - Task to encode images the host. 
There is one instance of this task per PE. 
</LI>
<LI>
<NOBR><A HREF="#dvrfw_html_Routines__dvrfw_host_decode">dvrfw_host_decode</A>()</NOBR> - Task to decode bit stream from the host. 
There is one instance of this task per PE. 
</LI>
<LI>
<NOBR><A HREF="#dvrfw_html_Routines__dvrfw_smo_manager">dvrfw_smo_manager</A>()</NOBR> - Task to manage SMO display arrangement. 
There is one instance of this task in the entire system, 
on the PE driving the SMO. 
</LI>
<LI>
<NOBR><A HREF="#dvrfw_html_Routines__dvrfw_vout_manager">dvrfw_vout_manager</A>()</NOBR> - Task to manage video output display. 
There is one instance of this task in the entire system, 
on the PE driving the video output. 
</LI>
<LI>
<NOBR><A HREF="#dvrfw_html_Routines__dvrfw_io_manager">dvrfw_io_manager</A>()</NOBR> - Task to manage I/O requests. 
There is one instance of this task in the entire system, 
on the PE attached to the I/O circuitry. 
</LI>
<LI>
<NOBR><A HREF="#dvrfw_html_Routines__dvrfw_stdout_manager">dvrfw_stdout_manager</A>()</NOBR> - Task to send stdout strings to the host. 
There is one instance of this task in the entire system, 
typically on PE0. This task is currently unimplemented. 
</LI>
</UL>

<a name="dvrfw_html_Top__Responsibility___of___the___dvrfw_host_msg_proxy_________Task"></a>
<H3>2.1 &nbsp; Responsibility of the <A HREF="#dvrfw_html_Routines__dvrfw_host_msg_proxy">dvrfw_host_msg_proxy</A>() Task</H3>
<UL>
<LI>
Periodically pull messages from the host and dispatch them 
to the appropriate jobs (tasks). 
</LI>
<LI>
Logging all the communication between firmware and the host 
for debugging.  All the logging information is sent to 
the host, over the debug channel, for storing and replaying. 
</LI>
<LI>
Allocating jobs to the chips.  It is responsible for making 
sure the chip can meet the real-time requirement. 
</LI>
<LI>
Creating and destroying a job on a specific chip. 
</LI>
</UL>

<a name="dvrfw_html_Top__Responsibility___of___the___dvrfw_host_data_proxy_________Task"></a>
<H3>2.2 &nbsp; Responsibility of the <A HREF="#dvrfw_html_Routines__dvrfw_host_data_proxy">dvrfw_host_data_proxy</A>() Task</H3>
<UL>
<LI>
Periodically check for data from all jobs and forward 
them over the PCIe bus to the host. 
</LI>
</UL>

<a name="dvrfw_html_Top__Responsibility___of___the___dvrfw_camera_encode_________Task"></a>
<H3>2.3 &nbsp; Responsibility of the <A HREF="#dvrfw_html_Routines__dvrfw_camera_encode">dvrfw_camera_encode</A>() Task</H3>
<P>
There is one task of this type per chip.  It performs 
the following functions for each enabled input camera 
channel: 
</P>
<UL>
<LI>
Pre-process, resize, and sub-sample incoming images. 
</LI>
<LI>
Encode incoming images. 
</LI>
<LI>
Send bit stream. 
</LI>
<LI>
Send resized images to <NOBR><A HREF="#dvrfw_html_Routines__dvrfw_smo_manager">dvrfw_smo_manager</A>()</NOBR>. 
</LI>
</UL>

<a name="dvrfw_html_Top__Responsibility___of___the___dvrfw_host_decode_________Task"></a>
<H3>2.4 &nbsp; Responsibility of the <A HREF="#dvrfw_html_Routines__dvrfw_host_decode">dvrfw_host_decode</A>() Task</H3>
<P>
There is one task of this type per chip.  It performs 
the following functions for each decoding bit stream 
sent by the host: 
</P>
<UL>
<LI>
Decode incoming bit stream. 
</LI>
<LI>
Pre-process and resize decoded images. 
</LI>
<LI>
Send decoded images to host. 
</LI>
<LI>
Send resized images to <NOBR><A HREF="#dvrfw_html_Routines__dvrfw_smo_manager">dvrfw_smo_manager</A>()</NOBR>. 
</LI>
</UL>

<a name="dvrfw_html_Top__Responsibility___of___the___dvrfw_host_encode_________Task"></a>
<H3>2.5 &nbsp; Responsibility of the <A HREF="#dvrfw_html_Routines__dvrfw_host_encode">dvrfw_host_encode</A>() Task</H3>
<P>
There is one task of this type per chip.  It performs 
the following functions for each encoding channel 
sent by the host: 
</P>
<UL>
<LI>
Pre-process, resize and sub-sample incoming images. 
</LI>
<LI>
Encode incoming images. 
</LI>
<LI>
Send bit stream. 
</LI>
<LI>
Send resized images to <NOBR><A HREF="#dvrfw_html_Routines__dvrfw_smo_manager">dvrfw_smo_manager</A>()</NOBR>. 
</LI>
</UL>

<a name="dvrfw_html_Top__Details___of___the___dvrfw_smo_manager_________task"></a>
<H3>2.6 &nbsp; Details of the <A HREF="#dvrfw_html_Routines__dvrfw_smo_manager">dvrfw_smo_manager</A>() task</H3>
<UL>
<LI>
DMA incoming images to to specific regions in the SMO buffer. 
</LI>
<LI>
Send SMO buffer to the device. 
</LI>
</UL>

<a name="dvrfw_html_Top__Details___of___the___dvrfw_stdout_manager_________Task"></a>
<H3>2.7 &nbsp; Details of the <A HREF="#dvrfw_html_Routines__dvrfw_stdout_manager">dvrfw_stdout_manager</A>() Task</H3>
<UL>
<LI>
This task runs on PE0 and redirects writes from each chip to 
the host for displaying on the console. On each chip, there 
is a special <EM>write</EM> to replace the standard system <EM>write</EM>. 
The special write sends the output to the stdout manager task. 
This mechanism is currently unimplemented. 
</LI>
</UL>

<!-- SEC_DESCRIPTION_CLOSE -->

<!-- SEC_TYPES_START -->

<a name="dvrfw_html_Top__Types"></a>
<H2>3.3 &nbsp; Types</H2>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvrfw_html_Types__bootloader_versions"></a>
<PRE class="cdef">
typedef struct _bootloader_versions { ... } <A HREF="#dvrfw_html_Types__bootloader_versions">bootloader_versions</A>;
</PRE>
<DIV CLASS="descr">
<P>
Boot-Loader and BSP version definition structure. 
</P>
</DIV>

</DIV>

<!-- SEC_TYPES_CLOSE -->

<!-- SEC_DEFINES_START -->

<a name="dvrfw_html_Top__Defines"></a>
<H2>3.4 &nbsp; Defines</H2>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvrfw_html_Defines__DVRFW_VER_MAJOR"></a>
<a name="dvrfw_html_Defines__DVRFW_VER_MINOR"></a>
<a name="dvrfw_html_Defines__DVRFW_VER_BUG"></a>
<a name="dvrfw_html_Defines__DVRFW_VER_BUILD"></a>
<PRE class="cdef">
#define <A HREF="#dvrfw_html_Defines__DVRFW_VER_MAJOR">DVRFW_VER_MAJOR</A>
#define <A HREF="#dvrfw_html_Defines__DVRFW_VER_MINOR">DVRFW_VER_MINOR</A>
#define <A HREF="#dvrfw_html_Defines__DVRFW_VER_BUG">DVRFW_VER_BUG</A>
#define <A HREF="#dvrfw_html_Defines__DVRFW_VER_BUILD">DVRFW_VER_BUILD</A>
</PRE>
<DIV CLASS="descr">
<P>
Current DVR Firmware version number. 
<A HREF="#dvrfw_html_Defines__DVRFW_VER_MAJOR">DVRFW_VER_MAJOR</A>, <A HREF="#dvrfw_html_Defines__DVRFW_VER_MINOR">DVRFW_VER_MINOR</A>, <A HREF="#dvrfw_html_Defines__DVRFW_VER_BUG">DVRFW_VER_BUG</A>, <A HREF="#dvrfw_html_Defines__DVRFW_VER_BUILD">DVRFW_VER_BUILD</A>. 
</P>
</DIV>

</DIV>

<!-- SEC_DEFINES_CLOSE -->

<!-- SEC_ROUTINES_START -->

<a name="dvrfw_html_Top__Routines"></a>
<H2>3.5 &nbsp; Routines</H2>

<a name="dvrfw_html_Routines__Miscellaneous"></a>
<H3>3.5.1 &nbsp; Miscellaneous</H3>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvrfw_html_Routines__dvrfw_host_msg_proxy"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> <A HREF="#dvrfw_html_Routines__dvrfw_host_msg_proxy">dvrfw_host_msg_proxy</A> (void *arg);
</PRE>
<DIV CLASS="descr">
<P>
Task responsible for communicating with the host.  This is the 
gateway for all DVR firmware tasks. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvrfw_html_Routines__dvrfw_host_data_proxy"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> <A HREF="#dvrfw_html_Routines__dvrfw_host_data_proxy">dvrfw_host_data_proxy</A> (void *arg);
</PRE>
<DIV CLASS="descr">
<P>
This task acts as a proxy for all data sent between tasks on 
the PCIe boards and the host PC.  All data sent from an S6 task to 
the PC must be sent to this task, which in turn sends it to the host 
via the PCIe bus. 
</P>
<P>
<STRONG>NOTE</STRONG>: Much of this code is board-specific, i.e. tied to the way 
jobs are set up on the Stretch board. If your board architecture 
is different, then this code will have to be changed to match. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvrfw_html_Routines__dvrfw_host_encode"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> <A HREF="#dvrfw_html_Routines__dvrfw_host_encode">dvrfw_host_encode</A> (void *arg);
</PRE>
<DIV CLASS="descr">
<P>
Encoding task 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvrfw_html_Routines__dvrfw_host_decode"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> <A HREF="#dvrfw_html_Routines__dvrfw_host_decode">dvrfw_host_decode</A> (void *arg);
</PRE>
<DIV CLASS="descr">
<P>
Host decode task. This task controls decoding on every PE that it 
runs on. In this implementation it runs on every PE, and creates 
the same number of decode jobs on every PE. If your system supports 
a different organization of decode jobs, then you need to modify 
this code to control the decode job setup. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvrfw_html_Routines__dvrfw_camera_encode"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> <A HREF="#dvrfw_html_Routines__dvrfw_camera_encode">dvrfw_camera_encode</A> (void *arg);
</PRE>
<DIV CLASS="descr">
<P>
Encoding task main function. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvrfw_html_Routines__dvrfw_smo_manager"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> <A HREF="#dvrfw_html_Routines__dvrfw_smo_manager">dvrfw_smo_manager</A> (void *arg);
</PRE>
<DIV CLASS="descr">
<P>
SMO task 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvrfw_html_Routines__dvrfw_vout_manager"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> <A HREF="#dvrfw_html_Routines__dvrfw_vout_manager">dvrfw_vout_manager</A> (void *arg);
</PRE>
<DIV CLASS="descr">
<P>
Video output task 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvrfw_html_Routines__dvrfw_io_manager"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> <A HREF="#dvrfw_html_Routines__dvrfw_io_manager">dvrfw_io_manager</A> (void *arg);
</PRE>
<DIV CLASS="descr">
<P>
Input/output task 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="dvrfw_html_Routines__dvrfw_stdout_manager"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> <A HREF="#dvrfw_html_Routines__dvrfw_stdout_manager">dvrfw_stdout_manager</A> (void *arg);
</PRE>
<DIV CLASS="descr">
<P>
Encoding task 
</P>
</DIV>

</DIV>

<!-- SEC_ROUTINES_CLOSE -->

<DIV style="page-break-before:always"></DIV>
<A NAME=sdvr_sdk_html_start_of_file></A>

<H1>Stretch DVR SDK &nbsp; (sdvr_sdk)</H1>

<CENTER>Last modified on Mar 18, 2009 at 07:18 UTC</CENTER>

<!-- last_modified : Mar 18, 2009 at 07:18 UTC -->

<!-- package : sdvr_sdk -->

<!-- short-description : Stretch DVR SDK -->

<!-- contact_name :  -->

<!-- contact_email :  -->

<!-- copyright :  -->

<!-- cdoc-version : 2.4.5 -->
<!-- ANCHOR_TABLE
"Package"	"sdvr_sdk"	"sdvr_sdk.html"
"Section"	"Include"	"Top__Include"
"Section"	"Introduction"	"Top__Introduction"
"Section"	"Function Groups"	"Top__Function___Groups"
"Section"	"Important Notes about the SDK"	"Top__Important___Notes___about___the___SDK"
"Section"	"Important Restrictions"	"Top__Important___Restrictions"
"Section"	"Format of data buffer exchange between SDK and DVR Application"	"Top__Format___of___data___buffer___exchange___between___SDK___and___DVR___Application"
"Section"	"Using the SDK API"	"Top__Using___the___SDK___API"
"Section"	"SDK and Board Initialization and Set-Up"	"Top__SDK___and___Board___Initialization___and___Set___Up"
"Section"	"Channel Set-Up"	"Top__Channel___Set___Up"
"Section"	"Video Analytics and Privacy Blocking"	"Top__Video___Analytics___and___Privacy___Blocking"
"Section"	"Encode"	"Top__Encode"
"Section"	"Decode"	"Top__Decode"
"Section"	"Raw video and audio data"	"Top__Raw___video___and___audio___data"
"Section"	"On-Screen Display (OSD)"	"Top__On___Screen___Display______OSD___"
"Section"	"Spot Monitor Output (SMO)"	"Top__Spot___Monitor___Output______SMO___"
"Section"	"Pan, Tilt, and Zoom"	"Top__Pan______Tilt______and___Zoom"
"Section"	"Sensors and Relays"	"Top__Sensors___and___Relays"
"Section"	"System Shutdown"	"Top__System___Shutdown"
"Section"	"Types"	"Top__Types"
"Typedef"	"sx_uint8"	"Types__sx_uint8"
"Typedef"	"sx_uint16"	"Types__sx_uint16"
"Typedef"	"sx_uint32"	"Types__sx_uint32"
"Typedef"	"sx_uint64"	"Types__sx_uint64"
"Typedef"	"sx_bool"	"Types__sx_bool"
"Typedef"	"sx_int8"	"Types__sx_int8"
"Typedef"	"sx_int16"	"Types__sx_int16"
"Typedef"	"sx_int32"	"Types__sx_int32"
"Typedef"	"sx_int64"	"Types__sx_int64"
"Typedef"	"time_t"	"Types__time_t"
"Typedef"	"sdvr_err_e"	"Types__sdvr_err_e"
"Typedef"	"SDVR_ERR_NONE"	"Types__SDVR_ERR_NONE"
"Typedef"	"SDVR_FRMW_ERR_WRONG_CAMERA_NUMBER"	"Types__SDVR_FRMW_ERR_WRONG_CAMERA_NUMBER"
"Typedef"	"SDVR_FRMW_ERR_WRONG_CAMERA_TYPE"	"Types__SDVR_FRMW_ERR_WRONG_CAMERA_TYPE"
"Typedef"	"SDVR_FRMW_ERR_WRONG_CODEC_FORMAT"	"Types__SDVR_FRMW_ERR_WRONG_CODEC_FORMAT"
"Typedef"	"SDVR_FRMW_ERR_WRONG_CODEC_RESOLUTION"	"Types__SDVR_FRMW_ERR_WRONG_CODEC_RESOLUTION"
"Typedef"	"SDVR_FRMW_ERR_WRONG_CHANNEL_TYPE"	"Types__SDVR_FRMW_ERR_WRONG_CHANNEL_TYPE"
"Typedef"	"SDVR_FRMW_ERR_WRONG_CHANNEL_ID"	"Types__SDVR_FRMW_ERR_WRONG_CHANNEL_ID"
"Typedef"	"SDVR_FRMW_ERR_WRONG_VIDEO_FORMAT"	"Types__SDVR_FRMW_ERR_WRONG_VIDEO_FORMAT"
"Typedef"	"SDVR_FRMW_ERR_WRONG_AUDIO_FORMAT"	"Types__SDVR_FRMW_ERR_WRONG_AUDIO_FORMAT"
"Typedef"	"SDVR_FRMW_ERR_EXCEED_CPU_LIMIT"	"Types__SDVR_FRMW_ERR_EXCEED_CPU_LIMIT"
"Typedef"	"SDVR_FRMW_ERR_CHANNEL_NOT_CREATED"	"Types__SDVR_FRMW_ERR_CHANNEL_NOT_CREATED"
"Typedef"	"SDVR_FRMW_ERR_CHANNEL_ALREADY_CREATED"	"Types__SDVR_FRMW_ERR_CHANNEL_ALREADY_CREATED"
"Typedef"	"SDVR_FRMW_ERR_CHANNEL_NOT_ENABLED"	"Types__SDVR_FRMW_ERR_CHANNEL_NOT_ENABLED"
"Typedef"	"SDVR_FRMW_ERR_CHANNEL_NOT_DISABLED"	"Types__SDVR_FRMW_ERR_CHANNEL_NOT_DISABLED"
"Typedef"	"SDVR_FRMW_ERR_SMO_NOT_CREATED"	"Types__SDVR_FRMW_ERR_SMO_NOT_CREATED"
"Typedef"	"SDVR_FRMW_ERR_INVALID_TIME"	"Types__SDVR_FRMW_ERR_INVALID_TIME"
"Typedef"	"SDVR_FRMW_ERR_ILLEGAL_SMO_PARAMS"	"Types__SDVR_FRMW_ERR_ILLEGAL_SMO_PARAMS"
"Typedef"	"SDVR_FRMW_ERR_SMO_NOT_SUPPORTED"	"Types__SDVR_FRMW_ERR_SMO_NOT_SUPPORTED"
"Typedef"	"SDVR_FRMW_ERR_VDET_ERROR"	"Types__SDVR_FRMW_ERR_VDET_ERROR"
"Typedef"	"SDVR_FRMW_ERR_RUNTIME_ERROR"	"Types__SDVR_FRMW_ERR_RUNTIME_ERROR"
"Typedef"	"SDVR_FRMW_ERR_VPP_RUNTIME_ERROR"	"Types__SDVR_FRMW_ERR_VPP_RUNTIME_ERROR"
"Typedef"	"SDVR_FRMW_ERR_ENCODER_RUNTIME_ERROR"	"Types__SDVR_FRMW_ERR_ENCODER_RUNTIME_ERROR"
"Typedef"	"SDVR_FRMW_ERR_DECODER_RUNTIME_ERROR"	"Types__SDVR_FRMW_ERR_DECODER_RUNTIME_ERROR"
"Typedef"	"SDVR_FRMW_ERR_ILLEGAL_PARAMETER"	"Types__SDVR_FRMW_ERR_ILLEGAL_PARAMETER"
"Typedef"	"SDVR_FRMW_ERR_INTERNAL_ERROR"	"Types__SDVR_FRMW_ERR_INTERNAL_ERROR"
"Typedef"	"SDVR_FRMW_ERR_ILLEGAL_COMMAND"	"Types__SDVR_FRMW_ERR_ILLEGAL_COMMAND"
"Typedef"	"SDVR_FRMW_ERR_SMO_NOT_DISABLED"	"Types__SDVR_FRMW_ERR_SMO_NOT_DISABLED"
"Typedef"	"SDVR_FRMW_ERR_OUT_OF_MEMORY"	"Types__SDVR_FRMW_ERR_OUT_OF_MEMORY"
"Typedef"	"SDVR_FRMW_ERR_NO_IO_BOARD"	"Types__SDVR_FRMW_ERR_NO_IO_BOARD"
"Typedef"	"SDVR_FRMW_ERR_AUDIO_RUNTIME"	"Types__SDVR_FRMW_ERR_AUDIO_RUNTIME"
"Typedef"	"SDVR_FRMW_ERR_UNSUPPORTED_COMMAND"	"Types__SDVR_FRMW_ERR_UNSUPPORTED_COMMAND"
"Typedef"	"SDVR_FRMW_ERR_SMO_CHAN_FAILED"	"Types__SDVR_FRMW_ERR_SMO_CHAN_FAILED"
"Typedef"	"SDVR_FRMW_ERR_RES_LIMIT_EXCEEDED"	"Types__SDVR_FRMW_ERR_RES_LIMIT_EXCEEDED"
"Typedef"	"SDVR_DRV_ERR_MSG_RECV"	"Types__SDVR_DRV_ERR_MSG_RECV"
"Typedef"	"SDVR_DRV_ERR_INVALID_PARAMETER"	"Types__SDVR_DRV_ERR_INVALID_PARAMETER"
"Typedef"	"SDVR_DRV_ERR_BOARD_IN_USE"	"Types__SDVR_DRV_ERR_BOARD_IN_USE"
"Typedef"	"SDVR_DRV_ERR_BOARD_CONNECT"	"Types__SDVR_DRV_ERR_BOARD_CONNECT"
"Typedef"	"SDVR_DRV_ERR_BOARD_CLOSE"	"Types__SDVR_DRV_ERR_BOARD_CLOSE"
"Typedef"	"SDVR_DRV_ERR_BOARD_RESET"	"Types__SDVR_DRV_ERR_BOARD_RESET"
"Typedef"	"SDVR_DRV_ERR_IPC_INIT"	"Types__SDVR_DRV_ERR_IPC_INIT"
"Typedef"	"SDVR_DRV_ERR_NO_CHANNELS"	"Types__SDVR_DRV_ERR_NO_CHANNELS"
"Typedef"	"SDVR_DRV_ERR_CHANNEL_IN_USE"	"Types__SDVR_DRV_ERR_CHANNEL_IN_USE"
"Typedef"	"SDVR_DRV_ERR_CHANNEL_CREATE"	"Types__SDVR_DRV_ERR_CHANNEL_CREATE"
"Typedef"	"SDVR_DRV_ERR_CHANNEL_CONNECT"	"Types__SDVR_DRV_ERR_CHANNEL_CONNECT"
"Typedef"	"SDVR_DRV_ERR_CHANNEL_CLOSE"	"Types__SDVR_DRV_ERR_CHANNEL_CLOSE"
"Typedef"	"SDVR_DRV_ERR_CHANNEL_NOT_ACTIVE"	"Types__SDVR_DRV_ERR_CHANNEL_NOT_ACTIVE"
"Typedef"	"SDVR_DRV_ERR_CHANNEL_DEAD"	"Types__SDVR_DRV_ERR_CHANNEL_DEAD"
"Typedef"	"SDVR_DRV_ERR_NO_RECV_BUFFERS"	"Types__SDVR_DRV_ERR_NO_RECV_BUFFERS"
"Typedef"	"SDVR_DRV_ERR_NO_SEND_BUFFERS"	"Types__SDVR_DRV_ERR_NO_SEND_BUFFERS"
"Typedef"	"SDVR_DRV_ERR_MSG_SEND"	"Types__SDVR_DRV_ERR_MSG_SEND"
"Typedef"	"SDVR_DRV_BOARD_BOOT_FAIL"	"Types__SDVR_DRV_BOARD_BOOT_FAIL"
"Typedef"	"SDVR_ERR_OUT_OF_MEMORY"	"Types__SDVR_ERR_OUT_OF_MEMORY"
"Typedef"	"SDVR_ERR_INVALID_HANDLE"	"Types__SDVR_ERR_INVALID_HANDLE"
"Typedef"	"SDVR_ERR_INVALID_ARG"	"Types__SDVR_ERR_INVALID_ARG"
"Typedef"	"SDVR_ERR_INVALID_BOARD"	"Types__SDVR_ERR_INVALID_BOARD"
"Typedef"	"SDVR_ERR_BOARD_CONNECTED"	"Types__SDVR_ERR_BOARD_CONNECTED"
"Typedef"	"SDVR_ERR_INVALID_CHANNEL"	"Types__SDVR_ERR_INVALID_CHANNEL"
"Typedef"	"SDVR_ERR_CHANNEL_CLOSED"	"Types__SDVR_ERR_CHANNEL_CLOSED"
"Typedef"	"SDVR_ERR_BOARD_CLOSED"	"Types__SDVR_ERR_BOARD_CLOSED"
"Typedef"	"SDVR_ERR_NO_VFRAME"	"Types__SDVR_ERR_NO_VFRAME"
"Typedef"	"SDVR_ERR_NO_AFRAME"	"Types__SDVR_ERR_NO_AFRAME"
"Typedef"	"SDVR_ERR_INTERNAL"	"Types__SDVR_ERR_INTERNAL"
"Typedef"	"SDVR_ERR_BOARD_NOT_CONNECTED"	"Types__SDVR_ERR_BOARD_NOT_CONNECTED"
"Typedef"	"SDVR_ERR_IN_STREAMING"	"Types__SDVR_ERR_IN_STREAMING"
"Typedef"	"SDVR_ERR_NO_DVR_BOARD"	"Types__SDVR_ERR_NO_DVR_BOARD"
"Typedef"	"SDVR_ERR_WRONG_DRIVER_VERSION"	"Types__SDVR_ERR_WRONG_DRIVER_VERSION"
"Typedef"	"SDVR_ERR_DBG_FILE"	"Types__SDVR_ERR_DBG_FILE"
"Typedef"	"SDVR_ERR_ENCODER_NOT_ENABLED"	"Types__SDVR_ERR_ENCODER_NOT_ENABLED"
"Typedef"	"SDVR_ERR_ENCODER_NOT_DISABLED"	"Types__SDVR_ERR_ENCODER_NOT_DISABLED"
"Typedef"	"SDVR_ERR_SDK_NO_FRAME_BUF"	"Types__SDVR_ERR_SDK_NO_FRAME_BUF"
"Typedef"	"SDVR_ERR_INVALID_FRAME_TYPE"	"Types__SDVR_ERR_INVALID_FRAME_TYPE"
"Typedef"	"SDVR_ERR_NOBUF"	"Types__SDVR_ERR_NOBUF"
"Typedef"	"SDVR_ERR_CALLBACK_FAILED"	"Types__SDVR_ERR_CALLBACK_FAILED"
"Typedef"	"SDVR_ERR_INVALID_CHAN_HANDLE"	"Types__SDVR_ERR_INVALID_CHAN_HANDLE"
"Typedef"	"SDVR_ERR_COMMAND_NOT_SUPPORTED"	"Types__SDVR_ERR_COMMAND_NOT_SUPPORTED"
"Typedef"	"SDVR_ERR_ODD_SMO_COORDINATES"	"Types__SDVR_ERR_ODD_SMO_COORDINATES"
"Typedef"	"SDVR_ERR_LOAD_FIRMWARE"	"Types__SDVR_ERR_LOAD_FIRMWARE"
"Typedef"	"SDVR_ERR_WRONG_CHANNEL_TYPE"	"Types__SDVR_ERR_WRONG_CHANNEL_TYPE"
"Typedef"	"SDVR_ERR_DECODER_NOT_ENABLED"	"Types__SDVR_ERR_DECODER_NOT_ENABLED"
"Typedef"	"SDVR_ERR_BUF_NOT_AVAIL"	"Types__SDVR_ERR_BUF_NOT_AVAIL"
"Typedef"	"SDVR_ERR_MAX_REGIONS"	"Types__SDVR_ERR_MAX_REGIONS"
"Typedef"	"SDVR_ERR_INVALID_REGION"	"Types__SDVR_ERR_INVALID_REGION"
"Typedef"	"SDVR_ERR_INVALID_GOP"	"Types__SDVR_ERR_INVALID_GOP"
"Typedef"	"SDVR_ERR_INVALID_BITRATE"	"Types__SDVR_ERR_INVALID_BITRATE"
"Typedef"	"SDVR_ERR_INVALID_BITRATE_CONTROL"	"Types__SDVR_ERR_INVALID_BITRATE_CONTROL"
"Typedef"	"SDVR_ERR_INVALID_QUALITY"	"Types__SDVR_ERR_INVALID_QUALITY"
"Typedef"	"SDVR_ERR_INVALID_FPS"	"Types__SDVR_ERR_INVALID_FPS"
"Typedef"	"SDVR_ERR_UNSUPPORTED_FIRMWARE"	"Types__SDVR_ERR_UNSUPPORTED_FIRMWARE"
"Typedef"	"SDVR_ERR_INVALID_OSD_ID"	"Types__SDVR_ERR_INVALID_OSD_ID"
"Typedef"	"SDVR_ERR_OSD_LENGTH"	"Types__SDVR_ERR_OSD_LENGTH"
"Typedef"	"SDVR_ERR_OSD_FONT_FILE"	"Types__SDVR_ERR_OSD_FONT_FILE"
"Typedef"	"SDVR_ERR_FONT_ID"	"Types__SDVR_ERR_FONT_ID"
"Typedef"	"SDVR_ERR_CAMERA_IN_REC"	"Types__SDVR_ERR_CAMERA_IN_REC"
"Typedef"	"SDVR_ERR_OPEN_REC_FILE"	"Types__SDVR_ERR_OPEN_REC_FILE"
"Typedef"	"SDVR_ERR_FAILED_ADD_VIDEO_TRACK"	"Types__SDVR_ERR_FAILED_ADD_VIDEO_TRACK"
"Typedef"	"SDVR_ERR_FAILED_ADD_AUDIO_TRACK"	"Types__SDVR_ERR_FAILED_ADD_AUDIO_TRACK"
"Typedef"	"SDVR_ERR_SDK_BUF_EXCEEDED"	"Types__SDVR_ERR_SDK_BUF_EXCEEDED"
"Typedef"	"SDVR_ERR_AUTH_KEY_MISSING"	"Types__SDVR_ERR_AUTH_KEY_MISSING"
"Typedef"	"SDVR_ERR_AUTH_KEY_LEN"	"Types__SDVR_ERR_AUTH_KEY_LEN"
"Typedef"	"SDVR_ERR_INVALID_RESOLUTION"	"Types__SDVR_ERR_INVALID_RESOLUTION"
"Typedef"	"SDVR_ERR_SMO_PORT_NUM"	"Types__SDVR_ERR_SMO_PORT_NUM"
"Typedef"	"sdvr_diag_code_e"	"Types__sdvr_diag_code_e"
"Typedef"	"SDVR_DIAG_OK"	"Types__SDVR_DIAG_OK"
"Typedef"	"SDVR_DIAG_DDR_WRITEREAD_FAIL"	"Types__SDVR_DIAG_DDR_WRITEREAD_FAIL"
"Typedef"	"SDVR_DIAG_DDR_ADDRLINES_FAIL"	"Types__SDVR_DIAG_DDR_ADDRLINES_FAIL"
"Typedef"	"SDVR_DIAG_DDR_BITFLIP_FAIL"	"Types__SDVR_DIAG_DDR_BITFLIP_FAIL"
"Typedef"	"SDVR_DIAG_DDR_DMA_FAIL"	"Types__SDVR_DIAG_DDR_DMA_FAIL"
"Typedef"	"SDVR_DIAG_DDR_READ_DMA_FAIL"	"Types__SDVR_DIAG_DDR_READ_DMA_FAIL"
"Typedef"	"SDVR_DIAG_PLL_TEST_MHZ"	"Types__SDVR_DIAG_PLL_TEST_MHZ"
"Typedef"	"SDVR_DIAG_PLL_TEST_SYS"	"Types__SDVR_DIAG_PLL_TEST_SYS"
"Typedef"	"SDVR_DIAG_PLL_TEST_IO"	"Types__SDVR_DIAG_PLL_TEST_IO"
"Typedef"	"SDVR_DIAG_PLL_TEST_AIM"	"Types__SDVR_DIAG_PLL_TEST_AIM"
"Typedef"	"SDVR_DIAG_PLL_TEST_DP0"	"Types__SDVR_DIAG_PLL_TEST_DP0"
"Typedef"	"SDVR_DIAG_PLL_TEST_DP2"	"Types__SDVR_DIAG_PLL_TEST_DP2"
"Typedef"	"SDVR_DIAG_PLL_TEST_DDR"	"Types__SDVR_DIAG_PLL_TEST_DDR"
"Typedef"	"SDVR_DIAG_SPI_TEST_READ"	"Types__SDVR_DIAG_SPI_TEST_READ"
"Typedef"	"SDVR_DIAG_SPI_TEST_ERASE"	"Types__SDVR_DIAG_SPI_TEST_ERASE"
"Typedef"	"SDVR_DIAG_SPI_TEST_PROG"	"Types__SDVR_DIAG_SPI_TEST_PROG"
"Typedef"	"SDVR_DIAG_SPI_TEST_UNLOCK"	"Types__SDVR_DIAG_SPI_TEST_UNLOCK"
"Typedef"	"SDVR_DIAG_SPI_TEST_COMPARE"	"Types__SDVR_DIAG_SPI_TEST_COMPARE"
"Typedef"	"SDVR_DIAG_SPI_TEST_MAINT"	"Types__SDVR_DIAG_SPI_TEST_MAINT"
"Typedef"	"SDVR_DIAG_SPI_TEST_MISC"	"Types__SDVR_DIAG_SPI_TEST_MISC"
"Typedef"	"SDVR_DIAG_TWI_EEPROM_TEST_READ"	"Types__SDVR_DIAG_TWI_EEPROM_TEST_READ"
"Typedef"	"SDVR_DIAG_TWI_EEPROM_TEST_WRITE"	"Types__SDVR_DIAG_TWI_EEPROM_TEST_WRITE"
"Typedef"	"SDVR_DIAG_TWI_EEPROM_TEST_INIT"	"Types__SDVR_DIAG_TWI_EEPROM_TEST_INIT"
"Typedef"	"SDVR_DIAG_TWI_EEPROM_TEST_COMPARE"	"Types__SDVR_DIAG_TWI_EEPROM_TEST_COMPARE"
"Typedef"	"SDVR_DIAG_TWI_EEPROM_TEST_WP_COMPARE"	"Types__SDVR_DIAG_TWI_EEPROM_TEST_WP_COMPARE"
"Typedef"	"SDVR_DIAG_EPSON_REG_TEST_INIT"	"Types__SDVR_DIAG_EPSON_REG_TEST_INIT"
"Typedef"	"SDVR_DIAG_EPSON_REG_TEST_WALKING"	"Types__SDVR_DIAG_EPSON_REG_TEST_WALKING"
"Typedef"	"SDVR_DIAG_DECODER_AUDIO_TEST_INIT"	"Types__SDVR_DIAG_DECODER_AUDIO_TEST_INIT"
"Typedef"	"SDVR_DIAG_DECODER_AUDIO_TEST_NO_AUDIO"	"Types__SDVR_DIAG_DECODER_AUDIO_TEST_NO_AUDIO"
"Typedef"	"SDVR_DIAG_TW2815_REG_TEST"	"Types__SDVR_DIAG_TW2815_REG_TEST"
"Typedef"	"SDVR_DIAG_TW2864_REG_TEST"	"Types__SDVR_DIAG_TW2864_REG_TEST"
"Typedef"	"SDVR_DIAG_DECODER_VIDEO_TEST_INIT"	"Types__SDVR_DIAG_DECODER_VIDEO_TEST_INIT"
"Typedef"	"SDVR_DIAG_DECODER_VIDEO_TEST_NO_VIDEO"	"Types__SDVR_DIAG_DECODER_VIDEO_TEST_NO_VIDEO"
"Typedef"	"SDVR_DIAG_DECODER_VIDEO_TEST_TIMEOUT"	"Types__SDVR_DIAG_DECODER_VIDEO_TEST_TIMEOUT"
"Typedef"	"SDVR_DIAG_DECODER_VIDDET_TEST_INIT_ERR"	"Types__SDVR_DIAG_DECODER_VIDDET_TEST_INIT_ERR"
"Typedef"	"SDVR_DIAG_DECODER_VIDDET_TEST_UNKNOWN_CHIP"	"Types__SDVR_DIAG_DECODER_VIDDET_TEST_UNKNOWN_CHIP"
"Typedef"	"SDVR_DIAG_DECODER_VIDDET_TEST_NO_INPUT_ERR"	"Types__SDVR_DIAG_DECODER_VIDDET_TEST_NO_INPUT_ERR"
"Typedef"	"SDVR_DIAG_DECODER_VIDDET_TEST_CONFLICT_ERR"	"Types__SDVR_DIAG_DECODER_VIDDET_TEST_CONFLICT_ERR"
"Typedef"	"SDVR_DIAG_DECODER_VIDDET_TEST_NO_SYNC_ERR"	"Types__SDVR_DIAG_DECODER_VIDDET_TEST_NO_SYNC_ERR"
"Typedef"	"SDVR_DIAG_DECODER_AUDDET_TEST_NO_SYNC_ERR"	"Types__SDVR_DIAG_DECODER_AUDDET_TEST_NO_SYNC_ERR"
"Typedef"	"SDVR_DIAG_DECODER_UNIQUE_VIDEO_TEST"	"Types__SDVR_DIAG_DECODER_UNIQUE_VIDEO_TEST"
"Typedef"	"SDVR_DIAG_NVP1104_REG_TEST"	"Types__SDVR_DIAG_NVP1104_REG_TEST"
"Typedef"	"SDVR_DIAG_NVP1114_REG_TEST"	"Types__SDVR_DIAG_NVP1114_REG_TEST"
"Typedef"	"SDVR_DIAG_DECODER_AUDIO_TEST_TIMEOUT"	"Types__SDVR_DIAG_DECODER_AUDIO_TEST_TIMEOUT"
"Typedef"	"SDVR_DIAG_PCIE_EYEMASK_TEST_NO_CBB"	"Types__SDVR_DIAG_PCIE_EYEMASK_TEST_NO_CBB"
"Typedef"	"SDVR_DIAG_PCIE_EYEMASK_TEST_ERR"	"Types__SDVR_DIAG_PCIE_EYEMASK_TEST_ERR"
"Typedef"	"SDVR_DIAG_PCIE_EYEMASK_TEST_TIMEOUT"	"Types__SDVR_DIAG_PCIE_EYEMASK_TEST_TIMEOUT"
"Typedef"	"sdvr_chan_handle_t"	"Types__sdvr_chan_handle_t"
"Typedef"	"sdvr_signals_type_e"	"Types__sdvr_signals_type_e"
"Typedef"	"__sdvr_signals_type_e"	"Types____sdvr_signals_type_e"
"Typedef"	"SDVR_SIGNAL_RUNTIME_ERROR"	"Types__SDVR_SIGNAL_RUNTIME_ERROR"
"Typedef"	"SDVR_SIGNAL_FATAL_ERROR"	"Types__SDVR_SIGNAL_FATAL_ERROR"
"Typedef"	"sdvr_video_alarm_e"	"Types__sdvr_video_alarm_e"
"Typedef"	"SDVR_VIDEO_ALARM_NONE"	"Types__SDVR_VIDEO_ALARM_NONE"
"Typedef"	"SDVR_VIDEO_ALARM_MOTION"	"Types__SDVR_VIDEO_ALARM_MOTION"
"Typedef"	"SDVR_VIDEO_ALARM_BLIND"	"Types__SDVR_VIDEO_ALARM_BLIND"
"Typedef"	"SDVR_VIDEO_ALARM_NIGHT"	"Types__SDVR_VIDEO_ALARM_NIGHT"
"Typedef"	"SDVR_VIDEO_ALARM_LOSS"	"Types__SDVR_VIDEO_ALARM_LOSS"
"Typedef"	"SDVR_VIDEO_ALARM_DETECTED"	"Types__SDVR_VIDEO_ALARM_DETECTED"
"Typedef"	"sdvr_regions_type_e"	"Types__sdvr_regions_type_e"
"Typedef"	"SDVR_REGION_MOTION"	"Types__SDVR_REGION_MOTION"
"Typedef"	"SDVR_REGION_BLIND"	"Types__SDVR_REGION_BLIND"
"Typedef"	"SDVR_REGION_PRIVACY"	"Types__SDVR_REGION_PRIVACY"
"Typedef"	"__sdvr_frame_type_e"	"Types____sdvr_frame_type_e"
"Typedef"	"SDVR_FRAME_RAW_AUDIO"	"Types__SDVR_FRAME_RAW_AUDIO"
"Typedef"	"SDVR_FRAME_H264_IDR"	"Types__SDVR_FRAME_H264_IDR"
"Typedef"	"SDVR_FRAME_H264_I"	"Types__SDVR_FRAME_H264_I"
"Typedef"	"SDVR_FRAME_H264_P"	"Types__SDVR_FRAME_H264_P"
"Typedef"	"SDVR_FRAME_H264_B"	"Types__SDVR_FRAME_H264_B"
"Typedef"	"SDVR_FRAME_H264_SPS"	"Types__SDVR_FRAME_H264_SPS"
"Typedef"	"SDVR_FRAME_H264_PPS"	"Types__SDVR_FRAME_H264_PPS"
"Typedef"	"SDVR_FRAME_JPEG"	"Types__SDVR_FRAME_JPEG"
"Typedef"	"SDVR_FRAME_G711"	"Types__SDVR_FRAME_G711"
"Typedef"	"SDVR_FRAME_MPEG4_I"	"Types__SDVR_FRAME_MPEG4_I"
"Typedef"	"SDVR_FRAME_MPEG4_P"	"Types__SDVR_FRAME_MPEG4_P"
"Typedef"	"SDVR_FRAME_MPEG4_B"	"Types__SDVR_FRAME_MPEG4_B"
"Typedef"	"SDVR_FRAME_MPEG4_VOL"	"Types__SDVR_FRAME_MPEG4_VOL"
"Typedef"	"SDVR_FRAME_MOTION_VALUES"	"Types__SDVR_FRAME_MOTION_VALUES"
"Typedef"	"SDVR_FRAME_RAW_VIDEO"	"Types__SDVR_FRAME_RAW_VIDEO"
"Typedef"	"SDVR_FRAME_VIDEO_ENCODED_PRIMARY"	"Types__SDVR_FRAME_VIDEO_ENCODED_PRIMARY"
"Typedef"	"SDVR_FRAME_VIDEO_ENCODED_SECONDARY"	"Types__SDVR_FRAME_VIDEO_ENCODED_SECONDARY"
"Typedef"	"SDVR_FRAME_AUDIO_ENCODED"	"Types__SDVR_FRAME_AUDIO_ENCODED"
"Typedef"	"sdvr_frame_type_e"	"Types__sdvr_frame_type_e"
"Typedef"	"sdvr_location_e"	"Types__sdvr_location_e"
"Typedef"	"SDVR_LOC_TOP_LEFT"	"Types__SDVR_LOC_TOP_LEFT"
"Typedef"	"SDVR_LOC_BOTTOM_LEFT"	"Types__SDVR_LOC_BOTTOM_LEFT"
"Typedef"	"SDVR_LOC_TOP_RIGHT"	"Types__SDVR_LOC_TOP_RIGHT"
"Typedef"	"SDVR_LOC_BOTTOM_RIGHT"	"Types__SDVR_LOC_BOTTOM_RIGHT"
"Typedef"	"SDVR_LOC_CUSTOM"	"Types__SDVR_LOC_CUSTOM"
"Typedef"	"sdvr_video_std_e"	"Types__sdvr_video_std_e"
"Typedef"	"SDVR_VIDEO_STD_NONE"	"Types__SDVR_VIDEO_STD_NONE"
"Typedef"	"SDVR_VIDEO_STD_D1_PAL"	"Types__SDVR_VIDEO_STD_D1_PAL"
"Typedef"	"SDVR_VIDEO_STD_D1_NTSC"	"Types__SDVR_VIDEO_STD_D1_NTSC"
"Typedef"	"SDVR_VIDEO_STD_CIF_PAL"	"Types__SDVR_VIDEO_STD_CIF_PAL"
"Typedef"	"SDVR_VIDEO_STD_CIF_NTSC"	"Types__SDVR_VIDEO_STD_CIF_NTSC"
"Typedef"	"SDVR_VIDEO_STD_2CIF_PAL"	"Types__SDVR_VIDEO_STD_2CIF_PAL"
"Typedef"	"SDVR_VIDEO_STD_2CIF_NTSC"	"Types__SDVR_VIDEO_STD_2CIF_NTSC"
"Typedef"	"SDVR_VIDEO_STD_4CIF_PAL"	"Types__SDVR_VIDEO_STD_4CIF_PAL"
"Typedef"	"SDVR_VIDEO_STD_4CIF_NTSC"	"Types__SDVR_VIDEO_STD_4CIF_NTSC"
"Typedef"	"SDVR_VIDEO_STD_QCIF_PAL"	"Types__SDVR_VIDEO_STD_QCIF_PAL"
"Typedef"	"SDVR_VIDEO_STD_QCIF_NTSC"	"Types__SDVR_VIDEO_STD_QCIF_NTSC"
"Typedef"	"sdvr_video_size_e"	"Types__sdvr_video_size_e"
"Typedef"	"SDVR_VIDEO_SIZE_720x576"	"Types__SDVR_VIDEO_SIZE_720x576"
"Typedef"	"SDVR_VIDEO_SIZE_720x480"	"Types__SDVR_VIDEO_SIZE_720x480"
"Typedef"	"SDVR_VIDEO_SIZE_352x288"	"Types__SDVR_VIDEO_SIZE_352x288"
"Typedef"	"SDVR_VIDEO_SIZE_352x240"	"Types__SDVR_VIDEO_SIZE_352x240"
"Typedef"	"SDVR_VIDEO_SIZE_704x288"	"Types__SDVR_VIDEO_SIZE_704x288"
"Typedef"	"SDVR_VIDEO_SIZE_704x240"	"Types__SDVR_VIDEO_SIZE_704x240"
"Typedef"	"SDVR_VIDEO_SIZE_704x576"	"Types__SDVR_VIDEO_SIZE_704x576"
"Typedef"	"SDVR_VIDEO_SIZE_704x480"	"Types__SDVR_VIDEO_SIZE_704x480"
"Typedef"	"SDVR_VIDEO_SIZE_176x144"	"Types__SDVR_VIDEO_SIZE_176x144"
"Typedef"	"SDVR_VIDEO_SIZE_176x112"	"Types__SDVR_VIDEO_SIZE_176x112"
"Typedef"	"SDVR_VIDEO_SIZE_528x320"	"Types__SDVR_VIDEO_SIZE_528x320"
"Typedef"	"SDVR_VIDEO_SIZE_528x384"	"Types__SDVR_VIDEO_SIZE_528x384"
"Typedef"	"SDVR_VIDEO_SIZE_720x288"	"Types__SDVR_VIDEO_SIZE_720x288"
"Typedef"	"SDVR_VIDEO_SIZE_720x240"	"Types__SDVR_VIDEO_SIZE_720x240"
"Typedef"	"sdvr_chan_type_e"	"Types__sdvr_chan_type_e"
"Typedef"	"__sdvr_chan_type_e"	"Types____sdvr_chan_type_e"
"Typedef"	"SDVR_CHAN_TYPE_NONE"	"Types__SDVR_CHAN_TYPE_NONE"
"Typedef"	"SDVR_CHAN_TYPE_ENCODER"	"Types__SDVR_CHAN_TYPE_ENCODER"
"Typedef"	"SDVR_CHAN_TYPE_DECODER"	"Types__SDVR_CHAN_TYPE_DECODER"
"Typedef"	"SDVR_CHAN_TYPE_OUTPUT"	"Types__SDVR_CHAN_TYPE_OUTPUT"
"Typedef"	"sdvr_vpp_mode_e"	"Types__sdvr_vpp_mode_e"
"Typedef"	"_sdvr_vpp_mode_e"	"Types___sdvr_vpp_mode_e"
"Typedef"	"SDVR_VPP_MODE_SLATERAL"	"Types__SDVR_VPP_MODE_SLATERAL"
"Typedef"	"SDVR_VPP_MODE_ANALYTICS"	"Types__SDVR_VPP_MODE_ANALYTICS"
"Typedef"	"sdvr_sub_encoders_e"	"Types__sdvr_sub_encoders_e"
"Typedef"	"SDVR_ENC_PRIMARY"	"Types__SDVR_ENC_PRIMARY"
"Typedef"	"SDVR_ENC_SECONDARY"	"Types__SDVR_ENC_SECONDARY"
"Typedef"	"sdvr_venc_e"	"Types__sdvr_venc_e"
"Typedef"	"SDVR_VIDEO_ENC_NONE"	"Types__SDVR_VIDEO_ENC_NONE"
"Typedef"	"SDVR_VIDEO_ENC_H264"	"Types__SDVR_VIDEO_ENC_H264"
"Typedef"	"SDVR_VIDEO_ENC_JPEG"	"Types__SDVR_VIDEO_ENC_JPEG"
"Typedef"	"SDVR_VIDEO_ENC_MPEG4"	"Types__SDVR_VIDEO_ENC_MPEG4"
"Typedef"	"sdvr_aenc_e"	"Types__sdvr_aenc_e"
"Typedef"	"SDVR_AUDIO_ENC_NONE"	"Types__SDVR_AUDIO_ENC_NONE"
"Typedef"	"SDVR_AUDIO_ENC_G711"	"Types__SDVR_AUDIO_ENC_G711"
"Typedef"	"SDVR_AUDIO_ENC_G726_16K"	"Types__SDVR_AUDIO_ENC_G726_16K"
"Typedef"	"SDVR_AUDIO_ENC_G726_24K"	"Types__SDVR_AUDIO_ENC_G726_24K"
"Typedef"	"SDVR_AUDIO_ENC_G726_32K"	"Types__SDVR_AUDIO_ENC_G726_32K"
"Typedef"	"SDVR_AUDIO_ENC_G726_48K"	"Types__SDVR_AUDIO_ENC_G726_48K"
"Typedef"	"sdvr_video_res_decimation_e"	"Types__sdvr_video_res_decimation_e"
"Typedef"	"SDVR_VIDEO_RES_DECIMATION_NONE"	"Types__SDVR_VIDEO_RES_DECIMATION_NONE"
"Typedef"	"SDVR_VIDEO_RES_DECIMATION_EQUAL"	"Types__SDVR_VIDEO_RES_DECIMATION_EQUAL"
"Typedef"	"SDVR_VIDEO_RES_DECIMATION_CIF"	"Types__SDVR_VIDEO_RES_DECIMATION_CIF"
"Typedef"	"SDVR_VIDEO_RES_DECIMATION_FOURTH"	"Types__SDVR_VIDEO_RES_DECIMATION_FOURTH"
"Typedef"	"SDVR_VIDEO_RES_DECIMATION_QCIF"	"Types__SDVR_VIDEO_RES_DECIMATION_QCIF"
"Typedef"	"SDVR_VIDEO_RES_DECIMATION_SIXTEENTH"	"Types__SDVR_VIDEO_RES_DECIMATION_SIXTEENTH"
"Typedef"	"SDVR_VIDEO_RES_DECIMATION_HALF"	"Types__SDVR_VIDEO_RES_DECIMATION_HALF"
"Typedef"	"SDVR_VIDEO_RES_DECIMATION_DCIF"	"Types__SDVR_VIDEO_RES_DECIMATION_DCIF"
"Typedef"	"SDVR_VIDEO_RES_DECIMATION_CLASSIC_CIF"	"Types__SDVR_VIDEO_RES_DECIMATION_CLASSIC_CIF"
"Typedef"	"SDVR_VIDEO_RES_DECIMATION_CLASSIC_2CIF"	"Types__SDVR_VIDEO_RES_DECIMATION_CLASSIC_2CIF"
"Typedef"	"SDVR_VIDEO_RES_DECIMATION_CLASSIC_4CIF"	"Types__SDVR_VIDEO_RES_DECIMATION_CLASSIC_4CIF"
"Typedef"	"sdvr_br_control_e"	"Types__sdvr_br_control_e"
"Typedef"	"SDVR_BITRATE_CONTROL_NONE"	"Types__SDVR_BITRATE_CONTROL_NONE"
"Typedef"	"SDVR_BITRATE_CONTROL_VBR"	"Types__SDVR_BITRATE_CONTROL_VBR"
"Typedef"	"SDVR_BITRATE_CONTROL_CBR"	"Types__SDVR_BITRATE_CONTROL_CBR"
"Typedef"	"SDVR_BITRATE_CONTROL_CQP"	"Types__SDVR_BITRATE_CONTROL_CQP"
"Typedef"	"SDVR_BITRATE_CONTROL_CONSTANT_QUALITY"	"Types__SDVR_BITRATE_CONTROL_CONSTANT_QUALITY"
"Typedef"	"sdvr_dts_style_e"	"Types__sdvr_dts_style_e"
"Typedef"	"SDVR_OSD_DTS_NONE"	"Types__SDVR_OSD_DTS_NONE"
"Typedef"	"SDVR_OSD_DTS_DEBUG"	"Types__SDVR_OSD_DTS_DEBUG"
"Typedef"	"SDVR_OSD_DTS_MDY_12H"	"Types__SDVR_OSD_DTS_MDY_12H"
"Typedef"	"SDVR_OSD_DTS_DMY_12H"	"Types__SDVR_OSD_DTS_DMY_12H"
"Typedef"	"SDVR_OSD_DTS_YMD_12H"	"Types__SDVR_OSD_DTS_YMD_12H"
"Typedef"	"SDVR_OSD_DTS_MDY_24H"	"Types__SDVR_OSD_DTS_MDY_24H"
"Typedef"	"SDVR_OSD_DTS_DMY_24H"	"Types__SDVR_OSD_DTS_DMY_24H"
"Typedef"	"SDVR_OSD_DTS_YMD_24H"	"Types__SDVR_OSD_DTS_YMD_24H"
"Typedef"	"sdvr_chip_rev_e"	"Types__sdvr_chip_rev_e"
"Typedef"	"SDVR_CHIP_S6100_3_REV_C"	"Types__SDVR_CHIP_S6100_3_REV_C"
"Typedef"	"SDVR_CHIP_S6105_3_REV_C"	"Types__SDVR_CHIP_S6105_3_REV_C"
"Typedef"	"SDVR_CHIP_S6106_3_REV_C"	"Types__SDVR_CHIP_S6106_3_REV_C"
"Typedef"	"SDVR_CHIP_S6100_3_REV_D"	"Types__SDVR_CHIP_S6100_3_REV_D"
"Typedef"	"SDVR_CHIP_S6105_3_REV_D"	"Types__SDVR_CHIP_S6105_3_REV_D"
"Typedef"	"SDVR_CHIP_S6106_3_REV_D"	"Types__SDVR_CHIP_S6106_3_REV_D"
"Typedef"	"SDVR_CHIP_S6100_3_REV_F"	"Types__SDVR_CHIP_S6100_3_REV_F"
"Typedef"	"SDVR_CHIP_S6105_3_REV_F"	"Types__SDVR_CHIP_S6105_3_REV_F"
"Typedef"	"SDVR_CHIP_S6106_3_REV_F"	"Types__SDVR_CHIP_S6106_3_REV_F"
"Typedef"	"SDVR_CHIP_S6100_3_UNKNOWN"	"Types__SDVR_CHIP_S6100_3_UNKNOWN"
"Typedef"	"SDVR_CHIP_S6105_3_UNKNOWN"	"Types__SDVR_CHIP_S6105_3_UNKNOWN"
"Typedef"	"SDVR_CHIP_S6106_3_UNKNOWN"	"Types__SDVR_CHIP_S6106_3_UNKNOWN"
"Typedef"	"SDVR_CHIP_UNKNOWN"	"Types__SDVR_CHIP_UNKNOWN"
"Typedef"	"sdvr_board_attrib_t"	"Types__sdvr_board_attrib_t"
"Typedef"	"sdvr_pci_attrib_t"	"Types__sdvr_pci_attrib_t"
"Typedef"	"sdvr_sdk_params_t"	"Types__sdvr_sdk_params_t"
"Typedef"	"sdvr_board_config_t"	"Types__sdvr_board_config_t"
"Typedef"	"sdvr_firmware_ver_t"	"Types__sdvr_firmware_ver_t"
"Typedef"	"sdvr_signal_info_t"	"Types__sdvr_signal_info_t"
"Typedef"	"sdvr_term_e"	"Types__sdvr_term_e"
"Typedef"	"SDVR_TERM_75OHM"	"Types__SDVR_TERM_75OHM"
"Typedef"	"SDVR_TERM_HIGH_IMPEDANCE"	"Types__SDVR_TERM_HIGH_IMPEDANCE"
"Typedef"	"sdvr_led_type_e"	"Types__sdvr_led_type_e"
"Typedef"	"SDVR_LED_TYPE_RECORD"	"Types__SDVR_LED_TYPE_RECORD"
"Typedef"	"SDVR_LED_TYPE_ALARM"	"Types__SDVR_LED_TYPE_ALARM"
"Typedef"	"sdvr_chan_def_t"	"Types__sdvr_chan_def_t"
"Typedef"	"sdvr_image_ctrl_t"	"Types__sdvr_image_ctrl_t"
"Typedef"	"sdvr_video_enc_chan_params_t"	"Types__sdvr_video_enc_chan_params_t"
"Typedef"	"sdvr_alarm_video_enc_params_t"	"Types__sdvr_alarm_video_enc_params_t"
"Typedef"	"sdvr_audio_enc_chan_params_t"	"Types__sdvr_audio_enc_chan_params_t"
"Typedef"	"sdvr_mb_region_t"	"Types__sdvr_mb_region_t"
"Typedef"	"sdvr_region_t"	"Types__sdvr_region_t"
"Typedef"	"sdvr_motion_detection_t"	"Types__sdvr_motion_detection_t"
"Typedef"	"sdvr_blind_detection_t"	"Types__sdvr_blind_detection_t"
"Typedef"	"sdvr_night_detection_t"	"Types__sdvr_night_detection_t"
"Typedef"	"sdvr_privacy_region_t"	"Types__sdvr_privacy_region_t"
"Typedef"	"sdvr_av_buffer_t"	"Types__sdvr_av_buffer_t"
"Typedef"	"sdvr_rawv_formats_e"	"Types__sdvr_rawv_formats_e"
"Typedef"	"SDVR_RAWV_FORMAT_YUV_4_2_0"	"Types__SDVR_RAWV_FORMAT_YUV_4_2_0"
"Typedef"	"SDVR_RAWV_FORMAT_YUV_4_2_2"	"Types__SDVR_RAWV_FORMAT_YUV_4_2_2"
"Typedef"	"SDVR_RAWV_FORMAT_YVU_4_2_0"	"Types__SDVR_RAWV_FORMAT_YVU_4_2_0"
"Typedef"	"sdvr_yuv_buffer_t"	"Types__sdvr_yuv_buffer_t"
"Typedef"	"sdvr_osd_text_config_t"	"Types__sdvr_osd_text_config_t"
"Typedef"	"sdvr_osd_config_ex_t"	"Types__sdvr_osd_config_ex_t"
"Typedef"	"sdvr_font_table_t"	"Types__sdvr_font_table_t"
"Typedef"	"sdvr_smo_grid_t"	"Types__sdvr_smo_grid_t"
"Typedef"	"sdvr_smo_capabilities_e"	"Types__sdvr_smo_capabilities_e"
"Typedef"	"SDVR_SMO_CAP_OUTPUT"	"Types__SDVR_SMO_CAP_OUTPUT"
"Typedef"	"SDVR_SMO_CAP_OSD"	"Types__SDVR_SMO_CAP_OSD"
"Typedef"	"SDVR_SMO_CAP_ALPHA_BLENDING"	"Types__SDVR_SMO_CAP_ALPHA_BLENDING"
"Typedef"	"SDVR_SMO_CAP_TILING"	"Types__SDVR_SMO_CAP_TILING"
"Typedef"	"SDVR_SMO_CAP_ANALOG"	"Types__SDVR_SMO_CAP_ANALOG"
"Typedef"	"sdvr_smo_attribute_t"	"Types__sdvr_smo_attribute_t"
"Typedef"	"sdvr_video_alarm_callback"	"Types__sdvr_video_alarm_callback"
"Typedef"	"sdvr_sensor_callback"	"Types__sdvr_sensor_callback"
"Typedef"	"sdvr_av_frame_callback"	"Types__sdvr_av_frame_callback"
"Typedef"	"sdvr_display_debug_callback"	"Types__sdvr_display_debug_callback"
"Typedef"	"sdvr_signals_callback"	"Types__sdvr_signals_callback"
"Typedef"	"sdvr_send_confirmation_callback"	"Types__sdvr_send_confirmation_callback"
"Section"	"Defines"	"Top__Defines"
"Define"	"true"	"Defines__true"
"Define"	"false"	"Defines__false"
"Define"	"SDVR_REGION_MAP_D1_WIDTH"	"Defines__SDVR_REGION_MAP_D1_WIDTH"
"Define"	"SDVR_REGION_MAP_4CIF_WIDTH"	"Defines__SDVR_REGION_MAP_4CIF_WIDTH"
"Define"	"SDVR_REGION_MAP_LINE_NTSC"	"Defines__SDVR_REGION_MAP_LINE_NTSC"
"Define"	"SDVR_REGION_MAP_LINE_PAL"	"Defines__SDVR_REGION_MAP_LINE_PAL"
"Define"	"SDVR_AV_STATE_VIDEO_LOST"	"Defines__SDVR_AV_STATE_VIDEO_LOST"
"Define"	"SDVR_AV_STATE_AUDIO_LOST"	"Defines__SDVR_AV_STATE_AUDIO_LOST"
"Define"	"SDVR_BOARD_SERIAL_LENGTH"	"Defines__SDVR_BOARD_SERIAL_LENGTH"
"Define"	"DEBUG_FLAG_DEBUGGING_ON"	"Defines__DEBUG_FLAG_DEBUGGING_ON"
"Define"	"DEBUG_FLAG_ALL"	"Defines__DEBUG_FLAG_ALL"
"Define"	"DEBUG_FLAG_WRITE_TO_FILE"	"Defines__DEBUG_FLAG_WRITE_TO_FILE"
"Define"	"DEBUG_FLAG_OUTPUT_TO_SCREEN"	"Defines__DEBUG_FLAG_OUTPUT_TO_SCREEN"
"Define"	"DEBUG_FLAG_ENCODER"	"Defines__DEBUG_FLAG_ENCODER"
"Define"	"DEBUG_FLAG_DECODER"	"Defines__DEBUG_FLAG_DECODER"
"Define"	"DEBUG_FLAG_VIDEO_ALARM"	"Defines__DEBUG_FLAG_VIDEO_ALARM"
"Define"	"DEBUG_FLAG_SENSORS_RELAYS"	"Defines__DEBUG_FLAG_SENSORS_RELAYS"
"Define"	"DEBUG_FLAG_AUDIO_OPERATIONS"	"Defines__DEBUG_FLAG_AUDIO_OPERATIONS"
"Define"	"DEBUG_FLAG_DISPLAY_OPERATIONS"	"Defines__DEBUG_FLAG_DISPLAY_OPERATIONS"
"Define"	"DEBUG_FLAG_BOARD"	"Defines__DEBUG_FLAG_BOARD"
"Define"	"DEBUG_FLAG_GENERAL_SDK"	"Defines__DEBUG_FLAG_GENERAL_SDK"
"Define"	"DEBUG_FLAG_SMO"	"Defines__DEBUG_FLAG_SMO"
"Define"	"DEBUG_FLAG_OSD"	"Defines__DEBUG_FLAG_OSD"
"Define"	"DEBUG_FLAG_CHANNEL"	"Defines__DEBUG_FLAG_CHANNEL"
"Define"	"DEBUG_FLAG_VIDEO_FRAME"	"Defines__DEBUG_FLAG_VIDEO_FRAME"
"Define"	"DEBUG_FLAG_FW_WRITE_TO_FILE"	"Defines__DEBUG_FLAG_FW_WRITE_TO_FILE"
"Define"	"DEBUG_FLAG_RECORD_TO_FILE"	"Defines__DEBUG_FLAG_RECORD_TO_FILE"
"Define"	"SDVR_MAX_MD_REGIONS"	"Defines__SDVR_MAX_MD_REGIONS"
"Define"	"SDVR_MAX_BD_REGIONS"	"Defines__SDVR_MAX_BD_REGIONS"
"Define"	"SDVR_MAX_PR_REGIONS"	"Defines__SDVR_MAX_PR_REGIONS"
"Define"	"SDVR_MAX_OSD_TEXT"	"Defines__SDVR_MAX_OSD_TEXT"
"Define"	"SDVR_MAX_OSD_EX_TEXT"	"Defines__SDVR_MAX_OSD_EX_TEXT"
"Define"	"SDVR_MAX_OSD"	"Defines__SDVR_MAX_OSD"
"Define"	"INVALID_CHAN_HANDLE"	"Defines__INVALID_CHAN_HANDLE"
"Define"	"SDVR_ICFLAG_ALL"	"Defines__SDVR_ICFLAG_ALL"
"Define"	"SDVR_ICFLAG_HUE"	"Defines__SDVR_ICFLAG_HUE"
"Define"	"SDVR_ICFLAG_SATURATION"	"Defines__SDVR_ICFLAG_SATURATION"
"Define"	"SDVR_ICFLAG_BRIGHTNESS"	"Defines__SDVR_ICFLAG_BRIGHTNESS"
"Define"	"SDVR_ICFLAG_CONTRAST"	"Defines__SDVR_ICFLAG_CONTRAST"
"Define"	"SDVR_ICFLAG_SHARPNESS"	"Defines__SDVR_ICFLAG_SHARPNESS"
"Define"	"SDVR_DATA_HDR_SIG"	"Defines__SDVR_DATA_HDR_SIG"
"Define"	"SDVR_DATA_HDR_VER"	"Defines__SDVR_DATA_HDR_VER"
"Define"	"SDVR_FT_FONT_ENGLISH"	"Defines__SDVR_FT_FONT_ENGLISH"
"Define"	"SDVR_FT_FORMAT_BDF"	"Defines__SDVR_FT_FORMAT_BDF"
"Define"	"EXTERN"	"Defines__EXTERN"
"Section"	"Routines"	"Top__Routines"
"Section"	"System Set Up, SDK and Board Initialization API"	"Routines__System___Set___Up______SDK___and___Board___Initialization___API"
"Routine"	"sdvr_get_error_text"	"Routines__sdvr_get_error_text"
"Routine"	"sdvr_sdk_init"	"Routines__sdvr_sdk_init"
"Routine"	"sdvr_sdk_close"	"Routines__sdvr_sdk_close"
"Routine"	"sdvr_get_board_count"	"Routines__sdvr_get_board_count"
"Routine"	"sdvr_get_board_attributes"	"Routines__sdvr_get_board_attributes"
"Routine"	"sdvr_get_pci_attrib"	"Routines__sdvr_get_pci_attrib"
"Routine"	"sdvr_board_reset"	"Routines__sdvr_board_reset"
"Routine"	"sdvr_board_connect"	"Routines__sdvr_board_connect"
"Routine"	"sdvr_board_disconnect"	"Routines__sdvr_board_disconnect"
"Routine"	"sdvr_upgrade_firmware"	"Routines__sdvr_upgrade_firmware"
"Routine"	"sdvr_get_sdk_params"	"Routines__sdvr_get_sdk_params"
"Routine"	"sdvr_set_sdk_params"	"Routines__sdvr_set_sdk_params"
"Routine"	"sdvr_get_sdk_version"	"Routines__sdvr_get_sdk_version"
"Routine"	"sdvr_get_driver_version"	"Routines__sdvr_get_driver_version"
"Routine"	"sdvr_get_firmware_version_ex"	"Routines__sdvr_get_firmware_version_ex"
"Routine"	"sdvr_set_sensor_callback"	"Routines__sdvr_set_sensor_callback"
"Routine"	"sdvr_set_video_alarm_callback"	"Routines__sdvr_set_video_alarm_callback"
"Routine"	"sdvr_set_av_frame_callback"	"Routines__sdvr_set_av_frame_callback"
"Routine"	"sdvr_set_display_debug"	"Routines__sdvr_set_display_debug"
"Routine"	"sdvr_set_signals_callback"	"Routines__sdvr_set_signals_callback"
"Routine"	"sdvr_set_confirmation_callback"	"Routines__sdvr_set_confirmation_callback"
"Routine"	"sdvr_get_board_config"	"Routines__sdvr_get_board_config"
"Routine"	"sdvr_get_supported_vstd"	"Routines__sdvr_get_supported_vstd"
"Routine"	"sdvr_get_video_standard"	"Routines__sdvr_get_video_standard"
"Routine"	"sdvr_set_watchdog_state"	"Routines__sdvr_set_watchdog_state"
"Routine"	"sdvr_set_watchdog_state_ex"	"Routines__sdvr_set_watchdog_state_ex"
"Routine"	"sdvr_get_watchdog_state"	"Routines__sdvr_get_watchdog_state"
"Routine"	"sdvr_set_date_time"	"Routines__sdvr_set_date_time"
"Routine"	"sdvr_get_date_time"	"Routines__sdvr_get_date_time"
"Routine"	"sdvr_run_diagnostics"	"Routines__sdvr_run_diagnostics"
"Routine"	"sdvr_get_board_index"	"Routines__sdvr_get_board_index"
"Routine"	"sdvr_get_chan_num"	"Routines__sdvr_get_chan_num"
"Routine"	"sdvr_get_chan_type"	"Routines__sdvr_get_chan_type"
"Routine"	"sdvr_write_ioctl"	"Routines__sdvr_write_ioctl"
"Routine"	"sdvr_read_ioctl"	"Routines__sdvr_read_ioctl"
"Section"	"Channel Set Up API"	"Routines__Channel___Set___Up___API"
"Routine"	"sdvr_create_chan"	"Routines__sdvr_create_chan"
"Routine"	"sdvr_set_channel_default"	"Routines__sdvr_set_channel_default"
"Routine"	"sdvr_destroy_chan"	"Routines__sdvr_destroy_chan"
"Routine"	"sdvr_set_chan_user_data"	"Routines__sdvr_set_chan_user_data"
"Routine"	"sdvr_get_chan_user_data"	"Routines__sdvr_get_chan_user_data"
"Routine"	"sdvr_set_video_encoder_channel_params"	"Routines__sdvr_set_video_encoder_channel_params"
"Routine"	"sdvr_get_video_encoder_channel_params"	"Routines__sdvr_get_video_encoder_channel_params"
"Routine"	"sdvr_set_alarm_video_encoder_params"	"Routines__sdvr_set_alarm_video_encoder_params"
"Routine"	"sdvr_get_alarm_video_encoder_params"	"Routines__sdvr_get_alarm_video_encoder_params"
"Routine"	"sdvr_set_audio_encoder_channel_params"	"Routines__sdvr_set_audio_encoder_channel_params"
"Routine"	"sdvr_get_audio_encoder_channel_params"	"Routines__sdvr_get_audio_encoder_channel_params"
"Section"	"Video Analytics and Privacy Blocking API"	"Routines__Video___Analytics___and___Privacy___Blocking___API"
"Routine"	"sdvr_set_regions_map"	"Routines__sdvr_set_regions_map"
"Routine"	"sdvr_set_regions"	"Routines__sdvr_set_regions"
"Routine"	"sdvr_motion_value_analyzer"	"Routines__sdvr_motion_value_analyzer"
"Routine"	"sdvr_set_motion_value_frequency"	"Routines__sdvr_set_motion_value_frequency"
"Routine"	"sdvr_get_alarm_motion_value"	"Routines__sdvr_get_alarm_motion_value"
"Routine"	"sdvr_add_region"	"Routines__sdvr_add_region"
"Routine"	"sdvr_change_region"	"Routines__sdvr_change_region"
"Routine"	"sdvr_remove_region"	"Routines__sdvr_remove_region"
"Routine"	"sdvr_get_motion_detection"	"Routines__sdvr_get_motion_detection"
"Routine"	"sdvr_get_blind_detection"	"Routines__sdvr_get_blind_detection"
"Routine"	"sdvr_get_privacy_regions"	"Routines__sdvr_get_privacy_regions"
"Routine"	"sdvr_get_night_detection"	"Routines__sdvr_get_night_detection"
"Routine"	"sdvr_enable_privacy_regions"	"Routines__sdvr_enable_privacy_regions"
"Routine"	"sdvr_enable_motion_detection"	"Routines__sdvr_enable_motion_detection"
"Routine"	"sdvr_enable_motion_detection_ex"	"Routines__sdvr_enable_motion_detection_ex"
"Routine"	"sdvr_enable_blind_detection"	"Routines__sdvr_enable_blind_detection"
"Routine"	"sdvr_enable_night_detection"	"Routines__sdvr_enable_night_detection"
"Section"	"Encoding and Raw Audio/Video API"	"Routines__Encoding___and___Raw___Audio___Video___API"
"Routine"	"sdvr_enable_encoder"	"Routines__sdvr_enable_encoder"
"Routine"	"sdvr_get_av_buffer"	"Routines__sdvr_get_av_buffer"
"Routine"	"sdvr_get_yuv_buffer"	"Routines__sdvr_get_yuv_buffer"
"Routine"	"sdvr_release_av_buffer"	"Routines__sdvr_release_av_buffer"
"Routine"	"sdvr_release_yuv_buffer"	"Routines__sdvr_release_yuv_buffer"
"Routine"	"sdvr_enable_auth_key"	"Routines__sdvr_enable_auth_key"
"Section"	"Frame Buffer Field Access API"	"Routines__Frame___Buffer___Field___Access___API"
"Routine"	"sdvr_get_buffer_channel"	"Routines__sdvr_get_buffer_channel"
"Routine"	"sdvr_get_buffer_timestamp"	"Routines__sdvr_get_buffer_timestamp"
"Routine"	"sdvr_get_buffer_frame_type"	"Routines__sdvr_get_buffer_frame_type"
"Routine"	"sdvr_get_buffer_yuv_format"	"Routines__sdvr_get_buffer_yuv_format"
"Routine"	"sdvr_get_buffer_sub_encoder"	"Routines__sdvr_get_buffer_sub_encoder"
"Routine"	"sdvr_get_buffer_alarm_value"	"Routines__sdvr_get_buffer_alarm_value"
"Routine"	"sdvr_av_buf_video_dimensions"	"Routines__sdvr_av_buf_video_dimensions"
"Routine"	"sdvr_av_buf_sequence"	"Routines__sdvr_av_buf_sequence"
"Routine"	"sdvr_av_buf_payload"	"Routines__sdvr_av_buf_payload"
"Routine"	"sdvr_av_buf_yuv_payload"	"Routines__sdvr_av_buf_yuv_payload"
"Section"	"Decoding API"	"Routines__Decoding___API"
"Routine"	"sdvr_enable_decoder"	"Routines__sdvr_enable_decoder"
"Routine"	"sdvr_set_decoder_size"	"Routines__sdvr_set_decoder_size"
"Routine"	"sdvr_alloc_av_buffer_wait"	"Routines__sdvr_alloc_av_buffer_wait"
"Routine"	"sdvr_alloc_av_buffer"	"Routines__sdvr_alloc_av_buffer"
"Routine"	"sdvr_send_av_frame"	"Routines__sdvr_send_av_frame"
"Section"	"Display and Sound API"	"Routines__Display___and___Sound___API"
"Routine"	"sdvr_stream_raw_video"	"Routines__sdvr_stream_raw_video"
"Routine"	"sdvr_stream_raw_audio"	"Routines__sdvr_stream_raw_audio"
"Routine"	"sdvr_get_video_in_params"	"Routines__sdvr_get_video_in_params"
"Routine"	"sdvr_set_video_in_params"	"Routines__sdvr_set_video_in_params"
"Routine"	"sdvr_set_yuv_format"	"Routines__sdvr_set_yuv_format"
"Routine"	"sdvr_enable_deinterlacing"	"Routines__sdvr_enable_deinterlacing"
"Routine"	"sdvr_enable_noise_reduction"	"Routines__sdvr_enable_noise_reduction"
"Routine"	"sdvr_set_gain_mode"	"Routines__sdvr_set_gain_mode"
"Routine"	"sdvr_set_camera_termination"	"Routines__sdvr_set_camera_termination"
"Section"	"On-Screen Display API"	"Routines__On___Screen___Display___API"
"Routine"	"sdvr_osd_text_config_ex"	"Routines__sdvr_osd_text_config_ex"
"Routine"	"sdvr_osd_text_show"	"Routines__sdvr_osd_text_show"
"Routine"	"sdvr_osd_set_font_table"	"Routines__sdvr_osd_set_font_table"
"Routine"	"sdvr_osd_use_font_table"	"Routines__sdvr_osd_use_font_table"
"Section"	"Spot Monitor Output API"	"Routines__Spot___Monitor___Output___API"
"Routine"	"sdvr_set_smo_grid"	"Routines__sdvr_set_smo_grid"
"Routine"	"sdvr_get_smo_grid"	"Routines__sdvr_get_smo_grid"
"Routine"	"sdvr_set_smo_grid_ex"	"Routines__sdvr_set_smo_grid_ex"
"Routine"	"sdvr_get_smo_grid_ex"	"Routines__sdvr_get_smo_grid_ex"
"Routine"	"sdvr_get_smo_attributes"	"Routines__sdvr_get_smo_attributes"
"Routine"	"sdvr_start_video_output"	"Routines__sdvr_start_video_output"
"Routine"	"sdvr_stop_video_output"	"Routines__sdvr_stop_video_output"
"Routine"	"sdvr_get_video_output_buffer"	"Routines__sdvr_get_video_output_buffer"
"Routine"	"sdvr_send_video_output"	"Routines__sdvr_send_video_output"
"Routine"	"sdvr_smo_osd_text_config"	"Routines__sdvr_smo_osd_text_config"
"Routine"	"sdvr_smo_osd_text_show"	"Routines__sdvr_smo_osd_text_show"
"Section"	"RS485 Communication API"	"Routines__RS485___Communication___API"
"Routine"	"sdvr_init_uart"	"Routines__sdvr_init_uart"
"Routine"	"sdvr_write_uart"	"Routines__sdvr_write_uart"
"Routine"	"sdvr_read_uart"	"Routines__sdvr_read_uart"
"Section"	"Sensors and Relays API"	"Routines__Sensors___and___Relays___API"
"Routine"	"sdvr_trigger_relay"	"Routines__sdvr_trigger_relay"
"Routine"	"sdvr_enable_sensor"	"Routines__sdvr_enable_sensor"
"Routine"	"sdvr_config_sensors"	"Routines__sdvr_config_sensors"
"Routine"	"sdvr_get_sensors"	"Routines__sdvr_get_sensors"
"Routine"	"sdvr_get_relays"	"Routines__sdvr_get_relays"
"Routine"	"sdvr_set_led"	"Routines__sdvr_set_led"
"Section"	"Recording to File API"	"Routines__Recording___to___File___API"
"Routine"	"sdvr_start_recording"	"Routines__sdvr_start_recording"
"Routine"	"sdvr_stop_recording"	"Routines__sdvr_stop_recording"
-->

<P>
</P>


<!-- SEC_DESCRIPTION_START -->

<a name="sdvr_sdk_html_Top__Include"></a>
<H2>4.1 &nbsp; Include</H2>
<PRE class="ccode">
#include "sdvr_sdk.h" 
</PRE>

<a name="sdvr_sdk_html_Top__Introduction"></a>
<H2>4.2 &nbsp; Introduction</H2>
Stretch has developed a reference design for PC-based and embedded 
DVRs. The architecture of a DVR (either PC-based or embedded) using 
components supplied by Stretch is as follows: 
<PRE class="ccode">
       Host                                 Hardware Codec 
                                            consisting of 
   DVR Application                          one or more S6 
         |                                  chips running 
        SDK                                 the Stretch-developed 
         |                                      Codec 
      Driver                                    Firmware 
         |----------------------------------------| 
                 Host-to-hardware interface 
</PRE>
The Stretch DVR (SDVR) hardware consists of one or more S6 processors 
running the <STRONG>DVR  Firmware</STRONG>. 
Together, the hardware and the firmware are responsible 
for encoding, decoding, and interfacing to the cameras, microphones, 
sensors, and relays, and communicating with the host. 
<P>
On the host there is a <STRONG>Driver</STRONG> that handles the 
low-level communication with the firmware. Sitting on top of the 
driver is the <STRONG>SDK</STRONG>, which provides an Application-level Programming 
Interface (API) to the SDVR hardware. It is through this API that 
an application talks to the hardware. The SDK provides the 
ability to: 
</P>
<UL>
<LI>
Discover the capabilities of the hardware CODEC. 
</LI>
<LI>
Configure the hardware. 
</LI>
<LI>
Encode and decode video and audio. 
</LI>
<LI>
Control other capabilities like on-screen display, spot monitor, and so on. 
</LI>
</UL>
<P>
This document describes the Application Programming Interface (API) 
implemented in the SDK. 
Your DVR Application can link with the SDK library either statically or dynamically 
(MS Windows only). Use sdvr_sdk.lib to link statically with the SDK library. 
Use sdvr_sdk_dll.lib to link dynamically with the SDK library; the 
corresponding sdvr_sdk_dll.dll needs to be copied with your DVR 
Application executable. 
</P>
<P>
Throughout this document, we refer to the application that uses the 
SDK as the <STRONG>DVR Application</STRONG>, as it will implement the functionality 
of a DVR. 
</P>

<a name="sdvr_sdk_html_Top__Function___Groups"></a>
<H2>4.3 &nbsp; Function Groups</H2>
The functions in the SDK API are divided into nine major groups. 
<UL>
<LI>
<STRONG>System Set Up</STRONG>. Functions in 
this group enable you to initialize the SDK, set up the system 
parameters, and discover and initialize boards at start-up. When you want 
to exit the application, the APIs in this group allow you to 
shut down the system gracefully and to free all system resources. 
</LI>
<LI>
<STRONG>Channel Set Up</STRONG>. Functions in this group 
enable you to initialize each channel at start-up or to reinitialize 
a channel during operation. 
</LI>
<LI>
<STRONG>Encoding</STRONG>. Functions in this group allow you to start 
and stop encoding, and to receive encoded and raw audio/video (A/V) buffers. 
</LI>
<LI>
<STRONG>Frame Buffer Field Access</STRONG>. Functions in this group allow you to access 
different attributes associated to an encoded or decoded frame buffer 
that is received from the firmware. (i.e. timestamp, channel number, and so on.) 
</LI>
<LI>
<STRONG>Decoding</STRONG>. Functions in this group allow you to send encoded 
A/V streams to the decoder for decoding and display. 
</LI>
<LI>
<STRONG>Video Display and Sound</STRONG>. Functions in this group allow you to 
control raw audio and video streaming. Stretch provides a separate 
UI SDK library that helps you to display video frames in any regions 
within a display window handle. (See sdvr_ui_sdk.html for details.) 
</LI>
<LI>
<STRONG>On-Screen Display</STRONG>. Functions in this group allow you to 
control how on-screen information is displayed and to enable or disable 
on-screen display (OSD). 
</LI>
<LI>
<STRONG>Spot Monitor</STRONG>. Functions in this group allow you to control 
the grid pattern and channels appearing in the spot monitor output (SMO) 
as well as sending full size raw video frames to the video out port. 
</LI>
<LI>
<STRONG>RS485 Communication API</STRONG>. Functions in this group allow you to 
control the RS-485 interface over which you can implement any PTZ 
protocol that works over RS-485. 
</LI>
<LI>
<STRONG>Sensors and Relays</STRONG>. Functions in this group allow you to 
set and reset sensors and relays attached to the hardware. 
</LI>
<LI>
<STRONG>Recording to File API</STRONG>. Functions in this group allow you to 
save the encoded audio and video frames in to a file. 
</LI>
</UL>
<P>
Naming conventions. Functions and data structures start with <STRONG>sdvr_</STRONG> 
so as to avoid conflict with symbols in the DVR Application. 
</P>
<P>
All enumerated types end with <STRONG>_e</STRONG> and all data structures end with <STRONG>_t</STRONG>. 
</P>

<a name="sdvr_sdk_html_Top__Important___Notes___about___the___SDK"></a>
<H2>4.4 &nbsp; Important Notes about the SDK</H2>
Note the following: 
<UL>
<LI>
The SDK and the firmware on the board is stateless, i.e. parameters 
used to configure the SDK and the firmware are not stored across 
sessions (a session starts with initialization and ends when the SDK 
is closed or the system rebooted). Remember that every time you call 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_sdk_init">sdvr_sdk_init</A>()</NOBR> at the beginning of your application you must 
reinitialize all the system and channel parameters after you connect 
to the hardware. 
</LI>
<LI>
To set the time in firmware, the DVR Application needs to compute the 
number of seconds elapsed since January 1, 1970 UTC and to present it to 
each board using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_date_time">sdvr_set_date_time</A>()</NOBR>. When this function is used, 
the firmware takes the date and time and sets it in hardware. 
It is required that the DVR Application set the 
time whenever the time changes (e.g., Daylight  Savings Time). We also 
recommend that the DVR Application monitor the time on 
the hardware, and if the drift between the host clock and the 
clock on the hardware gets beyond a certain limit, then reset the time 
on the hardware. 
</LI>
<LI>
Depending on the type of DVR (embedded or PC-based), the hardware 
may consist of one or more boards, each having one or more S6 chips, 
and each running a copy of the CODEC firmware. 
If there are N boards in a system, the SDK numbers them from 0 to N-1. 
</LI>
<LI>
When configuring the system, the DVR Application is required to set 
the system-wide video standard and resolution. This is the maximum 
video resolution that is supported by the SDK. Lesser video 
resolutions can be supported, but the lesser resolutions can only be 1/4 
of or 1/16 of the maximum resolution. Other supported resolutions are 2CIF 
that is the same width but half the number of lines of maximum resolution and 
DCIF that is 3/4 of the width but 2/3 of the number of lines of 
maximum resolution. <STRONG>NOTE: 2CIF and DCIF are always based on 4CIF or D1 
video standard.</STRONG> 
</LI>
<LI>
If you mark a region as private, that region is blocked out in both 
the live and the encoded stream. 
</LI>
<LI>
When decoding a frame, you must enable raw video or SMO for the decoder 
channel in order to receive and display the decoded raw video frames. 
</LI>
<LI>
For any alarm detection (i.e., motion detection, blind detection, and so on) 
to be active, the camera must be either encoding video frames or streaming 
raw video. 
</LI>
<LI>
If the specified decimation and x,y coordinates of an SMO grid do not correctly 
fit on the monitor, the grid is not displayed. 
</LI>
</UL>

<a name="sdvr_sdk_html_Top__Important___Restrictions"></a>
<H2>4.5 &nbsp; Important Restrictions</H2>
Note the following restrictions when using the SDK. The 
restrictions, apart from those explicitly noted, are not permanent 
and will be removed in future versions of the SDK. 
<UL>
<LI>
Only one DVR Application can use the SDK on one host. Multiple 
copies of the SDK and associated driver cannot reside on the same host. 
This is a permanent restriction. 
</LI>
<LI>
All the cameras on an SDVR card must have the same video standards and camera 
resolution, e.g., NTSC D1 720x480 at 30 fps or PAL 720x576 at 25 fps. 
</LI>
<LI>
Only two OSD text strings are supported per channel. 
</LI>
<LI>
For OSD text only the ASCII character set is supported. 
Double-byte and Unicode character sets are supported only if the corresponding 
font table is loaded in the firmware. 
</LI>
<LI>
OSD text color and logo display are currently not supported. 
</LI>
<LI>
OSD text for decoder channels is currently not supported. 
</LI>
<LI>
OSD text must be positioned such that it does not cause wrapping 
within the video frame. Otherwise, the behavior is not deterministic. 
</LI>
<LI>
Only H.264 decoding is supported. 
</LI>
<LI>
Audio decoding is not supported. 
</LI>
<LI>
Currently the APIs that save A/V frames into a file is only limited to 
.mov file format. Additionally, these APIs are not officially supported 
in this release. 
</LI>
<LI>
SMO dwell time field is not supported. This means only one video channel can be 
specified in any SMO grid. 
</LI>
<LI>
A channel must be streaming video (encoder, raw, or SMO) in order for 
any of the alarm detection occurs. 
</LI>
<LI>
The three classic resolution CIF, 2CIF and 4CIF are only supported for 
streaming raw video frames to the host DVR Application. 
</LI>
<LI>
There may be a performance degrade if the encoded video frames that are being 
decoded are different from the current system video standard. 
</LI>
</UL>

<a name="sdvr_sdk_html_Top__Format___of___data___buffer___exchange___between___SDK___and___DVR___Application"></a>
<H2>4.6 &nbsp; Format of data buffer exchange between SDK and DVR Application</H2>
<P>
There are two type of data buffers: <A HREF="#sdvr_sdk_html_Types__sdvr_av_buffer_t">sdvr_av_buffer_t</A> and <A HREF="#sdvr_sdk_html_Types__sdvr_yuv_buffer_t">sdvr_yuv_buffer_t</A>. 
</P>
<P>
<A HREF="#sdvr_sdk_html_Types__sdvr_av_buffer_t">sdvr_av_buffer_t</A> is used to exchange encoded video, encoded audio, and 
raw audio data. <A HREF="#sdvr_sdk_html_Types__sdvr_yuv_buffer_t">sdvr_yuv_buffer_t</A> is used to exchange raw video data. 
</P>
<P>
The raw A/V frames can be 
either from the live or decoded video stream. 
In most DVR boards the format of a raw video is YUV 4:2:0 but some DVR boards 
may support YUV 4:2:0. The raw video format can be determined by examining 
the frame header. 
A raw video frame is of type <A HREF="#sdvr_sdk_html_Types__sdvr_yuv_buffer_t">sdvr_yuv_buffer_t</A> that 
consists of a header followed by three payloads. Each payload is 
a pointer to a Y, U, or V buffer. Each Y, U, or V buffer is of type <A HREF="#sdvr_sdk_html_Types__sdvr_av_buffer_t">sdvr_av_buffer_t</A>. 
The format of a raw audio is PCM. A raw audio frame is of type <A HREF="#sdvr_sdk_html_Types__sdvr_av_buffer_t">sdvr_av_buffer_t</A> 
that consists of a header followed by a payload. 
</P>
<P>
The encoder encodes the incoming video and audio 
frame-by-frame and each encoded 
frame is sent to the host. A frame consists of a header generated by 
the encoder and a payload. The header format is Stretch proprietary 
and has information that may be relevant to the DVR Application (e.g., 
whether motion was detected). The header format is <A HREF="#sdvr_sdk_html_Types__sdvr_av_buffer_t">sdvr_av_buffer_t</A> described later 
in this document. 
</P>
<P>
<STRONG>NOTE: You should not directly access the 
fields in this data structure. Instead, use the functions specified 
in the Frame Buffer Field Access group.</STRONG> 
</P>
<P>
The payload format contains the video or audio stream in 
elementary stream format. Therefore, if the video or audio payload is stored in 
its own file, it can be played by any player that supports the elementary 
stream format and has the corresponding decoder. There is an exception for alarm 
values frame types, in this case,  the payload contains the alarm values per 
macro blocks of the video frame. 
</P>

<a name="sdvr_sdk_html_Top__Using___the___SDK___API"></a>
<H2>4.7 &nbsp; Using the SDK API</H2>
This section provides a high-level overview of the various DVR 
Application tasks and the functions used to accomplish those tasks. 

<a name="sdvr_sdk_html_Top__SDK___and___Board___Initialization___and___Set___Up"></a>
<H3>4.7.1 &nbsp; SDK and Board Initialization and Set-Up</H3>
The DVR Application needs to perform the following tasks during 
initialization and set-up. 
<UL>
<LI>
Initialize the SDK using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_sdk_init">sdvr_sdk_init</A>()</NOBR>. 
</LI>
<LI>
Load firmware into every DVR board that needs to be connected by 
calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_upgrade_firmware">sdvr_upgrade_firmware</A>()</NOBR>. This is required only in cases when 
no firmware is 
burned onto the board, or when you want to use a different firmware than 
that already burned. You can get the board type as well as other PCI information 
in order to decide which version of firmware to load by calling 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_pci_attrib">sdvr_get_pci_attrib</A>()</NOBR>. 
</LI>
<LI>
For a PC-based DVR, get the number of boards using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_board_count">sdvr_get_board_count</A>()</NOBR>. 
For an embedded DVR, the board count is almost always 1. 
</LI>
<LI>
For both PC-based and embedded DVRs, get the board attributes using 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_board_attributes">sdvr_get_board_attributes</A>()</NOBR>. 
</LI>
<LI>
Set the amount of memory allocated for communication with the 
hardware using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_sdk_params">sdvr_set_sdk_params</A>()</NOBR>. We recommend that you use default 
video buffer settings for that call <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_sdk_params">sdvr_get_sdk_params</A>()</NOBR>, and only 
change the fields of interest to you. During development, we 
recommend that you enable debugging using many different flags in the SDK parameter 
structure, and specify a logfile to record tracing of communication between 
the DVR Application and the DVR firmware. 
</LI>
<LI>
Connect to each board using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_board_connect">sdvr_board_connect</A>()</NOBR> and set the 
video standard (NTSC or PAL) and maximum resolution. (You can get a list of 
supported video standards from <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_board_attributes">sdvr_get_board_attributes</A>()</NOBR>.) Additionally, 
specify whether the host PC should perform start code emulation for h.264 
codecs. For performance reasons, it is highly recommended to always set 
this field to 1 except for the embedded DVR Applications which must be set 
to 0. This establishes a connection to the board for further control and data 
communication. 
</LI>
<LI>
If required, the SDK, driver, boot loader, and firmware versions can be obtained 
using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_sdk_version">sdvr_get_sdk_version</A>()</NOBR>, <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_driver_version">sdvr_get_driver_version</A>()</NOBR> and 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_firmware_version_ex">sdvr_get_firmware_version_ex</A>()</NOBR>. Stretch will publish a matrix of which 
SDK, driver, boot loader, and firmware versions are compatible. This information 
can be used to check that compatible versions are used. 
</LI>
<LI>
Get the capabilities of each board, i.e., the number of cameras it 
can have, the number of sensors, etc. using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_board_config">sdvr_get_board_config</A>()</NOBR>. 
</LI>
<LI>
Set the date and time in the firmware using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_date_time">sdvr_set_date_time</A>()</NOBR>. 
Subsequently, the DVR Application should periodically monitor the 
time on the firmware using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_date_time">sdvr_get_date_time</A>()</NOBR>, and if there is 
drift between the host and the firmware clock, reset the clock on 
the firmware using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_date_time">sdvr_set_date_time</A>()</NOBR>. 
</LI>
<LI>
Set the callback function for the SDK to call when an error is 
encountered in the firmware 
using <NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_signals_callback">sdvr_signals_callback</A>()</NOBR>. This is not mandatory, but is a very 
useful tool for debugging. 
</LI>
<LI>
Set the callback function for the SDK to call when sensors are 
triggered using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_sensor_callback">sdvr_set_sensor_callback</A>()</NOBR>. This is mandatory if the 
DVR Application wants to be notified about sensors being triggered. 
</LI>
<LI>
Set the callback function for the SDK to call when video alarms are 
triggered using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_video_alarm_callback">sdvr_set_video_alarm_callback</A>()</NOBR>. This is not mandatory as 
you can get some of this information from the A/V buffer header, but we 
highly recommend that you register a callback for video alarms. 
</LI>
<LI>
Set the callback function for the SDK to call when AV frames are available 
from the hardware using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_av_frame_callback">sdvr_set_av_frame_callback</A>()</NOBR>. This callback 
function is not mandatory, as described later. 
</LI>
<LI>
Set the callback function for the SDK to call send AV frames confirmation 
from the DVR Host Application to the DVR firmware 
using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_confirmation_callback">sdvr_set_confirmation_callback</A>()</NOBR>. This callback 
function is not mandatory and only is used in conjunction with decoders 
or sending raw video to video out port. 
</LI>
<LI>
If you need to display OSD text other than English language, load 
the corresponding font file using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_osd_set_font_table">sdvr_osd_set_font_table</A>()</NOBR>. 
</LI>
<LI>
If necessary, set the watchdog timer in the hardware using 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_watchdog_state">sdvr_set_watchdog_state</A>()</NOBR> or <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_watchdog_state_ex">sdvr_set_watchdog_state_ex</A>()</NOBR>. 
The watchdog timer is used to reset the 
entire DVR system to prevent it from hanging. If the software on the 
host and the firmware is alive, then the watchdog should be periodically 
reset before it expires (the current value can be obtained using 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_watchdog_state">sdvr_get_watchdog_state</A>()</NOBR>). 
</LI>
<LI>
If necessary, run diagnostics on the hardware using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_run_diagnostics">sdvr_run_diagnostics</A>()</NOBR>. 
The diagnostics run pertain only to the S6-part of the 
system, as described later. 
</LI>
</UL>

<a name="sdvr_sdk_html_Top__Channel___Set___Up"></a>
<H3>4.7.2 &nbsp; Channel Set-Up</H3>
Before using the system, you must create different channel type to perform 
encoding or decoding tasks. An encoder channel provides encoded video and 
audio and raw video and audio data. 
<P>
To create and configure each channel type, the DVR Application needs to perform the 
following tasks during initialization. 
</P>
<UL>
<LI>
If there are N cameras supported by the system, then channels 0 to 
N-1 are encoding channels. Each encoding channel number corresponds to the 
camera position number in the back panel. 
Set each of these channels as encoding 
channels unless you want to leave some cameras unconnected and 
use the processing power for decoding. To create an encoding 
channel, use <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_create_chan">sdvr_create_chan</A>()</NOBR>. You can dynamically 
turn off encoding channels to free up processing power for decoding. 
Additionally, if there are channels created with secondary encoding support, 
you may not be able to connect to all the cameras for recording. You can 
also specify audio encoding for all cameras that have corresponding 
audio channels connected. Additionally, you may want to create some 
streaming only channels that do not need to have any encoding capabilities. 
These are called HMO- or SMO-only channels. To create HMO- or SMO-only 
channel, set the channel type to <A HREF="#sdvr_sdk_html_Types__SDVR_CHAN_TYPE_ENCODER">SDVR_CHAN_TYPE_ENCODER</A> 
and the primary video format to <A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_ENC_NONE">SDVR_VIDEO_ENC_NONE</A>. 
<STRONG>Note: The HMO- or SMO-only channels take away from the maximum number 
of encoding channels that are allowed by the system. This means that if there are N 
cameras supported and you create M HMO- or SMO-only 
channels, you can only create N minus M number of encoding channels.</STRONG> 
</LI>
<LI>
If necessary, you can change the video-in image parameters (i.e., hue, 
saturation) using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_video_in_params">sdvr_set_video_in_params</A>()</NOBR>. These parameters can 
be changed only for encoder or HMO- or SMO-only channels. 
</LI>
<LI>
After encoding channels are set up, set up decoding channels using 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_create_chan">sdvr_create_chan</A>()</NOBR>. The maximum number of decoding channels depends 
on the processing power left after setting up the encoder channels. 
If the call to <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_create_chan">sdvr_create_chan</A>()</NOBR> returns successfully, then the decoding 
channel was set up. Otherwise, there is no more processing power available and  
the decoding channel could not be set up. (NOTE: The actual processing power  
calculation is done when encoders or decoders are enabled. This implies,  
eventhough decdoers were able to  be created, they may fail to be  
enabled depending on the number of  decoders and encoders that are  
channel was set up. Otherwise, there is no more processing power available and  
the decoding channel could not be set up. (NOTE: The actual processing power  
calculation is done when encoders or decoders are enabled. This implies,  
eventhough decdoers were able to  be created, they may fail to be  
enabled depending on the number of  decoders and encoders that are  
channel was set up. Otherwise, there is no more processing power available and 
the decoding channel could not be set up. (NOTE: The actual processing power 
calculation is done when encoders or decoders are enabled. This implies, 
eventhough decdoers were able to  be created, they may fail to be 
enabled depending on the number of  decoders and encoders that are 
currently enabled at a certain resolution.) Currently, the decoding channel number 
indicates in which S6 chip the decoder is created. Similar to encoder channels, 
decoder channel numbers run from 0 to N-1. Where N is the maximum number of 
decoders supported returned by <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_board_config">sdvr_get_board_config</A>()</NOBR>. Every 4 consecutive 
decoder channel numbers are created in one S6 chip starting from decoder 
channel 0 in the first S6 chip. 
For example, to have one decoder channel created in every S6 chip in 
a four-S6 chip DVR board, you should assign channel numbers 0, 4, 9, and 
13 when creating the decoder channels. 
</LI>
<LI>
When you set a channel to be encoding or decoding, you receive 
a unique channel handle of type <A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>. Subsequently, 
you use this handle in all function calls requiring a channel 
identifier. 
</LI>
<LI>
Existing encoding or decoding channels can be destroyed at any time by 
calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_destroy_chan">sdvr_destroy_chan</A>()</NOBR>. This call lets you rebalance 
channel types as needed. 
</LI>
<LI>
Set the parameters of each video encoding channel using 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_video_encoder_channel_params">sdvr_set_video_encoder_channel_params</A>()</NOBR>. 
</LI>
<LI>
Set the parameters of each alarm-triggered video encoding channel using 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_alarm_video_encoder_params">sdvr_set_alarm_video_encoder_params</A>()</NOBR>. 
</LI>
<LI>
Set the parameters of each audio encoding channel using 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_audio_encoder_channel_params">sdvr_set_audio_encoder_channel_params</A>()</NOBR>. (Currently, there are no audio 
encoder parameters.) 
</LI>
<LI>
Set regions for motion and blind detection, and privacy regions 
using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_regions_map">sdvr_set_regions_map</A>()</NOBR>, <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_regions">sdvr_set_regions</A>()</NOBR>, or <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_add_region">sdvr_add_region</A>()</NOBR>. 
</LI>
<LI>
Set how often you want to receive motion values buffers using 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_motion_value_frequency">sdvr_set_motion_value_frequency</A>()</NOBR>. By default, motion values buffers 
are sent when a motion alarm is triggered. 
</LI>
<LI>
You can associate application-defined data with each encoding or 
decoding channel by calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_chan_user_data">sdvr_set_chan_user_data</A>()</NOBR>. This data 
can be retrieved at a later time by calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_chan_user_data">sdvr_get_chan_user_data</A>()</NOBR>. 
</LI>
<LI>
Enable motion, blind, and night detection using 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_motion_detection">sdvr_enable_motion_detection</A>()</NOBR>, <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_blind_detection">sdvr_enable_blind_detection</A>()</NOBR>, and 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_night_detection">sdvr_enable_night_detection</A>()</NOBR>, respectively. 
</LI>
<LI>
Enable privacy regions using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_privacy_regions">sdvr_enable_privacy_regions</A>()</NOBR>. 
</LI>
</UL>
<P>
The hardware is now set up for encoding, decoding, and display. 
</P>

<a name="sdvr_sdk_html_Top__Video___Analytics___and___Privacy___Blocking"></a>
<H3>4.7.3 &nbsp; Video Analytics and Privacy Blocking</H3>
Stretch provides variety of video frame analysis to be used with various 
video alarm detection, as well as blocking different regions within 
video frames for privacy. These video frame analytics include the Motion 
and Blind Detection within a 
video frame according to some user defined Regions of Interest (ROI) that 
are based on Macro Blocks (MB). As well as the Night Detection that applies 
to the entire video frame. The size of a MB is 16x16 pixels. The 
ROIs are always marked within a 1:1 decimation of a video standard size. Refer 
to <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_regions_map">sdvr_set_regions_map</A>()</NOBR> for more information. 
<P>
To start video alarm detections or to set up privacy blocking, you 
must specify ROIs within a 1:1 decimation of a video standard size for each 
encoder channel. 
Do this by calling either <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_regions_map">sdvr_set_regions_map</A>()</NOBR> or 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_regions">sdvr_set_regions</A>()</NOBR>. By default, the entire video frame is used for any of 
the alarm detection. 
</P>
<P>
The next step is to enable different alarm detections based on the currently 
specified ROIs for each channel and a specific threshold.  Enable motion, blind, 
and night detection using  <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_motion_detection">sdvr_enable_motion_detection</A>()</NOBR> or <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_motion_detection_ex">sdvr_enable_motion_detection_ex</A>()</NOBR>, 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_blind_detection">sdvr_enable_blind_detection</A>()</NOBR>, and  <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_night_detection">sdvr_enable_night_detection</A>()</NOBR>, respectively. 
Enable privacy regions using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_privacy_regions">sdvr_enable_privacy_regions</A>()</NOBR>. 
Once alarm detection is enabled, the DVR Application gets notified through 
the alarm callback as alarms are triggered according to the given threshold. By default 
all of the video alarms are disabled. 
Additionally, you receive different alarm values 
with every video frame (encoded or RAW) as part of the video frame buffer. 
You may choose to receive  motion values every N video 
frames by calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_motion_value_frequency">sdvr_set_motion_value_frequency</A>()</NOBR>. 
</P>
<P>
<STRONG>Note:</STRONG> Motion values are always generated once an alram is detected by 
the firmware regardless of the setting in <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_motion_value_frequency">sdvr_set_motion_value_frequency</A>()</NOBR>. 
</P>
<P>
Having a motion value buffer, you can perform more detailed analysis 
by calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_motion_value_analyzer">sdvr_motion_value_analyzer</A>()</NOBR> and passing it different list of 
ROIs to detect motions in various regions of the current video frame. 
</P>

<a name="sdvr_sdk_html_Top__Encode"></a>
<H3>4.7.4 &nbsp; Encode</H3>
The DVR Application needs to perform the following tasks during 
encoding. 
<UL>
<LI>
Enable the encoder for each channel using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_encoder">sdvr_enable_encoder</A>()</NOBR>. 
</LI>
<LI>
Get a frame of encoded video for a particular channel using 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_av_buffer">sdvr_get_av_buffer</A>()</NOBR>. If a callback was registered for AV frames, 
then the DVR Application should have received one or more callbacks 
with information about the channels for which encoded frames are 
available. (See <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_av_frame_callback">sdvr_set_av_frame_callback</A>()</NOBR> 
for a usage example of such a callback). That information can be used to 
determine which channels have 
data and to request frames only from those channels. If, however, a callback 
was not registered, <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_av_buffer">sdvr_get_av_buffer</A>()</NOBR> can be used as a polling 
function - when channels have encoded AV frames this function returns 
valid buffers, but returns appropriate error codes for channels 
that do not have new frames available. 
</LI>
<LI>
Stretch has implemented a one-copy buffer management policy. The buffers 
required to hold incoming data from the board (and data going to the 
board) are allocated in the SDK. The driver, however, 
allocates a few buffers that are contiguous in physical memory to 
enable efficient DMA. Data coming from the board is first stored in the 
driver buffers and then copied over to the SDK buffers. Similarly, 
data going to the board is first stored in the SDK buffers and then 
copied to the driver buffers before being DMAed to the board. 
</LI>
<LI>
It is important to release buffers obtained from the SDK using 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_release_av_buffer">sdvr_release_av_buffer</A>()</NOBR> for encoded frames and <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_release_yuv_buffer">sdvr_release_yuv_buffer</A>()</NOBR> 
for raw video frames. The SDK then recycles these buffers 
and uses them for holding future incoming frames. Under no 
circumstances should a buffer be freed by the DVR Application. 
Also, holding on to the buffer for too long causes the SDK 
to run out of buffers, and frames are lost. It is therefore 
important that enough buffers be allocated and that buffers are 
released in a timely manner. 
</LI>
</UL>
<P>
It is the responsibility of the DVR Application to save the data to disk. 
</P>

<a name="sdvr_sdk_html_Top__Decode"></a>
<H3>4.7.5 &nbsp; Decode</H3>
The DVR Application needs to perform the following tasks during decoding. 
<UL>
<LI>
Set the encoded video frame size for each channel 
to be decoded by calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_decoder_size">sdvr_set_decoder_size</A>()</NOBR>. 
</LI>
<LI>
Enable the decoder for each channel using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_decoder">sdvr_enable_decoder</A>()</NOBR>. 
</LI>
<LI>
In keeping with Stretch's buffer management policy whereby the 
SDK manages all the buffers, the 
DVR Application must request a free frame buffer from the SDK using 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_alloc_av_buffer">sdvr_alloc_av_buffer</A>()</NOBR>. 
</LI>
<LI>
The DVR Application should fill this buffer with encoded data 
from the disk. After this buffer is full, it can be sent to the 
hardware for decoding using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_send_av_frame">sdvr_send_av_frame</A>()</NOBR>. Decoder buffers are 
released as part of the call to <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_send_av_frame">sdvr_send_av_frame</A>()</NOBR>. In the event that 
a decoder buffer is acquired, but needs to be released without sending, 
you can call <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_release_av_buffer">sdvr_release_av_buffer</A>()</NOBR>. 
</LI>
<LI>
The decoded raw video frames can either be displayed on the SMO by calling 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_smo_grid">sdvr_set_smo_grid</A>()</NOBR> or requested to be sent to the DVR Application 
for displaying on the host monitor by calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_stream_raw_video">sdvr_stream_raw_video</A>()</NOBR>. 
Once the streaming of raw video frames is enabled for the decoded channel, the 
raw video frames will be sent for the corresponding decoder via the 
av_frame_callback function (refer to next Section, Raw Video and Audio Data 
for detailed information). 
</LI>
</UL>

<a name="sdvr_sdk_html_Top__Raw___video___and___audio___data"></a>
<H3>4.7.6 &nbsp; Raw video and audio data</H3>
The SDK provides raw (unencoded) audio and video for each channel 
as a separate stream to the DVR Application. These raw A/V frames can be 
either from the live or decoded video stream. The DVR Application needs 
to do the following to get raw video and audio data. 
<UL>
<LI>
Enable streaming of video and audio from the hardware or decoder to the host 
using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_stream_raw_video">sdvr_stream_raw_video</A>()</NOBR> and <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_stream_raw_audio">sdvr_stream_raw_audio</A>()</NOBR> calls. 
Although video for various channels can be enabled for streaming, it 
makes sense to enable streaming for only one audio channel 
(although the SDK supports streaming of multiple audio channels). 
To conserve communication bandwidth between the host and the board, we 
recommend that raw video streaming be enabled only for channels 
that are being displayed, and not for all channels. 
</LI>
<LI>
Register a callback function using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_av_frame_callback">sdvr_set_av_frame_callback</A>()</NOBR> 
so that the DVR Application can be informed 
when raw audio and video frames are available. This is not 
strictly required (see preceding discussion). 
</LI>
<LI>
Call <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_av_buffer">sdvr_get_av_buffer</A>()</NOBR> to get the raw audio or encoded audio/video 
frames from the SDK. Call <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_yuv_buffer">sdvr_get_yuv_buffer</A>()</NOBR> to get raw video frames. 
The format of raw video is YUV 4:2:0, and will be 
received as three separate buffers containing Y, U, and V. 
Use appropriate rendering and sound playback software 
and hardware to display the video and to play the sound. Video for 
each channel is obtained separately, and it is the responsibility of the 
DVR Application to display the video in its appropriate window. Typically, 
the DVR Application creates tiled windows for each channel to be 
displayed, and the video for each channel is rendered in its own 
window. If interested, Stretch provides a UI SDK library that helps you 
to display video frames in any regions within a display window handle. 
(See sdvr_ui_sdk.html for details.) 
</LI>
<LI>
Release the frame buffer obtained in the previous step using 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_release_av_buffer">sdvr_release_av_buffer</A>()</NOBR> or <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_release_yuv_buffer">sdvr_release_yuv_buffer</A>()</NOBR> as appropriate. 
Raw video buffers are large, so there will 
usually not be too many of these buffers per channel. Therefore, it 
is extremely important that these buffers be promptly released. 
</LI>
</UL>

<a name="sdvr_sdk_html_Top__On___Screen___Display______OSD___"></a>
<H3>4.7.7 &nbsp; On-Screen Display (OSD)</H3>
Each encoder or decoder channel can have two different OSD text items to be 
displayed at any position in the video frame. To show OSD, 
the DVR Application needs to do the following: 
<UL>
<LI>
It first needs to configure each OSD text using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_osd_text_config_ex">sdvr_osd_text_config_ex</A>()</NOBR>. 
The <EM>osd_text_config</EM> data structure allows the DVR Application to 
specify the text string, its location, whether date and time should 
be appended to the string, and if so, the style in which the date and  
time is displayed. Stretch provides multi-language support through multiple  
font tables. You can load a non-English language font by calling  
be appended to the string, and if so, the style in which the date and  
time is displayed. Stretch provides multi-language support through multiple  
font tables. You can load a non-English language font by calling  
be appended to the string, and if so, the style in which the date and 
time is displayed. Stretch provides multi-language support through multiple 
font tables. You can load a non-English language font by calling 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_osd_set_font_table">sdvr_osd_set_font_table</A>()</NOBR>. If no font table is loaded, the default English 
font is used. 
</LI>
<LI>
After an OSD text item is configured, it can be shown or hidden using 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_osd_text_show">sdvr_osd_text_show</A>()</NOBR>. In 
the case of encoder channels, OSD text is blended into the video before the video is 
encoded. Therefore, the OSD text present at the time of encoding is 
displayed during decoding. In the case of decoder channels, OSD text is added 
after the video frame is decoded. Therefore, it is possible to have two different 
OSD text items on the decoded frame, one when it was encoded and the other 
when it is decoded. You may select to specify an OSD text item that  is only 
displayed on any of the SMO ports on the board using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_osd_text_config_ex">sdvr_osd_text_config_ex</A>()</NOBR>. 
Doing so, this text will not be displayed in the raw or encoded video. 
</LI>
</UL>

<a name="sdvr_sdk_html_Top__Spot___Monitor___Output______SMO___"></a>
<H3>4.7.8 &nbsp; Spot Monitor Output (SMO)</H3>
Stretch provides displaying of the live video output from 
each encoder channel or the decode frames output of each decode channel on any where 
within the spot monitor display. The combination of SMO display location and 
its video decimation for each channel is called a SMO grid. Each SMO grid 
can be defined and enabled by calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_smo_grid">sdvr_set_smo_grid</A>()</NOBR>. You can achieve different 
display pattern by placing the channel video output in various display location. 
Additionally, an SMO port may have a video out capability that means you can send 
a full size raw video frame from the DVR Host Application to be displayed on that 
SMO port. You can get the capabilities, screen size, supported video format associated 
to each SMO port using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_smo_attributes">sdvr_get_smo_attributes</A>()</NOBR>. 
<P>
Stretch provides two SMO feature solutions. One is analog, which is a direct pass-through 
of only one video channel to the Spot Monitor. In this mode, only one video 
channel can be displayed in the full resolution and no OSD text can be viewed on 
that monitor. The other SMO mode provides full-function SMO capabilities with 
multiple channels and OSD. If this mode is selected, the last video channel in 
the last S6 chip will be lost. This means that in a 16 channel board only 15 
channels are available. 
</P>
<P>
To enable SMO, the DVR Application needs to do the following: 
</P>
<UL>
<LI>
Specify the grid pattern using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_smo_grid">sdvr_set_smo_grid</A>()</NOBR>. 
The SMO grid pattern is flexible and is defined by the user. Each tile can 
be either enabled or disabled. When enabled, there are one or more 
channels to display at this tile. If disabled, the tile is not used. 
The channel specified at each location can be either an encoding 
or decoding channel. If it is an encoding channel, live video is 
displayed, and if it is a decode channel then playback video is displayed. 
Each tile also has a display resolution decimation. 
</LI>
<LI>
Setting the SMO configuration using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_smo_grid">sdvr_set_smo_grid</A>()</NOBR> enables displaying 
of SMO. No further action is required on the part of the DVR Application. 
</LI>
</UL>
<P>
<STRONG>NOTE</STRONG>: In <EM>analog</EM> mode, only one tile at a time can be specified by calling 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_smo_grid">sdvr_set_smo_grid</A>()</NOBR>, since the display can handle only one channel at a time. 
To rotate the display between multiple channels (i.e. implement <EM>dwell time</EM>) 
the host application must implement the logic to do so, by disabling one channel 
and enabling the next one every time period. 
</P>
<P>
To send raw video frames from the Host DVR Application to be displayed on any SMO 
port with video out capability do the following: 
</P>
<UL>
<LI>
Open a video output channel using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_start_video_output">sdvr_start_video_output</A>()</NOBR>. The channel handle 
that is returned will be used for any subsequent call to send raw video 
frames. 
</LI>
<LI>
In keeping with Stretch's buffer management policy whereby the 
SDK manages all the buffers, the 
DVR Application must request a free frame buffer from the SDK using 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_video_output_buffer">sdvr_get_video_output_buffer</A>()</NOBR>. 
</LI>
<LI>
The DVR Application should fill this payload field of this buffer with 
raw video YUV fromat from the disk. The YUV planes at the payload must 
be compacted meaning no spaces between the Y, U, and V plane buffers and 
their size must match the specified video format when <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_start_video_output">sdvr_start_video_output</A>()</NOBR> 
was called. 
</LI>
<LI>
After this buffer is full, it can be sent to the 
hardware for decoding using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_send_video_output">sdvr_send_video_output</A>()</NOBR>. The buffers are 
released as part of the call to <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_send_video_output">sdvr_send_video_output</A>()</NOBR>. In the event that 
a send buffer is acquired, but needs to be released without sending, 
you can call <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_release_av_buffer">sdvr_release_av_buffer</A>()</NOBR>. 
</LI>
<LI>
You can be notified as each raw video frame is 
sent to the DVR board and processed by registering a confirmation 
callback using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_confirmation_callback">sdvr_set_confirmation_callback</A>()</NOBR>. 
</LI>
<LI>
Once you are done sending video frame, close 
the video output channel using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_stop_video_output">sdvr_stop_video_output</A>()</NOBR>. 
</LI>
</UL>

<a name="sdvr_sdk_html_Top__Pan______Tilt______and___Zoom"></a>
<H3>4.7.9 &nbsp; Pan, Tilt, and Zoom</H3>
Typically, the PTZ controller for a camera is connected to the processor 
implementing the PTZ protocol through an RS-485 interface. The S6 
processor does not have an RS-485 interface, so the Stretch reference 
design provides the mechanism to talk to the RS-485 port on the alarm 
I/O card. 
<P>
The SDK does not support any particular PTZ protocol. Instead, it gives 
access to the RS-485 interface through the RS-232C interface. The PTZ 
section of the SDK allows the DVR Application to set up the RS232C port 
on the S6 to talk to the RS-485. The following functions are available: 
</P>
<UL>
<LI>
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_init_uart">sdvr_init_uart</A>()</NOBR> allows the DVR Application to set the baud rate, 
stop bits, etc. for the UART interface. 
</LI>
<LI>
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_read_uart">sdvr_read_uart</A>()</NOBR> returns up to 255 character from the UART port. 
</LI>
<LI>
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_write_uart">sdvr_write_uart</A>()</NOBR> writes up to 255 character to the UART port. 
</LI>
</UL>

<a name="sdvr_sdk_html_Top__Sensors___and___Relays"></a>
<H3>4.7.10 &nbsp; Sensors and Relays</H3>
Sensors are external inputs that can be triggered, for example, by a 
door opening. The SDK allows the DVR Application to register a callback 
so that any time one or more sensors are triggered, the callback function 
is called. This callback is registered using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_sensor_callback">sdvr_set_sensor_callback</A>()</NOBR> 
and the type of the callback function is <A HREF="#sdvr_sdk_html_Types__sdvr_sensor_callback">sdvr_sensor_callback</A>. Some sensors 
are edge triggered whereas others are level sensitive. You can specify 
how each sensor should be triggered, as well as its initial enable status 
by calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_config_sensors">sdvr_config_sensors</A>()</NOBR>. You can also enable or disable an 
individual sensor at different times by calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_sensor">sdvr_enable_sensor</A>()</NOBR>. 
<P>
Relays are actuators that are activated by the DVR Application. To 
activate or deactivate a relay, the DVR Application calls 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_trigger_relay">sdvr_trigger_relay</A>()</NOBR> with the proper value for the <EM>is_triggered</EM> 
flag. 
</P>

<a name="sdvr_sdk_html_Top__System___Shutdown"></a>
<H3>4.7.11 &nbsp; System Shutdown</H3>
The DVR Application needs to perform the following tasks during 
shutdown: 
<UL>
<LI>
Disable encoding on all channels using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_encoder">sdvr_enable_encoder</A>()</NOBR>, with the 
<EM>enable</EM> flag set to <A HREF="#sdvr_sdk_html_Defines__false">false</A>. 
</LI>
<LI>
Disable decoding on all channels using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_decoder">sdvr_enable_decoder</A>()</NOBR>, with the 
<EM>enable</EM> flag set to <A HREF="#sdvr_sdk_html_Defines__false">false</A>. 
</LI>
<LI>
Disable all relays using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_trigger_relay">sdvr_trigger_relay</A>()</NOBR>, with the <EM>is_triggered</EM> 
flag set to <A HREF="#sdvr_sdk_html_Defines__false">false</A>. 
</LI>
<LI>
Disconnect from boards using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_board_disconnect">sdvr_board_disconnect</A>()</NOBR>. This frees up 
all board-specific resources in the SDK and driver. 
<STRONG>NOTE:  After you call <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_board_disconnect">sdvr_board_disconnect</A>()</NOBR>, you must load the firmware 
by calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_upgrade_firmware">sdvr_upgrade_firmware</A>()</NOBR> every time prior to re-connecting 
to the DVR board if no firmware is 
loaded into the board's none-volatile memory.</STRONG> 
</LI>
<LI>
Close the SDK and free up all system resources using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_sdk_close">sdvr_sdk_close</A>()</NOBR>. 
Although disabling and destroying all the channels, as well as disconnecting 
from all boards is good programming  practice, 
it is not required because <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_sdk_close">sdvr_sdk_close</A>()</NOBR> performs these actions. 
</LI>
</UL>

<!-- SEC_DESCRIPTION_CLOSE -->

<!-- SEC_TYPES_START -->

<a name="sdvr_sdk_html_Top__Types"></a>
<H2>4.8 &nbsp; Types</H2>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sx_uint8"></a>
<PRE class="cdef">
typedef unsigned char <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>; 
</PRE>
<DIV CLASS="descr">
<P>
8-bit unsigned integer. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sx_uint16"></a>
<PRE class="cdef">
typedef unsigned short <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A>; 
</PRE>
<DIV CLASS="descr">
<P>
16-bit unsigned integer. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sx_uint32"></a>
<PRE class="cdef">
typedef unsigned int <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>; 
</PRE>
<DIV CLASS="descr">
<P>
32-bit unsigned integer. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sx_uint64"></a>
<PRE class="cdef">
typedef unsigned long long <A HREF="#sdvr_sdk_html_Types__sx_uint64">sx_uint64</A>; 
</PRE>
<DIV CLASS="descr">
<P>
64-bit unsigned integer. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sx_bool"></a>
<PRE class="cdef">
typedef unsigned int <A HREF="#sdvr_sdk_html_Types__sx_bool">sx_bool</A>; 
</PRE>
<DIV CLASS="descr">
<P>
Boolean value. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sx_int8"></a>
<PRE class="cdef">
typedef signed char <A HREF="#sdvr_sdk_html_Types__sx_int8">sx_int8</A>; 
</PRE>
<DIV CLASS="descr">
<P>
8-bit signed integer. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sx_int16"></a>
<PRE class="cdef">
typedef short <A HREF="#sdvr_sdk_html_Types__sx_int16">sx_int16</A>; 
</PRE>
<DIV CLASS="descr">
<P>
16-bit signed integer. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sx_int32"></a>
<PRE class="cdef">
typedef int <A HREF="#sdvr_sdk_html_Types__sx_int32">sx_int32</A>; 
</PRE>
<DIV CLASS="descr">
<P>
32-bit signed integer. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sx_int64"></a>
<PRE class="cdef">
typedef long long <A HREF="#sdvr_sdk_html_Types__sx_int64">sx_int64</A>; 
</PRE>
<DIV CLASS="descr">
<P>
64-bit signed integer. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__time_t"></a>
<PRE class="cdef">
typedef long <A HREF="#sdvr_sdk_html_Types__time_t">time_t</A>; 
</PRE>
<DIV CLASS="descr">
<P>
32 bit time value, the number of seconds elapsed since midnight 01/01/1970. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_err_e"></a>
<PRE class="cdef">
typedef enum _sdvr_err_e {
    <A name="sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> = 0,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_WRONG_CAMERA_NUMBER">SDVR_FRMW_ERR_WRONG_CAMERA_NUMBER</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_WRONG_CAMERA_TYPE">SDVR_FRMW_ERR_WRONG_CAMERA_TYPE</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_WRONG_CODEC_FORMAT">SDVR_FRMW_ERR_WRONG_CODEC_FORMAT</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_WRONG_CODEC_RESOLUTION">SDVR_FRMW_ERR_WRONG_CODEC_RESOLUTION</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_WRONG_CHANNEL_TYPE">SDVR_FRMW_ERR_WRONG_CHANNEL_TYPE</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_WRONG_CHANNEL_ID">SDVR_FRMW_ERR_WRONG_CHANNEL_ID</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_WRONG_VIDEO_FORMAT">SDVR_FRMW_ERR_WRONG_VIDEO_FORMAT</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_WRONG_AUDIO_FORMAT">SDVR_FRMW_ERR_WRONG_AUDIO_FORMAT</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_EXCEED_CPU_LIMIT">SDVR_FRMW_ERR_EXCEED_CPU_LIMIT</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_CHANNEL_NOT_CREATED">SDVR_FRMW_ERR_CHANNEL_NOT_CREATED</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_CHANNEL_ALREADY_CREATED">SDVR_FRMW_ERR_CHANNEL_ALREADY_CREATED</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_CHANNEL_NOT_ENABLED">SDVR_FRMW_ERR_CHANNEL_NOT_ENABLED</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_CHANNEL_NOT_DISABLED">SDVR_FRMW_ERR_CHANNEL_NOT_DISABLED</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_SMO_NOT_CREATED">SDVR_FRMW_ERR_SMO_NOT_CREATED</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_INVALID_TIME">SDVR_FRMW_ERR_INVALID_TIME</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_ILLEGAL_SMO_PARAMS">SDVR_FRMW_ERR_ILLEGAL_SMO_PARAMS</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_SMO_NOT_SUPPORTED">SDVR_FRMW_ERR_SMO_NOT_SUPPORTED</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_VDET_ERROR">SDVR_FRMW_ERR_VDET_ERROR</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_RUNTIME_ERROR">SDVR_FRMW_ERR_RUNTIME_ERROR</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_VPP_RUNTIME_ERROR">SDVR_FRMW_ERR_VPP_RUNTIME_ERROR</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_ENCODER_RUNTIME_ERROR">SDVR_FRMW_ERR_ENCODER_RUNTIME_ERROR</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_DECODER_RUNTIME_ERROR">SDVR_FRMW_ERR_DECODER_RUNTIME_ERROR</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_ILLEGAL_PARAMETER">SDVR_FRMW_ERR_ILLEGAL_PARAMETER</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_INTERNAL_ERROR">SDVR_FRMW_ERR_INTERNAL_ERROR</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_ILLEGAL_COMMAND">SDVR_FRMW_ERR_ILLEGAL_COMMAND</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_SMO_NOT_DISABLED">SDVR_FRMW_ERR_SMO_NOT_DISABLED</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_OUT_OF_MEMORY">SDVR_FRMW_ERR_OUT_OF_MEMORY</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_NO_IO_BOARD">SDVR_FRMW_ERR_NO_IO_BOARD</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_AUDIO_RUNTIME">SDVR_FRMW_ERR_AUDIO_RUNTIME</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_UNSUPPORTED_COMMAND">SDVR_FRMW_ERR_UNSUPPORTED_COMMAND</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_SMO_CHAN_FAILED">SDVR_FRMW_ERR_SMO_CHAN_FAILED</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRMW_ERR_RES_LIMIT_EXCEEDED">SDVR_FRMW_ERR_RES_LIMIT_EXCEEDED</A>,
    <A name="sdvr_sdk_html_Types__SDVR_DRV_ERR_MSG_RECV">SDVR_DRV_ERR_MSG_RECV</A> = 255,
    <A name="sdvr_sdk_html_Types__SDVR_DRV_ERR_INVALID_PARAMETER">SDVR_DRV_ERR_INVALID_PARAMETER</A> = 1000,
    <A name="sdvr_sdk_html_Types__SDVR_DRV_ERR_BOARD_IN_USE">SDVR_DRV_ERR_BOARD_IN_USE</A>,
    <A name="sdvr_sdk_html_Types__SDVR_DRV_ERR_BOARD_CONNECT">SDVR_DRV_ERR_BOARD_CONNECT</A>,
    <A name="sdvr_sdk_html_Types__SDVR_DRV_ERR_BOARD_CLOSE">SDVR_DRV_ERR_BOARD_CLOSE</A>,
    <A name="sdvr_sdk_html_Types__SDVR_DRV_ERR_BOARD_RESET">SDVR_DRV_ERR_BOARD_RESET</A>,
    <A name="sdvr_sdk_html_Types__SDVR_DRV_ERR_IPC_INIT">SDVR_DRV_ERR_IPC_INIT</A>,
    <A name="sdvr_sdk_html_Types__SDVR_DRV_ERR_NO_CHANNELS">SDVR_DRV_ERR_NO_CHANNELS</A>,
    <A name="sdvr_sdk_html_Types__SDVR_DRV_ERR_CHANNEL_IN_USE">SDVR_DRV_ERR_CHANNEL_IN_USE</A>,
    <A name="sdvr_sdk_html_Types__SDVR_DRV_ERR_CHANNEL_CREATE">SDVR_DRV_ERR_CHANNEL_CREATE</A>,
    <A name="sdvr_sdk_html_Types__SDVR_DRV_ERR_CHANNEL_CONNECT">SDVR_DRV_ERR_CHANNEL_CONNECT</A>,
    <A name="sdvr_sdk_html_Types__SDVR_DRV_ERR_CHANNEL_CLOSE">SDVR_DRV_ERR_CHANNEL_CLOSE</A>,
    <A name="sdvr_sdk_html_Types__SDVR_DRV_ERR_CHANNEL_NOT_ACTIVE">SDVR_DRV_ERR_CHANNEL_NOT_ACTIVE</A>,
    <A name="sdvr_sdk_html_Types__SDVR_DRV_ERR_CHANNEL_DEAD">SDVR_DRV_ERR_CHANNEL_DEAD</A>,
    <A name="sdvr_sdk_html_Types__SDVR_DRV_ERR_NO_RECV_BUFFERS">SDVR_DRV_ERR_NO_RECV_BUFFERS</A>,
    <A name="sdvr_sdk_html_Types__SDVR_DRV_ERR_NO_SEND_BUFFERS">SDVR_DRV_ERR_NO_SEND_BUFFERS</A>,
    <A name="sdvr_sdk_html_Types__SDVR_DRV_ERR_MSG_SEND">SDVR_DRV_ERR_MSG_SEND</A> = 1015,
    <A name="sdvr_sdk_html_Types__SDVR_DRV_BOARD_BOOT_FAIL">SDVR_DRV_BOARD_BOOT_FAIL</A> = 1017,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_OUT_OF_MEMORY">SDVR_ERR_OUT_OF_MEMORY</A> = 2000,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_INVALID_HANDLE">SDVR_ERR_INVALID_HANDLE</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_INVALID_ARG">SDVR_ERR_INVALID_ARG</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_INVALID_BOARD">SDVR_ERR_INVALID_BOARD</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_BOARD_CONNECTED">SDVR_ERR_BOARD_CONNECTED</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_INVALID_CHANNEL">SDVR_ERR_INVALID_CHANNEL</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_CHANNEL_CLOSED">SDVR_ERR_CHANNEL_CLOSED</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_BOARD_CLOSED">SDVR_ERR_BOARD_CLOSED</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_NO_VFRAME">SDVR_ERR_NO_VFRAME</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_NO_AFRAME">SDVR_ERR_NO_AFRAME</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_INTERNAL">SDVR_ERR_INTERNAL</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_BOARD_NOT_CONNECTED">SDVR_ERR_BOARD_NOT_CONNECTED</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_IN_STREAMING">SDVR_ERR_IN_STREAMING</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_NO_DVR_BOARD">SDVR_ERR_NO_DVR_BOARD</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_WRONG_DRIVER_VERSION">SDVR_ERR_WRONG_DRIVER_VERSION</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_DBG_FILE">SDVR_ERR_DBG_FILE</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_ENCODER_NOT_ENABLED">SDVR_ERR_ENCODER_NOT_ENABLED</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_ENCODER_NOT_DISABLED">SDVR_ERR_ENCODER_NOT_DISABLED</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_SDK_NO_FRAME_BUF">SDVR_ERR_SDK_NO_FRAME_BUF</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_INVALID_FRAME_TYPE">SDVR_ERR_INVALID_FRAME_TYPE</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_NOBUF">SDVR_ERR_NOBUF</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_CALLBACK_FAILED">SDVR_ERR_CALLBACK_FAILED</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_INVALID_CHAN_HANDLE">SDVR_ERR_INVALID_CHAN_HANDLE</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_COMMAND_NOT_SUPPORTED">SDVR_ERR_COMMAND_NOT_SUPPORTED</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_ODD_SMO_COORDINATES">SDVR_ERR_ODD_SMO_COORDINATES</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_LOAD_FIRMWARE">SDVR_ERR_LOAD_FIRMWARE</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_WRONG_CHANNEL_TYPE">SDVR_ERR_WRONG_CHANNEL_TYPE</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_DECODER_NOT_ENABLED">SDVR_ERR_DECODER_NOT_ENABLED</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_BUF_NOT_AVAIL">SDVR_ERR_BUF_NOT_AVAIL</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_MAX_REGIONS">SDVR_ERR_MAX_REGIONS</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_INVALID_REGION">SDVR_ERR_INVALID_REGION</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_INVALID_GOP">SDVR_ERR_INVALID_GOP</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_INVALID_BITRATE">SDVR_ERR_INVALID_BITRATE</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_INVALID_BITRATE_CONTROL">SDVR_ERR_INVALID_BITRATE_CONTROL</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_INVALID_QUALITY">SDVR_ERR_INVALID_QUALITY</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_INVALID_FPS">SDVR_ERR_INVALID_FPS</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_UNSUPPORTED_FIRMWARE">SDVR_ERR_UNSUPPORTED_FIRMWARE</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_INVALID_OSD_ID">SDVR_ERR_INVALID_OSD_ID</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_OSD_LENGTH">SDVR_ERR_OSD_LENGTH</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_OSD_FONT_FILE">SDVR_ERR_OSD_FONT_FILE</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_FONT_ID">SDVR_ERR_FONT_ID</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_CAMERA_IN_REC">SDVR_ERR_CAMERA_IN_REC</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_OPEN_REC_FILE">SDVR_ERR_OPEN_REC_FILE</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_FAILED_ADD_VIDEO_TRACK">SDVR_ERR_FAILED_ADD_VIDEO_TRACK</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_FAILED_ADD_AUDIO_TRACK">SDVR_ERR_FAILED_ADD_AUDIO_TRACK</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_SDK_BUF_EXCEEDED">SDVR_ERR_SDK_BUF_EXCEEDED</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_AUTH_KEY_MISSING">SDVR_ERR_AUTH_KEY_MISSING</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_AUTH_KEY_LEN">SDVR_ERR_AUTH_KEY_LEN</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_INVALID_RESOLUTION">SDVR_ERR_INVALID_RESOLUTION</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ERR_SMO_PORT_NUM">SDVR_ERR_SMO_PORT_NUM</A>
} <A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
Typedef for the errors returned by the SDK. 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - No error, or in other words, success! 
</LI>
<LI>
<STRONG>Following error codes are generated by the DVR firmware:</STRONG> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_WRONG_CAMERA_NUMBER">SDVR_FRMW_ERR_WRONG_CAMERA_NUMBER</A> - The given camera number is invalid. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_WRONG_CAMERA_TYPE">SDVR_FRMW_ERR_WRONG_CAMERA_TYPE</A> - Error code if the specified video standard 
is not supported by the firmware. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_WRONG_CODEC_FORMAT">SDVR_FRMW_ERR_WRONG_CODEC_FORMAT</A> - Error code if the specified video 
codec is not supported. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_WRONG_CODEC_RESOLUTION">SDVR_FRMW_ERR_WRONG_CODEC_RESOLUTION</A> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_WRONG_CHANNEL_TYPE">SDVR_FRMW_ERR_WRONG_CHANNEL_TYPE</A> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_WRONG_CHANNEL_ID">SDVR_FRMW_ERR_WRONG_CHANNEL_ID</A> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_WRONG_VIDEO_FORMAT">SDVR_FRMW_ERR_WRONG_VIDEO_FORMAT</A> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_WRONG_AUDIO_FORMAT">SDVR_FRMW_ERR_WRONG_AUDIO_FORMAT</A> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_EXCEED_CPU_LIMIT">SDVR_FRMW_ERR_EXCEED_CPU_LIMIT</A> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_CHANNEL_NOT_CREATED">SDVR_FRMW_ERR_CHANNEL_NOT_CREATED</A> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_CHANNEL_ALREADY_CREATED">SDVR_FRMW_ERR_CHANNEL_ALREADY_CREATED</A> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_CHANNEL_NOT_ENABLED">SDVR_FRMW_ERR_CHANNEL_NOT_ENABLED</A> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_CHANNEL_NOT_DISABLED">SDVR_FRMW_ERR_CHANNEL_NOT_DISABLED</A> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_INVALID_TIME">SDVR_FRMW_ERR_INVALID_TIME</A> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_ILLEGAL_SMO_PARAMS">SDVR_FRMW_ERR_ILLEGAL_SMO_PARAMS</A> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_SMO_NOT_SUPPORTED">SDVR_FRMW_ERR_SMO_NOT_SUPPORTED</A> - There is no SMO support in the firmware. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_VDET_ERROR">SDVR_FRMW_ERR_VDET_ERROR</A> - Error code if the firmware detects cameras 
connected with mixed video standard connected. (i.e., some NTSC cameras and 
some PAL cameras). 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_RUNTIME_ERROR">SDVR_FRMW_ERR_RUNTIME_ERROR</A> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_VPP_RUNTIME_ERROR">SDVR_FRMW_ERR_VPP_RUNTIME_ERROR</A> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_ENCODER_RUNTIME_ERROR">SDVR_FRMW_ERR_ENCODER_RUNTIME_ERROR</A> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_DECODER_RUNTIME_ERROR">SDVR_FRMW_ERR_DECODER_RUNTIME_ERROR</A> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_ILLEGAL_PARAMETER">SDVR_FRMW_ERR_ILLEGAL_PARAMETER</A> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_INTERNAL_ERROR">SDVR_FRMW_ERR_INTERNAL_ERROR</A> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_ILLEGAL_COMMAND">SDVR_FRMW_ERR_ILLEGAL_COMMAND</A> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_SMO_NOT_DISABLED">SDVR_FRMW_ERR_SMO_NOT_DISABLED</A> - Error code if you tried to reset channel 
parameters to factory default while SMO was enabled. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_OUT_OF_MEMORY">SDVR_FRMW_ERR_OUT_OF_MEMORY</A> - Error code if the firmware runs out of memory 
in the middle of the current operation. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_NO_IO_BOARD">SDVR_FRMW_ERR_NO_IO_BOARD</A> - Error code if the current command requires 
an I/O board for the operation but the I/O board is not connected to the 
DVR board. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_AUDIO_RUNTIME">SDVR_FRMW_ERR_AUDIO_RUNTIME</A> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_UNSUPPORTED_COMMAND">SDVR_FRMW_ERR_UNSUPPORTED_COMMAND</A> - Error code if the command is not 
supported by the current version of the DVR firmware. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_SMO_CHAN_FAILED">SDVR_FRMW_ERR_SMO_CHAN_FAILED</A> - 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_RES_LIMIT_EXCEEDED">SDVR_FRMW_ERR_RES_LIMIT_EXCEEDED</A> - Error code if you exceeded 
the processing capabilities for the current operation. (i.e. If you 
try to start 4 channels of D1 dual encoding.) 
</LI>
<LI>
<STRONG>Following error codes are generated by the PCI driver interface:</STRONG> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_INVALID_PARAMETER">SDVR_DRV_ERR_INVALID_PARAMETER</A> - Refer to the function prototype for information. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_BOARD_IN_USE">SDVR_DRV_ERR_BOARD_IN_USE</A> - The given board index is already in use. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_BOARD_CONNECT">SDVR_DRV_ERR_BOARD_CONNECT</A> - Failed to connect to the board. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_BOARD_CLOSE">SDVR_DRV_ERR_BOARD_CLOSE</A> - Failed while trying to close the board. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_BOARD_RESET">SDVR_DRV_ERR_BOARD_RESET</A> - Error code if failed to reset the DVR board. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_IPC_INIT">SDVR_DRV_ERR_IPC_INIT</A> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_NO_CHANNELS">SDVR_DRV_ERR_NO_CHANNELS</A> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_CHANNEL_IN_USE">SDVR_DRV_ERR_CHANNEL_IN_USE</A> - If a receive channel has not been closed by 
the firmware. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_CHANNEL_CREATE">SDVR_DRV_ERR_CHANNEL_CREATE</A> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_CHANNEL_CONNECT">SDVR_DRV_ERR_CHANNEL_CONNECT</A> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_CHANNEL_CLOSE">SDVR_DRV_ERR_CHANNEL_CLOSE</A> - If an error occurred while closing the 
channel, or the firmware did not respond correctly to the close request. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_CHANNEL_NOT_ACTIVE">SDVR_DRV_ERR_CHANNEL_NOT_ACTIVE</A> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_CHANNEL_DEAD">SDVR_DRV_ERR_CHANNEL_DEAD</A> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_NO_RECV_BUFFERS">SDVR_DRV_ERR_NO_RECV_BUFFERS</A> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_NO_SEND_BUFFERS">SDVR_DRV_ERR_NO_SEND_BUFFERS</A> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_MSG_SEND">SDVR_DRV_ERR_MSG_SEND</A> - Error code if the driver failed to send the 
command to the firmware. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_MSG_RECV">SDVR_DRV_ERR_MSG_RECV</A> - Error code if the driver timeout while waiting 
to receive a response from the firmware. This error could be an indication 
that the code on the firmware hung. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DRV_BOARD_BOOT_FAIL">SDVR_DRV_BOARD_BOOT_FAIL</A> - Failed to boot PCI board. 
</LI>
<LI>
<STRONG>Following error codes are generated by the DVR SDK:</STRONG> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_OUT_OF_MEMORY">SDVR_ERR_OUT_OF_MEMORY</A> - System is out of memory. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INVALID_HANDLE">SDVR_ERR_INVALID_HANDLE</A> - Invalid buffer handle. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INVALID_ARG">SDVR_ERR_INVALID_ARG</A> - Invalid argument to a function call. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INVALID_BOARD">SDVR_ERR_INVALID_BOARD</A> - Invalid board number. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_BOARD_CONNECTED">SDVR_ERR_BOARD_CONNECTED</A> - The current operation is invalid while 
connecting to a board (i.e., setting SDK parameters or connect to a board 
that is already connected). 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INVALID_CHANNEL">SDVR_ERR_INVALID_CHANNEL</A> - Invalid channel number. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_CHANNEL_CLOSED">SDVR_ERR_CHANNEL_CLOSED</A> - Channel is closed - cannot communicate with it. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_BOARD_CLOSED">SDVR_ERR_BOARD_CLOSED</A> - Board is closed - cannot communicate with it. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NO_VFRAME">SDVR_ERR_NO_VFRAME</A> - No video frame is available. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NO_AFRAME">SDVR_ERR_NO_AFRAME</A> - No audio frame is available. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INTERNAL">SDVR_ERR_INTERNAL</A> - Internal error in the SDK. Please contact 
Stretch support for assistance. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_BOARD_NOT_CONNECTED">SDVR_ERR_BOARD_NOT_CONNECTED</A> - The specified board index was not 
connected. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_IN_STREAMING">SDVR_ERR_IN_STREAMING</A> - Failed to close the board because some channels 
are still active (encoding or decoding). 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NO_DVR_BOARD">SDVR_ERR_NO_DVR_BOARD</A> - No PCIe DVR board was found on the PC. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_WRONG_DRIVER_VERSION">SDVR_ERR_WRONG_DRIVER_VERSION</A> - The current DVR PCIe driver is 
not supported. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_DBG_FILE">SDVR_ERR_DBG_FILE</A> - Failed to open the debug file. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_ENCODER_NOT_ENABLED">SDVR_ERR_ENCODER_NOT_ENABLED</A> - Failed to start the encoder on the 
given channel. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_ENCODER_NOT_DISABLED">SDVR_ERR_ENCODER_NOT_DISABLED</A> - Failed to stop the encoder on the 
given channel. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_SDK_NO_FRAME_BUF">SDVR_ERR_SDK_NO_FRAME_BUF</A> - There is not enough buffer allocated to 
receive encoded or raw frame buffers. Or the frame size is zero. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INVALID_FRAME_TYPE">SDVR_ERR_INVALID_FRAME_TYPE</A> - The given frame type is not supported. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NOBUF">SDVR_ERR_NOBUF</A> - No A/V buffer is available. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_CALLBACK_FAILED">SDVR_ERR_CALLBACK_FAILED</A> - Failed to register callback with the driver. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INVALID_CHAN_HANDLE">SDVR_ERR_INVALID_CHAN_HANDLE</A> - The given channel handle is invalid. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_COMMAND_NOT_SUPPORTED">SDVR_ERR_COMMAND_NOT_SUPPORTED</A> - The function is not implemented. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_ODD_SMO_COORDINATES">SDVR_ERR_ODD_SMO_COORDINATES</A> - Error code if either of the x or y value of the 
SMO grid is an odd number. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_LOAD_FIRMWARE">SDVR_ERR_LOAD_FIRMWARE</A> - Error code if failed to load the firmware. This 
could be as result of invalid file path or failure to load from PCIe driver. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_WRONG_CHANNEL_TYPE">SDVR_ERR_WRONG_CHANNEL_TYPE</A> - The channel handle belongs to wrong channel 
type for the current operation. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_DECODER_NOT_ENABLED">SDVR_ERR_DECODER_NOT_ENABLED</A> - Error code if we are trying to send 
frames to be decoded but the decoder is not enabled. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_BUF_NOT_AVAIL">SDVR_ERR_BUF_NOT_AVAIL</A> - Error code if no buffer is available to send 
frames. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_MAX_REGIONS">SDVR_ERR_MAX_REGIONS</A> - Error code if the maximum allowed regions is reached 
when you request to add a new motion or blind detection as well as 
privacy region. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INVALID_REGION">SDVR_ERR_INVALID_REGION</A> - Error code if the given region is either does 
not exist or is invalid. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INVALID_GOP">SDVR_ERR_INVALID_GOP</A> - Error code if the specified GOP value of the 
encoder parameter to be set is zero. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INVALID_BITRATE">SDVR_ERR_INVALID_BITRATE</A> - Error code if the specified maximum bit rate is 
less than the average bit rate while setting the encoder parameters. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INVALID_BITRATE_CONTROL">SDVR_ERR_INVALID_BITRATE_CONTROL</A> - Error code if an unknown encoder bit rate 
control is specified. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INVALID_QUALITY">SDVR_ERR_INVALID_QUALITY</A> - Error code if the encoder quality parameter 
is out of range for the current video encoder. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INVALID_FPS">SDVR_ERR_INVALID_FPS</A> - Error code if the specified encoder frame rate is 
not supported by the current video standard. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_UNSUPPORTED_FIRMWARE">SDVR_ERR_UNSUPPORTED_FIRMWARE</A> - Error code if the DVR firmware version is 
not supported by the current version of SDK. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INVALID_OSD_ID">SDVR_ERR_INVALID_OSD_ID</A> - Error code if the specified OSD ID has not been 
configured before using or is out of the valid range of OSD items on a 
channel. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_OSD_LENGTH">SDVR_ERR_OSD_LENGTH</A> - Error code if the given OSD text length is too large. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_OSD_FONT_FILE">SDVR_ERR_OSD_FONT_FILE</A> - Error code if the given font table file does not 
exist, is invalid, or can not be opened. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_FONT_ID">SDVR_ERR_FONT_ID</A> - Error code if the given font ID does not fall within 
the valid range or the font table with this ID does not exist. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_CAMERA_IN_REC">SDVR_ERR_CAMERA_IN_REC</A> - Error code if the camera that is being 
requested for recording, is currently in recording. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_OPEN_REC_FILE">SDVR_ERR_OPEN_REC_FILE</A> - Error code for failure  to open the given 
file for recording. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_FAILED_ADD_VIDEO_TRACK">SDVR_ERR_FAILED_ADD_VIDEO_TRACK</A> - Error code for failure to add 
the video track to the recording file. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_FAILED_ADD_AUDIO_TRACK">SDVR_ERR_FAILED_ADD_AUDIO_TRACK</A> - Error code for failure  to add 
the audio track to the recording file. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_SDK_BUF_EXCEEDED">SDVR_ERR_SDK_BUF_EXCEEDED</A> - Error code if any buffer size, while 
setting up SDK buffers, exceeds the maximum allowed. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_AUDIO_RUNTIME">SDVR_FRMW_ERR_AUDIO_RUNTIME</A> - Error code if audio buffers overflow. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_AUTH_KEY_MISSING">SDVR_ERR_AUTH_KEY_MISSING</A> - Error code if a required authentication key 
is missing on the DVR board while connecting to it. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_AUTH_KEY_LEN">SDVR_ERR_AUTH_KEY_LEN</A> - Error code if the size of authentication key is 
larger than what the SDK can support. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INVALID_RESOLUTION">SDVR_ERR_INVALID_RESOLUTION</A> - Error code if the specified resolution 
decimation is not supported by the current operation. (i.e. DCIF or 
2CIF resolution is not supported in SMO). 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_SMO_PORT_NUM">SDVR_ERR_SMO_PORT_NUM</A> - Error code if the given SMO port number does not 
exist on the DVR board. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_diag_code_e"></a>
<PRE class="cdef">
typedef enum _sdvr_diag_code_e {
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_OK">SDVR_DIAG_OK</A> = 0x00000000,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_DDR_WRITEREAD_FAIL">SDVR_DIAG_DDR_WRITEREAD_FAIL</A> = 0xb007e001,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_DDR_ADDRLINES_FAIL">SDVR_DIAG_DDR_ADDRLINES_FAIL</A> = 0xb007e002,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_DDR_BITFLIP_FAIL">SDVR_DIAG_DDR_BITFLIP_FAIL</A> = 0xb007e003,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_DDR_DMA_FAIL">SDVR_DIAG_DDR_DMA_FAIL</A> = 0xb007e004,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_DDR_READ_DMA_FAIL">SDVR_DIAG_DDR_READ_DMA_FAIL</A> = 0xb007e005,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_PLL_TEST_MHZ">SDVR_DIAG_PLL_TEST_MHZ</A> = 0x1000e001,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_PLL_TEST_SYS">SDVR_DIAG_PLL_TEST_SYS</A> = 0x1000e002,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_PLL_TEST_IO">SDVR_DIAG_PLL_TEST_IO</A> = 0x1000e003,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_PLL_TEST_AIM">SDVR_DIAG_PLL_TEST_AIM</A> = 0x1000e004,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_PLL_TEST_DP0">SDVR_DIAG_PLL_TEST_DP0</A> = 0x1000e005,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_PLL_TEST_DP2">SDVR_DIAG_PLL_TEST_DP2</A> = 0x1000e006,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_PLL_TEST_DDR">SDVR_DIAG_PLL_TEST_DDR</A> = 0x1000e007,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_SPI_TEST_READ">SDVR_DIAG_SPI_TEST_READ</A> = 0x1001e001,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_SPI_TEST_ERASE">SDVR_DIAG_SPI_TEST_ERASE</A> = 0x1001e002,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_SPI_TEST_PROG">SDVR_DIAG_SPI_TEST_PROG</A> = 0x1001e003,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_SPI_TEST_UNLOCK">SDVR_DIAG_SPI_TEST_UNLOCK</A> = 0x1001e004,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_SPI_TEST_COMPARE">SDVR_DIAG_SPI_TEST_COMPARE</A> = 0x1001e005,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_SPI_TEST_MAINT">SDVR_DIAG_SPI_TEST_MAINT</A> = 0x1001e006,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_SPI_TEST_MISC">SDVR_DIAG_SPI_TEST_MISC</A> = 0x1001e007,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_TWI_EEPROM_TEST_READ">SDVR_DIAG_TWI_EEPROM_TEST_READ</A> = 0x1002e001,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_TWI_EEPROM_TEST_WRITE">SDVR_DIAG_TWI_EEPROM_TEST_WRITE</A> = 0x1002e002,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_TWI_EEPROM_TEST_INIT">SDVR_DIAG_TWI_EEPROM_TEST_INIT</A> = 0x1002e003,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_TWI_EEPROM_TEST_COMPARE">SDVR_DIAG_TWI_EEPROM_TEST_COMPARE</A> = 0x1002e004,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_TWI_EEPROM_TEST_WP_COMPARE">SDVR_DIAG_TWI_EEPROM_TEST_WP_COMPARE</A> = 0x1002e005,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_EPSON_REG_TEST_INIT">SDVR_DIAG_EPSON_REG_TEST_INIT</A> = 0x1003e001,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_EPSON_REG_TEST_WALKING">SDVR_DIAG_EPSON_REG_TEST_WALKING</A> = 0x1003e002,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_DECODER_AUDIO_TEST_INIT">SDVR_DIAG_DECODER_AUDIO_TEST_INIT</A> = 0x1004e001,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_DECODER_AUDIO_TEST_NO_AUDIO">SDVR_DIAG_DECODER_AUDIO_TEST_NO_AUDIO</A> = 0x1004e002,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_TW2815_REG_TEST">SDVR_DIAG_TW2815_REG_TEST</A> = 0x1004e003,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_TW2864_REG_TEST">SDVR_DIAG_TW2864_REG_TEST</A> = 0x1004e013,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_DECODER_VIDEO_TEST_INIT">SDVR_DIAG_DECODER_VIDEO_TEST_INIT</A> = 0x1004e004,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_DECODER_VIDEO_TEST_NO_VIDEO">SDVR_DIAG_DECODER_VIDEO_TEST_NO_VIDEO</A> = 0x1004e005,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_DECODER_VIDEO_TEST_TIMEOUT">SDVR_DIAG_DECODER_VIDEO_TEST_TIMEOUT</A> = 0x1004e015,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_DECODER_VIDDET_TEST_INIT_ERR">SDVR_DIAG_DECODER_VIDDET_TEST_INIT_ERR</A> = 0x1004e006,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_DECODER_VIDDET_TEST_UNKNOWN_CHIP">SDVR_DIAG_DECODER_VIDDET_TEST_UNKNOWN_CHIP</A> = 0x1004e007,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_DECODER_VIDDET_TEST_NO_INPUT_ERR">SDVR_DIAG_DECODER_VIDDET_TEST_NO_INPUT_ERR</A> = 0x1004e008,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_DECODER_VIDDET_TEST_CONFLICT_ERR">SDVR_DIAG_DECODER_VIDDET_TEST_CONFLICT_ERR</A> = 0x1004e009,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_DECODER_VIDDET_TEST_NO_SYNC_ERR">SDVR_DIAG_DECODER_VIDDET_TEST_NO_SYNC_ERR</A> = 0x1004e00a,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_DECODER_AUDDET_TEST_NO_SYNC_ERR">SDVR_DIAG_DECODER_AUDDET_TEST_NO_SYNC_ERR</A> = 0x1004e00b,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_DECODER_UNIQUE_VIDEO_TEST">SDVR_DIAG_DECODER_UNIQUE_VIDEO_TEST</A> = 0x1004e00c,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_NVP1104_REG_TEST">SDVR_DIAG_NVP1104_REG_TEST</A> = 0x1004e01d,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_NVP1114_REG_TEST">SDVR_DIAG_NVP1114_REG_TEST</A> = 0x1004e00d,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_DECODER_AUDIO_TEST_TIMEOUT">SDVR_DIAG_DECODER_AUDIO_TEST_TIMEOUT</A> = 0x1004e00e,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_PCIE_EYEMASK_TEST_NO_CBB">SDVR_DIAG_PCIE_EYEMASK_TEST_NO_CBB</A> = 0x1005e001,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_PCIE_EYEMASK_TEST_ERR">SDVR_DIAG_PCIE_EYEMASK_TEST_ERR</A> = 0x1005e002,
    <A name="sdvr_sdk_html_Types__SDVR_DIAG_PCIE_EYEMASK_TEST_TIMEOUT">SDVR_DIAG_PCIE_EYEMASK_TEST_TIMEOUT</A> = 0x1005e003
} <A HREF="#sdvr_sdk_html_Types__sdvr_diag_code_e">sdvr_diag_code_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
Typedef for the board diagnostics codes. 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_OK">SDVR_DIAG_OK</A> - All the diagnostic tests passed. 
</LI>
</UL>
<P>
<STRONG>Diagnostics failure codes for Boot-loader DDR test:</STRONG> 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DDR_WRITEREAD_FAIL">SDVR_DIAG_DDR_WRITEREAD_FAIL</A> - DDR write/read test failed. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DDR_ADDRLINES_FAIL">SDVR_DIAG_DDR_ADDRLINES_FAIL</A> - DDR address lines test failed. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DDR_BITFLIP_FAIL">SDVR_DIAG_DDR_BITFLIP_FAIL</A>   - DDR bit-flip test failed. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DDR_DMA_FAIL">SDVR_DIAG_DDR_DMA_FAIL</A>       - DDR DMA test failed. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DDR_READ_DMA_FAIL">SDVR_DIAG_DDR_READ_DMA_FAIL</A>  - DDR read/DMA test failed. 
</LI>
</UL>
<P>
<STRONG>Diagnostics failure codes for PLL test:</STRONG> 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_PLL_TEST_MHZ">SDVR_DIAG_PLL_TEST_MHZ</A>       - Processor speed test failed. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_PLL_TEST_SYS">SDVR_DIAG_PLL_TEST_SYS</A>       - PLL_SYS test failed. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_PLL_TEST_IO">SDVR_DIAG_PLL_TEST_IO</A>        - PLL_IO test failed. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_PLL_TEST_AIM">SDVR_DIAG_PLL_TEST_AIM</A>       - PLL_AIM test failed. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_PLL_TEST_DP0">SDVR_DIAG_PLL_TEST_DP0</A>       - PLL_DP0 test failed. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_PLL_TEST_DP2">SDVR_DIAG_PLL_TEST_DP2</A>       - PLL_DP2 test failed. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_PLL_TEST_DDR">SDVR_DIAG_PLL_TEST_DDR</A>       - DLL_DDR test failed. 
</LI>
</UL>
<P>
<STRONG>Diagnostics failure codes for SPI flash test:</STRONG> 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_SPI_TEST_READ">SDVR_DIAG_SPI_TEST_READ</A>      - Flash read error. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_SPI_TEST_ERASE">SDVR_DIAG_SPI_TEST_ERASE</A>     - Flash erase error. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_SPI_TEST_PROG">SDVR_DIAG_SPI_TEST_PROG</A>      - Flash program error. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_SPI_TEST_UNLOCK">SDVR_DIAG_SPI_TEST_UNLOCK</A>    - Flash unlock error. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_SPI_TEST_COMPARE">SDVR_DIAG_SPI_TEST_COMPARE</A>   - Flash data compare error. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_SPI_TEST_MAINT">SDVR_DIAG_SPI_TEST_MAINT</A>     - Flash maintenance command error. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_SPI_TEST_MISC">SDVR_DIAG_SPI_TEST_MISC</A>      - Miscellaneous Flash error. 
</LI>
</UL>
<P>
<STRONG>Diagnostics failure codes for TWI EEPROM test:</STRONG> 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_TWI_EEPROM_TEST_READ">SDVR_DIAG_TWI_EEPROM_TEST_READ</A>     - TWI EEPROM read error. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_TWI_EEPROM_TEST_WRITE">SDVR_DIAG_TWI_EEPROM_TEST_WRITE</A>    - TWI EEPROM write error. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_TWI_EEPROM_TEST_INIT">SDVR_DIAG_TWI_EEPROM_TEST_INIT</A>     - TWI EEPROM initialization error. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_TWI_EEPROM_TEST_COMPARE">SDVR_DIAG_TWI_EEPROM_TEST_COMPARE</A>  - TWI EEPROM data compare error. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_TWI_EEPROM_TEST_WP_COMPARE">SDVR_DIAG_TWI_EEPROM_TEST_WP_COMPARE</A> - TWI EEPROM write-protect error. 
</LI>
</UL>
<P>
<STRONG>Diagnostics failure codes for Epson test:</STRONG> 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_EPSON_REG_TEST_INIT">SDVR_DIAG_EPSON_REG_TEST_INIT</A>     - Epson test initialization error. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_EPSON_REG_TEST_WALKING">SDVR_DIAG_EPSON_REG_TEST_WALKING</A>  - Epson register bit-walk error. 
</LI>
</UL>
<P>
<STRONG>Diagnostics failure codes for Decoder test:</STRONG> 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DECODER_AUDIO_TEST_INIT">SDVR_DIAG_DECODER_AUDIO_TEST_INIT</A>      - Decoder audio test init error. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DECODER_AUDIO_TEST_NO_AUDIO">SDVR_DIAG_DECODER_AUDIO_TEST_NO_AUDIO</A>  - Decoder audio not received error. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_TW2815_REG_TEST">SDVR_DIAG_TW2815_REG_TEST</A>             - Techwell register test error. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_TW2864_REG_TEST">SDVR_DIAG_TW2864_REG_TEST</A>             - Techwell register test error. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DECODER_VIDEO_TEST_INIT">SDVR_DIAG_DECODER_VIDEO_TEST_INIT</A>      - Decoder video test init error. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DECODER_VIDEO_TEST_NO_VIDEO">SDVR_DIAG_DECODER_VIDEO_TEST_NO_VIDEO</A>  - Decoder video not received error. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DECODER_VIDEO_TEST_TIMEOUT">SDVR_DIAG_DECODER_VIDEO_TEST_TIMEOUT</A>   - Decoder video test timeout error. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DECODER_VIDDET_TEST_INIT_ERR">SDVR_DIAG_DECODER_VIDDET_TEST_INIT_ERR</A>     - Decoder video detect test init error. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DECODER_VIDDET_TEST_UNKNOWN_CHIP">SDVR_DIAG_DECODER_VIDDET_TEST_UNKNOWN_CHIP</A> - Decoder video detect test unknown chip error. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DECODER_VIDDET_TEST_NO_INPUT_ERR">SDVR_DIAG_DECODER_VIDDET_TEST_NO_INPUT_ERR</A> - Decoder video detect test no input error. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DECODER_VIDDET_TEST_CONFLICT_ERR">SDVR_DIAG_DECODER_VIDDET_TEST_CONFLICT_ERR</A> - Decoder video detect test conflict error. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DECODER_VIDDET_TEST_NO_SYNC_ERR">SDVR_DIAG_DECODER_VIDDET_TEST_NO_SYNC_ERR</A>  - Decoder video detect test no synch. error. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DECODER_AUDDET_TEST_NO_SYNC_ERR">SDVR_DIAG_DECODER_AUDDET_TEST_NO_SYNC_ERR</A>  - Decoder audio detect test no sync. error. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DECODER_UNIQUE_VIDEO_TEST">SDVR_DIAG_DECODER_UNIQUE_VIDEO_TEST</A> - Video inputs are not unique 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_NVP1104_REG_TEST">SDVR_DIAG_NVP1104_REG_TEST</A> - Nextchip register test error 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_NVP1114_REG_TEST">SDVR_DIAG_NVP1114_REG_TEST</A> - Nextchip register test error 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DECODER_AUDIO_TEST_TIMEOUT">SDVR_DIAG_DECODER_AUDIO_TEST_TIMEOUT</A> - Decoder audio test timeout error. 
</LI>
</UL>
<P>
<STRONG>Diagnostics failure codes for PCIe test:</STRONG> 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_PCIE_EYEMASK_TEST_NO_CBB">SDVR_DIAG_PCIE_EYEMASK_TEST_NO_CBB</A>    - PCIe did not detect the CBB test board. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_PCIE_EYEMASK_TEST_ERR">SDVR_DIAG_PCIE_EYEMASK_TEST_ERR</A>       - PCIe eye mask test failure. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_PCIE_EYEMASK_TEST_TIMEOUT">SDVR_DIAG_PCIE_EYEMASK_TEST_TIMEOUT</A>   - PCIe eye mask test timeout. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_chan_handle_t"></a>
<PRE class="cdef">
typedef <A HREF="#sdvr_sdk_html_Types__sx_int32">sx_int32</A> <A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>; 
</PRE>
<DIV CLASS="descr">
<P>
A handle to a channel. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_signals_type_e"></a>
<PRE class="cdef">
typedef <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> <A HREF="#sdvr_sdk_html_Types__sdvr_signals_type_e">sdvr_signals_type_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
Microsoft compiler work around, <A HREF="#sdvr_sdk_html_Types__sdvr_signals_type_e">sdvr_signals_type_e</A> cannot 
be enum because it is being used as :8 bit in the data structure. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types____sdvr_signals_type_e"></a>
<PRE class="cdef">
typedef enum _sdvr_signals_type_e {
    <A name="sdvr_sdk_html_Types__SDVR_SIGNAL_RUNTIME_ERROR">SDVR_SIGNAL_RUNTIME_ERROR</A> = 1,
    <A name="sdvr_sdk_html_Types__SDVR_SIGNAL_FATAL_ERROR">SDVR_SIGNAL_FATAL_ERROR</A>
} <A HREF="#sdvr_sdk_html_Types____sdvr_signals_type_e">__sdvr_signals_type_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
This enumerated type defines the types of asynchronous messages 
that can be sent from the DVR firmware to the DVR Application. 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_SIGNAL_RUNTIME_ERROR">SDVR_SIGNAL_RUNTIME_ERROR</A> - Indicates that a non-fatal runtime 
error has occurred on the board. There is extra data associated with 
this signal that gives more information regarding the error. The 
meaning of those values varies depending on where the error occurred. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_SIGNAL_FATAL_ERROR">SDVR_SIGNAL_FATAL_ERROR</A> - Indicates that a fatal error has 
occurred on the board. If this signal is received, the board must 
be reset. There is extra data associated with 
this signal that gives more information regarding the error. The 
meaning of those values varies depending on where the error occurred. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_video_alarm_e"></a>
<PRE class="cdef">
typedef enum _sdvr_video_alarm_e {
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_ALARM_NONE">SDVR_VIDEO_ALARM_NONE</A>,
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_ALARM_MOTION">SDVR_VIDEO_ALARM_MOTION</A>,
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_ALARM_BLIND">SDVR_VIDEO_ALARM_BLIND</A>,
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_ALARM_NIGHT">SDVR_VIDEO_ALARM_NIGHT</A>,
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_ALARM_LOSS">SDVR_VIDEO_ALARM_LOSS</A>,
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_ALARM_DETECTED">SDVR_VIDEO_ALARM_DETECTED</A>
} <A HREF="#sdvr_sdk_html_Types__sdvr_video_alarm_e">sdvr_video_alarm_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
This enumerated type defines the types of events that 
can be detected by the video encoder. 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_ALARM_NONE">SDVR_VIDEO_ALARM_NONE</A> - No event or alarm. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_ALARM_MOTION">SDVR_VIDEO_ALARM_MOTION</A> - Motion detected. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_ALARM_BLIND">SDVR_VIDEO_ALARM_BLIND</A> - Blind detected. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_ALARM_NIGHT">SDVR_VIDEO_ALARM_NIGHT</A> - Night detected. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_ALARM_LOSS">SDVR_VIDEO_ALARM_LOSS</A> - Video loss detected. If a channel is set 
to be an encoding channel and no camera is connected to it, this 
video alarm is triggered whenever the encoder is enabled. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_ALARM_DETECTED">SDVR_VIDEO_ALARM_DETECTED</A> - This alarm is sent when a video signal 
is detected on an encoding channel that was created but had no video 
signal previously. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_regions_type_e"></a>
<PRE class="cdef">
typedef enum _sdvr_regions_type_e {
    <A name="sdvr_sdk_html_Types__SDVR_REGION_MOTION">SDVR_REGION_MOTION</A> = 1,
    <A name="sdvr_sdk_html_Types__SDVR_REGION_BLIND">SDVR_REGION_BLIND</A> = 2,
    <A name="sdvr_sdk_html_Types__SDVR_REGION_PRIVACY">SDVR_REGION_PRIVACY</A> = 4
} <A HREF="#sdvr_sdk_html_Types__sdvr_regions_type_e">sdvr_regions_type_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
This enumerated type defines the types of regions that 
can be defined for a camera. 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_REGION_MOTION">SDVR_REGION_MOTION</A> - Motion detected region. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_REGION_BLIND">SDVR_REGION_BLIND</A> - Blind detected region. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_REGION_PRIVACY">SDVR_REGION_PRIVACY</A> - Privacy region. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types____sdvr_frame_type_e"></a>
<PRE class="cdef">
typedef enum _sdvr_frame_type_e {
    <A name="sdvr_sdk_html_Types__SDVR_FRAME_RAW_AUDIO">SDVR_FRAME_RAW_AUDIO</A> = 3,
    <A name="sdvr_sdk_html_Types__SDVR_FRAME_H264_IDR">SDVR_FRAME_H264_IDR</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRAME_H264_I">SDVR_FRAME_H264_I</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRAME_H264_P">SDVR_FRAME_H264_P</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRAME_H264_B">SDVR_FRAME_H264_B</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRAME_H264_SPS">SDVR_FRAME_H264_SPS</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRAME_H264_PPS">SDVR_FRAME_H264_PPS</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRAME_JPEG">SDVR_FRAME_JPEG</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRAME_G711">SDVR_FRAME_G711</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRAME_MPEG4_I">SDVR_FRAME_MPEG4_I</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRAME_MPEG4_P">SDVR_FRAME_MPEG4_P</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRAME_MPEG4_B">SDVR_FRAME_MPEG4_B</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRAME_MPEG4_VOL">SDVR_FRAME_MPEG4_VOL</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRAME_MOTION_VALUES">SDVR_FRAME_MOTION_VALUES</A> = 18,
    <A name="sdvr_sdk_html_Types__SDVR_FRAME_RAW_VIDEO">SDVR_FRAME_RAW_VIDEO</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRAME_VIDEO_ENCODED_PRIMARY">SDVR_FRAME_VIDEO_ENCODED_PRIMARY</A> = 100,
    <A name="sdvr_sdk_html_Types__SDVR_FRAME_VIDEO_ENCODED_SECONDARY">SDVR_FRAME_VIDEO_ENCODED_SECONDARY</A>,
    <A name="sdvr_sdk_html_Types__SDVR_FRAME_AUDIO_ENCODED">SDVR_FRAME_AUDIO_ENCODED</A>
} <A HREF="#sdvr_sdk_html_Types____sdvr_frame_type_e">__sdvr_frame_type_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
This enumerated type defines the kind of frames that can 
be exchanged between the SDK and the DVR Application. 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_RAW_VIDEO">SDVR_FRAME_RAW_VIDEO</A> - Generic Raw video frame type. This is the 
type to pass to <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_yuv_buffer">sdvr_get_yuv_buffer</A>()</NOBR> to get the raw video frames. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_RAW_AUDIO">SDVR_FRAME_RAW_AUDIO</A> - Generic Raw audio PCM frame. This is the 
type to pass to <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_av_buffer">sdvr_get_av_buffer</A>()</NOBR> to get the raw audio frames. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_H264_IDR">SDVR_FRAME_H264_IDR</A> - Encoded H.264 IDR frame. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_H264_I">SDVR_FRAME_H264_I</A>   - Encoded H.264 I frame. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_H264_P">SDVR_FRAME_H264_P</A>   - Encoded H.264 P frame. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_H264_B">SDVR_FRAME_H264_B</A>   - Encoded H.264 B frame. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_H264_SPS">SDVR_FRAME_H264_SPS</A> - Encoded H.264 SPS frame. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_H264_PPS">SDVR_FRAME_H264_PPS</A> - Encoded H.264 PPS frame. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_JPEG">SDVR_FRAME_JPEG</A> - Encoded JPEG image frame. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_G711">SDVR_FRAME_G711</A> - Encoded G.711 audio frame. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_MPEG4_I">SDVR_FRAME_MPEG4_I</A>   - Encoded MPEG4 I frame. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_MPEG4_P">SDVR_FRAME_MPEG4_P</A>   - Encoded MPEG4 P frame. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_MPEG4_VOL">SDVR_FRAME_MPEG4_VOL</A> - Encoded MPEG4 VOL frame which contains 
the video frame header information. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_MOTION_VALUES">SDVR_FRAME_MOTION_VALUES</A> - Macro Block (MB) based motion values 
buffer. Each element in this buffer contains the motion value 
from 0 to 255 indicating amount of motion for a particular 
MB. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_VIDEO_ENCODED_PRIMARY">SDVR_FRAME_VIDEO_ENCODED_PRIMARY</A> - Any encoded video frame from the 
primary encoder. This is the 
type to pass to <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_av_buffer">sdvr_get_av_buffer</A>()</NOBR> to get the primary encoded video frames. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_VIDEO_ENCODED_SECONDARY">SDVR_FRAME_VIDEO_ENCODED_SECONDARY</A> - Any encoded video frame from the 
secondary encoder. This is the 
type to pass to <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_av_buffer">sdvr_get_av_buffer</A>()</NOBR> to get the secondary encoded video frames. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_AUDIO_ENCODED">SDVR_FRAME_AUDIO_ENCODED</A> - Any encoded audio frame. This is the 
type to pass to <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_av_buffer">sdvr_get_av_buffer</A>()</NOBR> to get the encoded audio frames. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_frame_type_e"></a>
<PRE class="cdef">
typedef <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> <A HREF="#sdvr_sdk_html_Types__sdvr_frame_type_e">sdvr_frame_type_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
Microsoft compiler work around, <A HREF="#sdvr_sdk_html_Types__sdvr_frame_type_e">sdvr_frame_type_e</A> cannot 
be enum because it is being used as :8 bit in the data structure. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_location_e"></a>
<PRE class="cdef">
typedef enum _sdvr_location_e {
    <A name="sdvr_sdk_html_Types__SDVR_LOC_TOP_LEFT">SDVR_LOC_TOP_LEFT</A> = 0,
    <A name="sdvr_sdk_html_Types__SDVR_LOC_BOTTOM_LEFT">SDVR_LOC_BOTTOM_LEFT</A>,
    <A name="sdvr_sdk_html_Types__SDVR_LOC_TOP_RIGHT">SDVR_LOC_TOP_RIGHT</A>,
    <A name="sdvr_sdk_html_Types__SDVR_LOC_BOTTOM_RIGHT">SDVR_LOC_BOTTOM_RIGHT</A>,
    <A name="sdvr_sdk_html_Types__SDVR_LOC_CUSTOM">SDVR_LOC_CUSTOM</A>
} <A HREF="#sdvr_sdk_html_Types__sdvr_location_e">sdvr_location_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
Typedef describing locations for OSD. 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_LOC_TOP_LEFT">SDVR_LOC_TOP_LEFT</A> - Top left of the screen 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_LOC_TOP_RIGHT">SDVR_LOC_TOP_RIGHT</A> - Top right of the screen 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_LOC_BOTTOM_LEFT">SDVR_LOC_BOTTOM_LEFT</A> - Bottom left of the screen 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_LOC_BOTTOM_RIGHT">SDVR_LOC_BOTTOM_RIGHT</A> - Bottom right of the screen 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_LOC_CUSTOM">SDVR_LOC_CUSTOM</A> - A user-defined position. The upper left corner of 
the video frame is the origin (0,0). 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_video_std_e"></a>
<PRE class="cdef">
typedef enum _sdvr_video_std_e {
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_STD_NONE">SDVR_VIDEO_STD_NONE</A> = 0,
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_STD_D1_PAL">SDVR_VIDEO_STD_D1_PAL</A> = (1 << 0),
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_STD_D1_NTSC">SDVR_VIDEO_STD_D1_NTSC</A> = (1 << 1),
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_STD_CIF_PAL">SDVR_VIDEO_STD_CIF_PAL</A> = (1 << 2),
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_STD_CIF_NTSC">SDVR_VIDEO_STD_CIF_NTSC</A> = (1 << 3),
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_STD_2CIF_PAL">SDVR_VIDEO_STD_2CIF_PAL</A> = (1 << 4),
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_STD_2CIF_NTSC">SDVR_VIDEO_STD_2CIF_NTSC</A> = (1 << 5),
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_STD_4CIF_PAL">SDVR_VIDEO_STD_4CIF_PAL</A> = (1 << 6),
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_STD_4CIF_NTSC">SDVR_VIDEO_STD_4CIF_NTSC</A> = (1 << 7),
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_STD_QCIF_PAL">SDVR_VIDEO_STD_QCIF_PAL</A> = (1 << 8),
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_STD_QCIF_NTSC">SDVR_VIDEO_STD_QCIF_NTSC</A> = (1 << 9)
} <A HREF="#sdvr_sdk_html_Types__sdvr_video_std_e">sdvr_video_std_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
This enumerated type describes the video standards supported 
by SDVR. 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_STD_NONE">SDVR_VIDEO_STD_NONE</A> - No standard defined 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_STD_D1_PAL">SDVR_VIDEO_STD_D1_PAL</A>  - PAL 720x576 at 25 fps. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_STD_D1_NTSC">SDVR_VIDEO_STD_D1_NTSC</A> - NTSC 720x480 at 30 fps. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_STD_CIF_PAL">SDVR_VIDEO_STD_CIF_PAL</A> - PAL 352x288 at 25 fps. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_STD_CIF_NTSC">SDVR_VIDEO_STD_CIF_NTSC</A> - NTSC 352x240 at 30 fps. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_STD_2CIF_PAL">SDVR_VIDEO_STD_2CIF_PAL</A> - PAL 704x288 at 25 fps. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_STD_2CIF_NTSC">SDVR_VIDEO_STD_2CIF_NTSC</A> - NTSC 704x240 at 30 fps. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_STD_4CIF_PAL">SDVR_VIDEO_STD_4CIF_PAL</A> - PAL 704x576 at 25 fps. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_STD_4CIF_NTSC">SDVR_VIDEO_STD_4CIF_NTSC</A> - NTSC 704x480 at 30 fps. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_STD_QCIF_PAL">SDVR_VIDEO_STD_QCIF_PAL</A> - PAL 176x144 at 25 fps. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_STD_QCIF_NTSC">SDVR_VIDEO_STD_QCIF_NTSC</A> - NTSC 176x112 at 30 fps. 
<STRONG>NOTE: This is not an standard QCIF size 176x120</STRONG> 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_video_size_e"></a>
<PRE class="cdef">
typedef enum _sdvr_video_size_e {
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_720x576">SDVR_VIDEO_SIZE_720x576</A> = (1 << 0),
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_720x480">SDVR_VIDEO_SIZE_720x480</A> = (1 << 1),
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_352x288">SDVR_VIDEO_SIZE_352x288</A> = (1 << 2),
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_352x240">SDVR_VIDEO_SIZE_352x240</A> = (1 << 3),
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_704x288">SDVR_VIDEO_SIZE_704x288</A> = (1 << 4),
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_704x240">SDVR_VIDEO_SIZE_704x240</A> = (1 << 5),
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_704x576">SDVR_VIDEO_SIZE_704x576</A> = (1 << 6),
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_704x480">SDVR_VIDEO_SIZE_704x480</A> = (1 << 7),
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_176x144">SDVR_VIDEO_SIZE_176x144</A> = (1 << 8),
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_176x112">SDVR_VIDEO_SIZE_176x112</A> = (1 << 9),
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_528x320">SDVR_VIDEO_SIZE_528x320</A> = (1 << 10),
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_528x384">SDVR_VIDEO_SIZE_528x384</A> = (1 << 11),
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_720x288">SDVR_VIDEO_SIZE_720x288</A> = (1 << 12),
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_720x240">SDVR_VIDEO_SIZE_720x240</A> = (1 << 13)
} <A HREF="#sdvr_sdk_html_Types__sdvr_video_size_e">sdvr_video_size_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
This enumerated type describes the various supported video sizes. 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_720x576">SDVR_VIDEO_SIZE_720x576</A> - D1-PAL video width of 720 and number of 
lines of 576. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_720x480">SDVR_VIDEO_SIZE_720x480</A> - D1-NTSC video width of 720 and number of 
lines of 480. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_352x288">SDVR_VIDEO_SIZE_352x288</A> - CIF-PAL video width of 352 and number of 
lines of 288. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_352x240">SDVR_VIDEO_SIZE_352x240</A> - CIF-NTSC video width of 352 and number of 
lines of 240. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_704x288">SDVR_VIDEO_SIZE_704x288</A> - 2CIF-PAL video width of 704 and number of 
lines of 288. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_704x240">SDVR_VIDEO_SIZE_704x240</A> - 2CIF-NTSC video width of 704 and number of 
lines of 240. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_704x576">SDVR_VIDEO_SIZE_704x576</A> - 4CIF-PAL video width of 704 and number of 
lines of 576. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_704x480">SDVR_VIDEO_SIZE_704x480</A> - 4CIF-NTSC video width of 704 and number of 
lines of 480. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_176x144">SDVR_VIDEO_SIZE_176x144</A> - QCIF_PAL video width of 176 and number of 
lines of 144. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_176x112">SDVR_VIDEO_SIZE_176x112</A> - QCIF_NTSC video width of 176 and number of 
lines of 112. <STRONG>NOTE: This is not an standard QCIF size 176x120</STRONG> 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_528x320">SDVR_VIDEO_SIZE_528x320</A> - DCIF based on 4CIF NTSC video width of 528 and number of 
lines of 320. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_528x384">SDVR_VIDEO_SIZE_528x384</A> - DCIF based on 4CIF PAL video width of 528 and number of 
lines of 384. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_720x288">SDVR_VIDEO_SIZE_720x288</A> - HALF-D1-PAL video width of 720 and number of 
lines of 288. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_720x240">SDVR_VIDEO_SIZE_720x240</A> - HALF_D1-NTSC video width of 720 and number of 
lines of 240. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_chan_type_e"></a>
<PRE class="cdef">
typedef <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> <A HREF="#sdvr_sdk_html_Types__sdvr_chan_type_e">sdvr_chan_type_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
Microsoft compiler work around, <A HREF="#sdvr_sdk_html_Types__sdvr_chan_type_e">sdvr_chan_type_e</A> cannot 
be enum because it is being used as :8 bit in the data structure. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types____sdvr_chan_type_e"></a>
<PRE class="cdef">
typedef enum _sdvr_chan_type_e {
    <A name="sdvr_sdk_html_Types__SDVR_CHAN_TYPE_NONE">SDVR_CHAN_TYPE_NONE</A> = 255,
    <A name="sdvr_sdk_html_Types__SDVR_CHAN_TYPE_ENCODER">SDVR_CHAN_TYPE_ENCODER</A> = 0,
    <A name="sdvr_sdk_html_Types__SDVR_CHAN_TYPE_DECODER">SDVR_CHAN_TYPE_DECODER</A> = 2,
    <A name="sdvr_sdk_html_Types__SDVR_CHAN_TYPE_OUTPUT">SDVR_CHAN_TYPE_OUTPUT</A> = 0xF
} <A HREF="#sdvr_sdk_html_Types____sdvr_chan_type_e">__sdvr_chan_type_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
This enumerated type describes the kinds of channels supported 
by SDVR. To create a channel that only allows it to be used in HMO or 
SMO, you must use <A HREF="#sdvr_sdk_html_Types__SDVR_CHAN_TYPE_ENCODER">SDVR_CHAN_TYPE_ENCODER</A>, and set the encoder type to 
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_ENC_NONE">SDVR_VIDEO_ENC_NONE</A>. 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_CHAN_TYPE_NONE">SDVR_CHAN_TYPE_NONE</A> - Channel type not specified. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_CHAN_TYPE_ENCODER">SDVR_CHAN_TYPE_ENCODER</A> - Encoder channel. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_CHAN_TYPE_DECODER">SDVR_CHAN_TYPE_DECODER</A> - Decoder channel. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_CHAN_TYPE_OUTPUT">SDVR_CHAN_TYPE_OUTPUT</A> - To be used only by the SDK. The DVR Application 
should not use this channel type. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_vpp_mode_e"></a>
<PRE class="cdef">
typedef <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> <A HREF="#sdvr_sdk_html_Types__sdvr_vpp_mode_e">sdvr_vpp_mode_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
Microsoft compiler work around, <A HREF="#sdvr_sdk_html_Types__sdvr_vpp_mode_e">sdvr_vpp_mode_e</A> cannot 
be enum because it is being used as :8 bit in the data structure. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types___sdvr_vpp_mode_e"></a>
<PRE class="cdef">
enum <A HREF="#sdvr_sdk_html_Types___sdvr_vpp_mode_e">_sdvr_vpp_mode_e</A> {
    <A name="sdvr_sdk_html_Types__SDVR_VPP_MODE_SLATERAL">SDVR_VPP_MODE_SLATERAL</A> = 0,
    <A name="sdvr_sdk_html_Types__SDVR_VPP_MODE_ANALYTICS">SDVR_VPP_MODE_ANALYTICS</A> = 1
} ; 
</PRE>
<DIV CLASS="descr">
<P>
Enumerated type describing video pre-processing modes. 
</P>
<P>
<A HREF="#sdvr_sdk_html_Types__SDVR_VPP_MODE_ANALYTICS">SDVR_VPP_MODE_ANALYTICS</A>    Run VPP in analytics mode. 
</P>
<P>
<A HREF="#sdvr_sdk_html_Types__SDVR_VPP_MODE_SLATERAL">SDVR_VPP_MODE_SLATERAL</A>     Run VPP in Stretch-lateral-filter mode. 
</P>
<P>
<STRONG>NOTE</STRONG>: These enums are deprecated and will be removed in a future release. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_sub_encoders_e"></a>
<PRE class="cdef">
typedef enum _sdvr_sub_encoders_e {
    <A name="sdvr_sdk_html_Types__SDVR_ENC_PRIMARY">SDVR_ENC_PRIMARY</A>,
    <A name="sdvr_sdk_html_Types__SDVR_ENC_SECONDARY">SDVR_ENC_SECONDARY</A>
} <A HREF="#sdvr_sdk_html_Types__sdvr_sub_encoders_e">sdvr_sub_encoders_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
Enumerated type describing encoder subchannels supported 
by the SDVR. 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ENC_PRIMARY">SDVR_ENC_PRIMARY</A> - The primary encoder. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ENC_SECONDARY">SDVR_ENC_SECONDARY</A> - The secondary encoder. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_venc_e"></a>
<PRE class="cdef">
typedef enum _sdvr_venc_e {
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_ENC_NONE">SDVR_VIDEO_ENC_NONE</A>,
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_ENC_H264">SDVR_VIDEO_ENC_H264</A>,
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_ENC_JPEG">SDVR_VIDEO_ENC_JPEG</A>,
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_ENC_MPEG4">SDVR_VIDEO_ENC_MPEG4</A>
} <A HREF="#sdvr_sdk_html_Types__sdvr_venc_e">sdvr_venc_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
Enumerated type describing video encoders supported by the SDVR. 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_ENC_NONE">SDVR_VIDEO_ENC_NONE</A> - No video encoder specified. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_ENC_H264">SDVR_VIDEO_ENC_H264</A> - H.264 encoder. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_ENC_JPEG">SDVR_VIDEO_ENC_JPEG</A> - Motion JPEG encoder. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_ENC_MPEG4">SDVR_VIDEO_ENC_MPEG4</A> - MPEG4 encoder. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_aenc_e"></a>
<PRE class="cdef">
typedef enum _sdvr_aenc_e {
    <A name="sdvr_sdk_html_Types__SDVR_AUDIO_ENC_NONE">SDVR_AUDIO_ENC_NONE</A>,
    <A name="sdvr_sdk_html_Types__SDVR_AUDIO_ENC_G711">SDVR_AUDIO_ENC_G711</A>,
    <A name="sdvr_sdk_html_Types__SDVR_AUDIO_ENC_G726_16K">SDVR_AUDIO_ENC_G726_16K</A>,
    <A name="sdvr_sdk_html_Types__SDVR_AUDIO_ENC_G726_24K">SDVR_AUDIO_ENC_G726_24K</A>,
    <A name="sdvr_sdk_html_Types__SDVR_AUDIO_ENC_G726_32K">SDVR_AUDIO_ENC_G726_32K</A>,
    <A name="sdvr_sdk_html_Types__SDVR_AUDIO_ENC_G726_48K">SDVR_AUDIO_ENC_G726_48K</A>
} <A HREF="#sdvr_sdk_html_Types__sdvr_aenc_e">sdvr_aenc_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
Enumerated type describing audio encoders supported by the SDVR. 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_AUDIO_ENC_NONE">SDVR_AUDIO_ENC_NONE</A> - No audio encoder specified. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_AUDIO_ENC_G711">SDVR_AUDIO_ENC_G711</A> - G.711 audio encoder. 
</LI>
<LI>
SDVR_AUDIO_ENC_G726_16 - G.726 audio encoder at 16K bits/sec. 
</LI>
<LI>
SDVR_AUDIO_ENC_G726_24 - G.726 audio encoder at 24K bits/sec. 
</LI>
<LI>
SDVR_AUDIO_ENC_G726_32 - G.726 audio encoder at 32K bits/sec. 
</LI>
<LI>
SDVR_AUDIO_ENC_G726_48 - G.726 audio encoder at 48K bits/sec. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_video_res_decimation_e"></a>
<PRE class="cdef">
typedef enum _sdvr_video_res_decimation_e {
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_NONE">SDVR_VIDEO_RES_DECIMATION_NONE</A> = 0,
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_EQUAL">SDVR_VIDEO_RES_DECIMATION_EQUAL</A> = 1,
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_CIF">SDVR_VIDEO_RES_DECIMATION_CIF</A> = 2,
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_FOURTH">SDVR_VIDEO_RES_DECIMATION_FOURTH</A> = <A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_CIF">SDVR_VIDEO_RES_DECIMATION_CIF</A>,
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_QCIF">SDVR_VIDEO_RES_DECIMATION_QCIF</A> = 4,
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_SIXTEENTH">SDVR_VIDEO_RES_DECIMATION_SIXTEENTH</A> = <A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_QCIF">SDVR_VIDEO_RES_DECIMATION_QCIF</A>,
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_HALF">SDVR_VIDEO_RES_DECIMATION_HALF</A> = 5,
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_DCIF">SDVR_VIDEO_RES_DECIMATION_DCIF</A> = 6,
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_CLASSIC_CIF">SDVR_VIDEO_RES_DECIMATION_CLASSIC_CIF</A> = 7,
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_CLASSIC_2CIF">SDVR_VIDEO_RES_DECIMATION_CLASSIC_2CIF</A> = 8,
    <A name="sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_CLASSIC_4CIF">SDVR_VIDEO_RES_DECIMATION_CLASSIC_4CIF</A> = 9
} <A HREF="#sdvr_sdk_html_Types__sdvr_video_res_decimation_e">sdvr_video_res_decimation_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
Enumerated type describing the various encoding and display 
resolution decimation. 
</P>
<P>
When configuring the DVR, the DVR Application sets the maximum 
system-wide resolution. The video resolution for a particular channel 
is described in terms of this maximum resolution. The video resolution 
for a channel can be the same as, 1/4 of (CIF), or 1/16 (QCIF), 2CIF, 
or DCIF of the maximum system-wide resolution. In the case of classic 
CIF, 2CIF, or 4CIF resolutions , the video sizes will be generated 
by scaling (if needed) followed by cropping. Classic CIF and 2CIF 
require scaling before cropping, Classic 4CIF requires cropping only. 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_NONE">SDVR_VIDEO_RES_DECIMATION_NONE</A> - No resolution set. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_EQUAL">SDVR_VIDEO_RES_DECIMATION_EQUAL</A> - Same resolution as the maximum. 
For D1, it is 720x480 for NTSC and 720x576 for PAL. For 4CIF, it is 704x480 
for NTSC and 704x576 for PAL. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_CIF">SDVR_VIDEO_RES_DECIMATION_CIF</A> - 1/4 of the maximum resolution. CIF 
size is 352x240 for NTSC and 352x288 for PAL. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_FOURTH">SDVR_VIDEO_RES_DECIMATION_FOURTH</A> - Same a <A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_CIF">SDVR_VIDEO_RES_DECIMATION_CIF</A>. 
Kept for backward compatibility. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_QCIF">SDVR_VIDEO_RES_DECIMATION_QCIF</A> - 1/16 of the maximum resolution. 
QCIF size is 176x112 for NTSC and 176x144 for PAL. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_SIXTEENTH">SDVR_VIDEO_RES_DECIMATION_SIXTEENTH</A> - Same a <A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_QCIF">SDVR_VIDEO_RES_DECIMATION_QCIF</A>. 
Kept for backward compatibility. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_HALF">SDVR_VIDEO_RES_DECIMATION_HALF</A> - 2CIF size. It is same width as 
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_EQUAL">SDVR_VIDEO_RES_DECIMATION_EQUAL</A> but one-half the height. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_DCIF">SDVR_VIDEO_RES_DECIMATION_DCIF</A> - DCIF size. It is 528x320 for NTSC and 
528x384 for PAL. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_CLASSIC_CIF">SDVR_VIDEO_RES_DECIMATION_CLASSIC_CIF</A> - 320x240 - Only supported for 
streaming raw video frames. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_CLASSIC_2CIF">SDVR_VIDEO_RES_DECIMATION_CLASSIC_2CIF</A> - 640x240  - Only supported for 
streaming raw video frames. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_CLASSIC_4CIF">SDVR_VIDEO_RES_DECIMATION_CLASSIC_4CIF</A> - 640x480  - Only supported for 
streaming raw video frames. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_br_control_e"></a>
<PRE class="cdef">
typedef enum _sdvr_br_control_e {
    <A name="sdvr_sdk_html_Types__SDVR_BITRATE_CONTROL_NONE">SDVR_BITRATE_CONTROL_NONE</A> = 255,
    <A name="sdvr_sdk_html_Types__SDVR_BITRATE_CONTROL_VBR">SDVR_BITRATE_CONTROL_VBR</A> = 0,
    <A name="sdvr_sdk_html_Types__SDVR_BITRATE_CONTROL_CBR">SDVR_BITRATE_CONTROL_CBR</A>,
    <A name="sdvr_sdk_html_Types__SDVR_BITRATE_CONTROL_CQP">SDVR_BITRATE_CONTROL_CQP</A>,
    <A name="sdvr_sdk_html_Types__SDVR_BITRATE_CONTROL_CONSTANT_QUALITY">SDVR_BITRATE_CONTROL_CONSTANT_QUALITY</A>
} <A HREF="#sdvr_sdk_html_Types__sdvr_br_control_e">sdvr_br_control_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
Enumerated type describing various bit rate control schemes 
available in the SDVR. 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_BITRATE_CONTROL_NONE">SDVR_BITRATE_CONTROL_NONE</A> - No bit rate control. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_BITRATE_CONTROL_VBR">SDVR_BITRATE_CONTROL_VBR</A> - Variable bit rate. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_BITRATE_CONTROL_CBR">SDVR_BITRATE_CONTROL_CBR</A> - Constant bit rate. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_BITRATE_CONTROL_CQP">SDVR_BITRATE_CONTROL_CQP</A> - Quantization parameter - Not Supported. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_BITRATE_CONTROL_CONSTANT_QUALITY">SDVR_BITRATE_CONTROL_CONSTANT_QUALITY</A> - Constant quality bit rate. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_dts_style_e"></a>
<PRE class="cdef">
typedef enum _sdvr_dts_style_e {
    <A name="sdvr_sdk_html_Types__SDVR_OSD_DTS_NONE">SDVR_OSD_DTS_NONE</A> = 0,
    <A name="sdvr_sdk_html_Types__SDVR_OSD_DTS_DEBUG">SDVR_OSD_DTS_DEBUG</A>,
    <A name="sdvr_sdk_html_Types__SDVR_OSD_DTS_MDY_12H">SDVR_OSD_DTS_MDY_12H</A>,
    <A name="sdvr_sdk_html_Types__SDVR_OSD_DTS_DMY_12H">SDVR_OSD_DTS_DMY_12H</A>,
    <A name="sdvr_sdk_html_Types__SDVR_OSD_DTS_YMD_12H">SDVR_OSD_DTS_YMD_12H</A>,
    <A name="sdvr_sdk_html_Types__SDVR_OSD_DTS_MDY_24H">SDVR_OSD_DTS_MDY_24H</A>,
    <A name="sdvr_sdk_html_Types__SDVR_OSD_DTS_DMY_24H">SDVR_OSD_DTS_DMY_24H</A>,
    <A name="sdvr_sdk_html_Types__SDVR_OSD_DTS_YMD_24H">SDVR_OSD_DTS_YMD_24H</A>
} <A HREF="#sdvr_sdk_html_Types__sdvr_dts_style_e">sdvr_dts_style_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
Enumerated type describing the date and time display styles 
supported by the SDVR. 
</P>
<P>
<A HREF="#sdvr_sdk_html_Types__SDVR_OSD_DTS_NONE">SDVR_OSD_DTS_NONE</A> - No date and time is displayed after the 
OSD text. 
</P>
<P>
<A HREF="#sdvr_sdk_html_Types__SDVR_OSD_DTS_DEBUG">SDVR_OSD_DTS_DEBUG</A> - Enables a special debug display mode. 
</P>
<P>
<A HREF="#sdvr_sdk_html_Types__SDVR_OSD_DTS_MDY_12H">SDVR_OSD_DTS_MDY_12H</A> - Displays the date in Month/Day/Year format 
followed by time in HH:MM:SS am/pm format. 
</P>
<P>
<A HREF="#sdvr_sdk_html_Types__SDVR_OSD_DTS_DMY_12H">SDVR_OSD_DTS_DMY_12H</A> - Displays the date in Day/Month/Year format 
followed by time in HH:MM:SS am/pm format. 
</P>
<P>
<A HREF="#sdvr_sdk_html_Types__SDVR_OSD_DTS_YMD_12H">SDVR_OSD_DTS_YMD_12H</A> - Displays the date in Year/Month/Day format 
followed by time in HH:MM:SS am/pm format. 
</P>
<P>
<A HREF="#sdvr_sdk_html_Types__SDVR_OSD_DTS_MDY_24H">SDVR_OSD_DTS_MDY_24H</A> - Displays the date in Month/Day/Year format 
followed by time in 24 hour HH:MM:SS format. 
</P>
<P>
<A HREF="#sdvr_sdk_html_Types__SDVR_OSD_DTS_DMY_24H">SDVR_OSD_DTS_DMY_24H</A> - Displays the date in Day/Month/Year format 
followed by time in 24 hour HH:MM:SS format. 
</P>
<P>
<A HREF="#sdvr_sdk_html_Types__SDVR_OSD_DTS_YMD_24H">SDVR_OSD_DTS_YMD_24H</A> - Displays the date in Year/Month/Day format 
followed by time in 24 hour HH:MM:SS format. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_chip_rev_e"></a>
<PRE class="cdef">
typedef enum _sdvr_chip_rev_e {
    <A name="sdvr_sdk_html_Types__SDVR_CHIP_S6100_3_REV_C">SDVR_CHIP_S6100_3_REV_C</A> = 0,
    <A name="sdvr_sdk_html_Types__SDVR_CHIP_S6105_3_REV_C">SDVR_CHIP_S6105_3_REV_C</A>,
    <A name="sdvr_sdk_html_Types__SDVR_CHIP_S6106_3_REV_C">SDVR_CHIP_S6106_3_REV_C</A>,
    <A name="sdvr_sdk_html_Types__SDVR_CHIP_S6100_3_REV_D">SDVR_CHIP_S6100_3_REV_D</A> = 16,
    <A name="sdvr_sdk_html_Types__SDVR_CHIP_S6105_3_REV_D">SDVR_CHIP_S6105_3_REV_D</A>,
    <A name="sdvr_sdk_html_Types__SDVR_CHIP_S6106_3_REV_D">SDVR_CHIP_S6106_3_REV_D</A>,
    <A name="sdvr_sdk_html_Types__SDVR_CHIP_S6100_3_REV_F">SDVR_CHIP_S6100_3_REV_F</A> = 32,
    <A name="sdvr_sdk_html_Types__SDVR_CHIP_S6105_3_REV_F">SDVR_CHIP_S6105_3_REV_F</A>,
    <A name="sdvr_sdk_html_Types__SDVR_CHIP_S6106_3_REV_F">SDVR_CHIP_S6106_3_REV_F</A>,
    <A name="sdvr_sdk_html_Types__SDVR_CHIP_S6100_3_UNKNOWN">SDVR_CHIP_S6100_3_UNKNOWN</A> = 48,
    <A name="sdvr_sdk_html_Types__SDVR_CHIP_S6105_3_UNKNOWN">SDVR_CHIP_S6105_3_UNKNOWN</A>,
    <A name="sdvr_sdk_html_Types__SDVR_CHIP_S6106_3_UNKNOWN">SDVR_CHIP_S6106_3_UNKNOWN</A>,
    <A name="sdvr_sdk_html_Types__SDVR_CHIP_UNKNOWN">SDVR_CHIP_UNKNOWN</A> = 255
} <A HREF="#sdvr_sdk_html_Types__sdvr_chip_rev_e">sdvr_chip_rev_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
Chip revision definitions. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_board_attrib_t"></a>
<PRE class="cdef">
typedef struct _sdvr_board_attrib_t {
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> pci_slot_num;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> board_type;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> supported_video_stds;
    <A HREF="#sdvr_sdk_html_Types__sdvr_chip_rev_e">sdvr_chip_rev_e</A> chip_revision;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> board_revision;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> board_sub_rev;
} <A HREF="#sdvr_sdk_html_Types__sdvr_board_attrib_t">sdvr_board_attrib_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This data structure holds board attributes. 
</P>
<UL>
<LI>
<STRONG>pci_slot_num</STRONG> - The PCI slot number in which the board is located. 
</LI>
<LI>
<STRONG>board_type</STRONG> - The board type that is combination of device_id and 
the subsystem_vendor. 
</LI>
<LI>
<STRONG>supported_video_stds</STRONG> - Specifies what cameras are supported by the board. 
It is a bit-wise OR of video standards, such as <A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_STD_D1_PAL">SDVR_VIDEO_STD_D1_PAL</A> 
or <A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_STD_D1_NTSC">SDVR_VIDEO_STD_D1_NTSC</A>. 
</LI>
<LI>
<STRONG>chip_revision</STRONG> - The Stretch chip number and revision. Refer to 
<A HREF="#sdvr_sdk_html_Types__sdvr_chip_rev_e">sdvr_chip_rev_e</A> for a list of Stretch chip numbers. 
</LI>
<LI>
<STRONG>board_revision</STRONG> - The board revision. 
</LI>
<LI>
<STRONG>board_sub_rev</STRONG>- A character in the range of A-Z representing the board 
sub revision. This field is not used prior to firmware version 4.1.x.x. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_pci_attrib_t"></a>
<PRE class="cdef">
typedef struct _sdvr_pci_attrib_t {
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> pci_slot_num;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> board_type;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> vendor_id;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> device_id;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> subsystem_vendor;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> subsystem_id;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> serial_number[<A HREF="#sdvr_sdk_html_Defines__SDVR_BOARD_SERIAL_LENGTH">SDVR_BOARD_SERIAL_LENGTH</A> + 1];
} <A HREF="#sdvr_sdk_html_Types__sdvr_pci_attrib_t">sdvr_pci_attrib_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This data structure holds PCIe board attributes. You get these 
attributes by calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_pci_attrib">sdvr_get_pci_attrib</A>()</NOBR>. This function can be called 
before or after loading of the firmware into the DVR board. 
</P>
<UL>
<LI>
<STRONG>pci_slot_num</STRONG> - The PCI slot number in which the board is located. 
</LI>
<LI>
<STRONG>board_type</STRONG> - The board type which is a combination of device_id and 
the subsystem_vendor. 
</LI>
<LI>
<STRONG>vendor_id</STRONG> - Always Stretch (0x18A2) 
</LI>
<LI>
<STRONG>device_id</STRONG> - Board ID per each vendor. 
</LI>
<LI>
<STRONG>subsystem_vendor</STRONG> - Vendor ID. For Stretch boards it is (0x18A2). 
</LI>
<LI>
<STRONG>subsystem_id</STRONG> - Currently is always set to zero. 
</LI>
<LI>
<STRONG>serial_number</STRONG> - A null terminated serial number string. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_sdk_params_t"></a>
<PRE class="cdef">
typedef struct _sdvr_sdk_params_t {
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> enc_buf_num;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> raw_buf_num;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> dec_buf_num;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> dec_buf_size;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> timeout;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> debug_flag;
    char *debug_file_name;
} <A HREF="#sdvr_sdk_html_Types__sdvr_sdk_params_t">sdvr_sdk_params_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This data structure is used to hold SDK configuration 
parameters. 
</P>
<P>
To exchange encoded and raw video with the board, the SDK needs to 
allocate buffers to hold the data on its way to and from the DVR 
Application and the board. The number of buffers to be allocated on 
each of these paths and the sizes of these buffers are set using this 
data structure. 
</P>
<P>
We recommend that you use the default values for each frame buffer as if they 
are optimized for streaming at 30 fps for NTSC, and 25fps for PAL video standards. 
</P>
<UL>
<LI>
<STRONG>enc_buf_num</STRONG> - The number of buffers to be allocated for each encoder 
channel. Each encoder channel will have the same number of 
buffers allocated. 
It is important that you allocate enough buffers for encoded frames 
to be held between the times you can process them. The maximum allowed encoded 
audio and video frame buffer size is 22. 
The default value is 20. 
NOTE: The size of each buffer is  determined by the firmware. 
</LI>
<LI>
<STRONG>raw_buf_num</STRONG> - The number of buffers to be allocated for each channel that 
will be sending raw video to the DVR Application. Each channel sending 
raw video will have the same number of buffers. 
Typically, you will need to display raw frames 30 times per second. 
Therefore, you only need between 2 and 4 buffers to hold raw video. 
The maximum allowed raw audio and video frame buffer size is 5. 
The default value is 2. 
NOTE: The size of each buffer is determined by the firmware. 
</LI>
<LI>
<STRONG>dec_buf_num</STRONG> - The number of buffers to be allocated for each decoder 
channel. Each decoder channel will have the same number of buffers 
allocated. The maximum number of decoder buffers allowed is 5. 
The default value is 5. 
</LI>
<LI>
<STRONG>dec_buf_size</STRONG> - The size of each buffer used to hold encoded frames on 
the way to the decoder hardware. Typically, this is the size of the 
largest encoded frame that needs to be decoded. 
The same buffer size is used across all decoder channels. 
The default value is 414720. 
</LI>
<LI>
<STRONG>timeout</STRONG> - For a variety of reasons, it is possible for the board to 
hang. By setting the timeout value, you specify when the SDK will 
give up on a response from the board and inform the DVR Application 
that the board is hung. The value of this parameter is in seconds. 
A value of 0 indicates that there is no timeout and the SDK will 
wait indefinitely for the board to respond. 
Do not set the value of timeout too low, or during times of heavy 
traffic on the bus, you might get a <A HREF="#sdvr_sdk_html_Defines__false">false</A> warning that the board 
has hung. Setting the value to 0 (no timeout), may cause the 
PC to hang if the firmware on the board dies. 
The default value is 5 seconds. 
</LI>
<LI>
<STRONG>debug_flag</STRONG> - This is a bit field of flags that can be set to enable 
various levels of debugging as defined by the debug flags. 
See the defines for DEBUG_FLAG_xxx for the definition of each field. 
Setting debugging flags has a noticeable effect on 
system performance. The default value is zero. 
</LI>
<LI>
<STRONG>debug_file_name</STRONG> - The name of the file where the debug information 
is stored. This string should include the full path name to the 
file, or a file in the current working directory (depends on the OS 
as to how this is defined) is created. 
If the file does not exist, it is created. If it already exists, 
it will be truncated. You also must enable the <A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_WRITE_TO_FILE">DEBUG_FLAG_WRITE_TO_FILE</A> 
bit in the <STRONG>debug_flag</STRONG> filed to save the debugging information 
into the file. In addition to the given specified <STRONG>debug_file_name</STRONG>, which 
includes all the SDK tracing, a new file will be created with <STRONG>_fw</STRONG> appended 
to the <STRONG>debug_file_name</STRONG>, which contains all the low level commands sent to the 
DVR firmware. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_board_config_t"></a>
<PRE class="cdef">
typedef struct _sdvr_board_config_t {
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> num_cameras_supported;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> num_microphones_supported;
    <A HREF="#sdvr_sdk_html_Types__sx_bool">sx_bool</A> has_smo;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> num_sensors;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> num_relays;
    <A HREF="#sdvr_sdk_html_Types__sdvr_video_std_e">sdvr_video_std_e</A> camera_type;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> num_decoders_supported;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> num_smos;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> num_encoders_supported;
} <A HREF="#sdvr_sdk_html_Types__sdvr_board_config_t">sdvr_board_config_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This data structure defines the capabilities of the SDVR boards. 
</P>
<UL>
<LI>
<STRONG>num_cameras_supported</STRONG> - Number of cameras supported by the board, i.e., 
the number of physical camera connectors on the board. 
</LI>
<LI>
<STRONG>num_microphones_supported</STRONG> - Number of microphones supported by the 
board, i.e., the number of physical microphone connectors on the board. 
</LI>
<LI>
<STRONG>has_smo</STRONG> - If <A HREF="#sdvr_sdk_html_Defines__true">true</A>, this board has a spot monitor output. 
</LI>
<LI>
<STRONG>num_sensors</STRONG> - Number of sensors on this board. 
</LI>
<LI>
<STRONG>num_relays</STRONG> - Number of relays on this board. 
</LI>
<LI>
<STRONG>camera_type</STRONG> - The maximum resolution that was specified by the 
DVR Application when connecting to the board. Typically, all 
cameras connected to the DVR have this resolution, hence the 
name of the field. 
</LI>
<LI>
<STRONG>num_decoders_supported</STRONG> - The number of decoding channel supported 
by the board. This value is zero if the board does not support decoding. 
</LI>
<LI>
<STRONG>num_smos</STRONG> - The number of spot monitor output on the DVR board. Check this 
field only if <STRONG>has_smo</STRONG> is <A HREF="#sdvr_sdk_html_Defines__true">true</A>. 
</LI>
<LI>
<STRONG>num_encoders_supported</STRONG> - The number of encoder channel supported 
by the board. This value is zero if the board does not support encoding. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_firmware_ver_t"></a>
<PRE class="cdef">
typedef struct _sdvr_firmware_ver_t {
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> fw_major;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> fw_minor;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> fw_revision;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> fw_build;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> fw_build_year;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> fw_build_month;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> fw_build_day;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> bootloader_major;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> bootloader_minor;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> bsp_major;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> bsp_minor;
} <A HREF="#sdvr_sdk_html_Types__sdvr_firmware_ver_t">sdvr_firmware_ver_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This data structure defines the firmware, boot loader and 
BSP version, and build information. 
</P>
<P>
Stretch follows the convention of using four numbers for version 
control. A change in the major number indicates major changes to 
functionality, a change in the minor number indicates minor 
changes to functionality, and a change in the revision number indicates 
significant bug fixes that were introduced in the minor change functionality. 
A change to the build number indicates only bug fixes that do not 
change functionality. 
</P>
<UL>
<LI>
<STRONG>fw_major</STRONG> - The firmware major version number. A change in this field 
indicates major changes to functionality. 
</LI>
<LI>
<STRONG>fw_minor</STRONG> - The firmware minor version number. A change in this field 
indicates minor changes to functionality. 
</LI>
<LI>
<STRONG>fw_revision</STRONG> - The firmware revision version number. A change in this 
field indicates significant bug fixes that were introduced in the minor 
change functionality. 
</LI>
<LI>
<STRONG>fw_build</STRONG> - The firmware build version number. A change in this field 
indicates only bug fixes that do not change functionality. 
</LI>
<LI>
<STRONG>fw_build_year</STRONG> - The year of firmware build. 
</LI>
<LI>
<STRONG>fw_build_month</STRONG> - The month of firmware build. 
</LI>
<LI>
<STRONG>fw_build_day</STRONG> - The day of firmware build. 
</LI>
<LI>
<STRONG>bootloader_major</STRONG> - The major version number of bootloader. 
</LI>
<LI>
<STRONG>bootloader_minor</STRONG> - The minor version number of boot loader. 
</LI>
<LI>
<STRONG>bsp_major</STRONG> - The major version number of BSP. 
</LI>
<LI>
<STRONG>bsp_minor</STRONG> - The minor version number of BSP. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_signal_info_t"></a>
<PRE class="cdef">
typedef struct sdvr_signal_info {
    <A HREF="#sdvr_sdk_html_Types__sdvr_signals_type_e">sdvr_signals_type_e</A> sig_type;
    <A HREF="#sdvr_sdk_html_Types__sdvr_chan_type_e">sdvr_chan_type_e</A> chan_type;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> chan_num;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved1;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> data;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> extra_data;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved3;
} <A HREF="#sdvr_sdk_html_Types__sdvr_signal_info_t">sdvr_signal_info_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
The DVR firmware sends asynchronous signal messages to the DVR 
Application as it encounters errors not related to any direct function 
call. 
This data structure defines parameters associated with the asynchronous 
signals sent from the DVR firmware to the host DVR Application. 
</P>
<UL>
<LI>
<EM>sig_type</EM> - The type identifying the signal cause. 
</LI>
<LI>
<EM>chan_type</EM> -  The type of channel causing the signal. 
</LI>
<LI>
<EM>chan_num</EM> - The ID of channel causing the signal. 
</LI>
<LI>
<EM>data</EM> - The error code associated with the sig_type. 
</LI>
<LI>
<EM>extra_data</EM> - Optional data information associated with the 
signal_data. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_term_e"></a>
<PRE class="cdef">
typedef enum _sdvr_term_e {
    <A name="sdvr_sdk_html_Types__SDVR_TERM_75OHM">SDVR_TERM_75OHM</A>,
    <A name="sdvr_sdk_html_Types__SDVR_TERM_HIGH_IMPEDANCE">SDVR_TERM_HIGH_IMPEDANCE</A>
} <A HREF="#sdvr_sdk_html_Types__sdvr_term_e">sdvr_term_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
Enumerated type describing various camera input impedance 
termination. 
</P>
<UL>
<LI>
<EM>SDVR_TERM_75OHM</EM> - 75 ohm impedance termination. 
</LI>
<LI>
<EM>SDVR_TERM_HIGH_IMPEDANCE</EM> - High impedance termination. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_led_type_e"></a>
<PRE class="cdef">
typedef enum _sdvr_led_type_e {
    <A name="sdvr_sdk_html_Types__SDVR_LED_TYPE_RECORD">SDVR_LED_TYPE_RECORD</A>,
    <A name="sdvr_sdk_html_Types__SDVR_LED_TYPE_ALARM">SDVR_LED_TYPE_ALARM</A>
} <A HREF="#sdvr_sdk_html_Types__sdvr_led_type_e">sdvr_led_type_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
Enumerated type describing various LED types. 
</P>
<UL>
<LI>
<EM>SDVR_LED_TYPE_RECORD</EM> - A group of LEDs indicating the current state of 
recording. 
</LI>
<LI>
<EM>SDVR_LED_TYPE_ALARM</EM> - A group of LEDs indicating the current state 
of the alarms. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_chan_def_t"></a>
<PRE class="cdef">
typedef struct _sdvr_chan_def_t {
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> board_index;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> chan_num;
    <A HREF="#sdvr_sdk_html_Types__sdvr_chan_type_e">sdvr_chan_type_e</A> chan_type;
    <A HREF="#sdvr_sdk_html_Types__sdvr_venc_e">sdvr_venc_e</A> video_format_primary;
    <A HREF="#sdvr_sdk_html_Types__sdvr_aenc_e">sdvr_aenc_e</A> audio_format;
    <A HREF="#sdvr_sdk_html_Types__sdvr_venc_e">sdvr_venc_e</A> video_format_secondary;
    <A HREF="#sdvr_sdk_html_Types__sdvr_vpp_mode_e">sdvr_vpp_mode_e</A> vpp_mode;
} <A HREF="#sdvr_sdk_html_Types__sdvr_chan_def_t">sdvr_chan_def_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This data structure defines parameters that are needed to create 
a new encoder, decoder, or HMO-only channel. 
</P>
<UL>
<LI>
<EM>board_index</EM> - The zero based index of the board where this channel resides. 
</LI>
<LI>
<EM>chan_num</EM> - The channel number identifier. 
In the case of encoding, the range is 0 to M-1, where M is the number of cameras 
supported by the board that are designated encoding channels. 
In the case of decoding, the range is 0 to N-1, where N is the number of decoders 
supported by the board that are designated decoding channels. 
NOTE: The channel number specifies on which S6 chip the channel is going to be 
created. The first set of four (0 - 3) is created on the first S6 chip, 
the second set of four (4 - 7) on the second S6 chip, and so on. 
</LI>
<LI>
<EM>chan_type</EM> -  The type channel to create as specified in <A HREF="#sdvr_sdk_html_Types__sdvr_chan_type_e">sdvr_chan_type_e</A>, 
i.e., encoder or decoder. 
NOTE: To create an HMO- or SMO-only channel, set the chan_type to <A HREF="#sdvr_sdk_html_Types__SDVR_CHAN_TYPE_ENCODER">SDVR_CHAN_TYPE_ENCODER</A> 
and the video_format_primary to <A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_ENC_NONE">SDVR_VIDEO_ENC_NONE</A>. 
</LI>
<LI>
<EM>video_format_primary</EM> - The primary encode or decode video format, e.g., H.264 
</LI>
<LI>
<EM>audio_format</EM> - The encode or decode audio format, e.g., G.711. If no audio 
is associated with this channel, you can specify <A HREF="#sdvr_sdk_html_Types__SDVR_AUDIO_ENC_NONE">SDVR_AUDIO_ENC_NONE</A>. 
This field is ignored in version 1.0. 
</LI>
<LI>
<EM>video_format_secondary</EM> - The secondary encode video format, e.g., H.264 
This field is ignored when creating a decoder channel, or if the primary 
video format is <A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_ENC_NONE">SDVR_VIDEO_ENC_NONE</A>. 
NOTE: Specifying a secondary encoder on a camera takes away processing 
power from other channels. As result you may not be able to create some 
encoder channels if secondary encoding is used in all the encoder 
channels. 
</LI>
<LI>
<EM>vpp_mode</EM> - This field specifies whether to run VPP in analytics or 
Stretch-lateral-filter mode for an encoder channel. 
(This field is deprecated and ignored. It will be removed in a 
future release.) 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_image_ctrl_t"></a>
<PRE class="cdef">
typedef struct _sdvr_image_ctrl_t {
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> hue;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> saturation;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> brightness;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> contrast;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> sharpness;
} <A HREF="#sdvr_sdk_html_Types__sdvr_image_ctrl_t">sdvr_image_ctrl_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This data structure defines various parameters that 
can be changed for each video-in data port. These parameters effect both the 
raw and encoded video frames. 
</P>
<UL>
<LI>
<STRONG>hue</STRONG> - Value of hue control in the range of 0 to 255. 
</LI>
<LI>
<STRONG>saturation</STRONG> - Value of saturation control in the range of 0 to 255. 
</LI>
<LI>
<STRONG>brightness</STRONG> - Value of brightness control in the range of 0 to 255. 
</LI>
<LI>
<STRONG>contrast</STRONG> - Value of contrast control in the range of 0 to 255. 
</LI>
<LI>
<STRONG>sharpness</STRONG> - Value of sharpness control in the range of 1 to 15. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
Default values for these fields are hardware specific. 
These settings may affect the blind detection alarm. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_video_enc_chan_params_t"></a>
<PRE class="cdef">
typedef struct _sdvr_video_enc_chan_params_t {
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> frame_rate;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> res_decimation;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> reserved1;
    union {
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> avg_bitrate;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> max_bitrate;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> bitrate_control;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> gop;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> quality;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved1;
        } h264;
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> quality;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> is_image_style;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved1;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved2;
        } jpeg;
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> avg_bitrate;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> max_bitrate;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> bitrate_control;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> gop;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> quality;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved1;
        } mpeg4;
    } encoder;
} <A HREF="#sdvr_sdk_html_Types__sdvr_video_enc_chan_params_t">sdvr_video_enc_chan_params_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This data structure defines video encoder parameters. 
For each channel used for encoding, use this data structure to set its 
parameters. 
</P>
<UL>
<LI>
<STRONG>frame_rate</STRONG> - The frame rate of the channel in frames per 
second. Valid values are 1-30 for NTSC video and 1-25 for PAL. 
The default is 30 for NTSC and 25 for PAL. 
</LI>
<LI>
<STRONG>res_decimation</STRONG> - Resolution decimation of the channel. You can specify 
the resolution of the encoded channel to be the same as, 1/4, or 
1/16 of the system-wide maximum resolution. 
The default for primary encoding is <A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_EQUAL">SDVR_VIDEO_RES_DECIMATION_EQUAL</A> whereas 
for secondary encoding is <A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_QCIF">SDVR_VIDEO_RES_DECIMATION_QCIF</A>. 
</LI>
</UL>
<P>
The parameters for each encoder are set in the following 
<EM>union</EM>. 
</P>
<P>
H.264 Parameters: 
</P>
<UL>
<LI>
<STRONG>avg_bitrate</STRONG> - The average bit rate in Kbits per second 
if CBR or VBR is selected. 
The default is 2000. 
</LI>
<LI>
<STRONG>max_bitrate</STRONG> - The maximum target bit rate in Kbits per second 
if VBR is selected. 
The default is 4000. 
</LI>
<LI>
<STRONG>bitrate_control</STRONG> - Choose one of CBR, VBR, QP (not supported) 
or constant quality. The default is CBR. 
</LI>
<LI>
<STRONG>gop_size</STRONG> - GOP size for the H.264 encoder. GOP size must be 
greater than zero. The default is 15. 
</LI>
<LI>
<STRONG>quality</STRONG> - The quality level to be maintained when bitrate_control 
is set to constant quality. The valid range is 1 - 100. 
The default is 50. 
</LI>
</UL>
<P>
JPEG Parameters: 
</P>
<UL>
<LI>
<STRONG>quality</STRONG> - A number in the range of 1 - 99 to control the quality of the 
compression. A higher number implies better quality. 
The default is 50. 
</LI>
<LI>
<STRONG>is_image_style</STRONG> - The JPEG encoder generates an image-style JPEG frame 
header to be used for RTP when this value is 1. The JPEG encoder generates a 
video-style JPEG (Motion JPEG) frame header when this value is zero. This is 
suitable in AVI MJPEG or still JPEG image files. This field must always be 0. 
The default is 0. 
</LI>
</UL>
<P>
MPEG4 Parameters: 
</P>
<UL>
<LI>
<STRONG>avg_bitrate</STRONG> - The average bit rate in Kbits per second 
if CBR or VBR is selected. 
The default is 2000. 
</LI>
<LI>
<STRONG>max_bitrate</STRONG> - The maximum target bit rate in Kbits per second 
if VBR is selected. 
The default is 4000. 
</LI>
<LI>
<STRONG>bitrate_control</STRONG> - Choose one of CBR, VBR, QP (not supported), 
or constant quality. The default is CBR. 
</LI>
<LI>
<STRONG>gop_size</STRONG> - GOP size for the MPEG4 encoder. GOP size must be 
greater than zero. The default is 15. 
</LI>
<LI>
<STRONG>quality</STRONG> - The quality level to be maintained when bitrate_control 
is set to constant quality. The valid range is 1 - 100. 
The default is 50. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_alarm_video_enc_params_t"></a>
<PRE class="cdef">
typedef struct _sdvr_alarm_video_enc_params_t {
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> frame_rate;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> min_on_seconds;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> min_off_seconds;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> enable;
    union {
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> avg_bitrate;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> max_bitrate;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> bitrate_control;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> gop;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> quality;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved1;
        } h264;
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> quality;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> is_image_style;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved1;
            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved2;
        } jpeg;
        struct {
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> avg_bitrate;
            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> max_bitrate;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> bitrate_control;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> gop;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> quality;
            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved1;
        } mpeg4;
    } encoder;
} <A HREF="#sdvr_sdk_html_Types__sdvr_alarm_video_enc_params_t">sdvr_alarm_video_enc_params_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This data structure defines video encode channel parameters for 
alarm video streaming. After any of the alarms reaches its specified 
threshold, the video encoded frame is streamed using these new 
parameters for the given minimum duration. 
</P>
<P>
NOTE: Currently these parameters are used for all triggered alarms. 
</P>
<UL>
<LI>
<STRONG>frame_rate</STRONG> - The new on-alarm recording frame rate of the channel 
in frames per second. Valid values are 1-30 for NTSC video and 
1-25 for PAL. 
The default is 30 for NTSC and 25 for PAL. 
</LI>
<LI>
<STRONG>min_on_seconds</STRONG> - Minimum number of seconds to stream using the 
new encoder parameter after the alarm is triggered. 
</LI>
<LI>
<STRONG>min_off_seconds</STRONG> - Minimum number of quiet periods between each 
alarm streaming condition. 
</LI>
<LI>
<STRONG>enable</STRONG> - A flag to enable or disable on-alarm video streaming. 
0 turns off the on-alarm streaming. 1 turns on the on-alarm 
streaming. 
</LI>
<LI>
<STRONG>encoder</STRONG> - The encoder-specific parameters. See the encoder union in 
<A HREF="#sdvr_sdk_html_Types__sdvr_video_enc_chan_params_t">sdvr_video_enc_chan_params_t</A> for a detailed description. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_audio_enc_chan_params_t"></a>
<PRE class="cdef">
typedef struct _sdvr_audio_enc_chan_params_t {
    <A HREF="#sdvr_sdk_html_Types__sdvr_aenc_e">sdvr_aenc_e</A> audio_enc_type;
} <A HREF="#sdvr_sdk_html_Types__sdvr_audio_enc_chan_params_t">sdvr_audio_enc_chan_params_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
Structure defining audio encoder channel parameters. 
</P>
<UL>
<LI>
<STRONG>audio_enc_type</STRONG> - The type of audio encoder to use. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_mb_region_t"></a>
<PRE class="cdef">
typedef struct _sdvr_mb_region_t {
    <A HREF="#sdvr_sdk_html_Types__sx_bool">sx_bool</A> alarm_flag;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved1;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> reserved2;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> upper_left_x;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> upper_left_y;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> lower_right_x;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> lower_right_y;
} <A HREF="#sdvr_sdk_html_Types__sdvr_mb_region_t">sdvr_mb_region_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
Data structure for a Macro Block (MB) rectangular region of interest. 
An MB region is specified by upper left row and column macro block 
and lower right macro block within a map of ROI buffers. See 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_regions_map">sdvr_set_regions_map</A>()</NOBR>for details. 
</P>
<UL>
<LI>
<STRONG>alarm_flag</STRONG>    - A flag indicating whether the motion value in this 
Macro Block rectangle exceeds the specified threshold. This 
field is set by <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_motion_value_analyzer">sdvr_motion_value_analyzer</A>()</NOBR> upon successful 
return. 
</LI>
<LI>
<STRONG>mb_upper_left_row</STRONG> - MB row number of the upper left corner. 
</LI>
<LI>
<STRONG>mb_upper_left_col</STRONG> - MB column number of the upper left corner. 
</LI>
<LI>
<STRONG>mb_lower_right_row</STRONG> - MB row number of the lower right corner. 
</LI>
<LI>
<STRONG>mb_lower_right_col</STRONG> - MB column number of the lower right corner. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_region_t"></a>
<PRE class="cdef">
typedef struct _sdvr_region_t {
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> region_id;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> upper_left_x;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> upper_left_y;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> lower_right_x;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> lower_right_y;
} <A HREF="#sdvr_sdk_html_Types__sdvr_region_t">sdvr_region_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
Data structure for a region. 
A region is specified by its upper left and lower right coordinates 
in pixels. The upper left corner of an image is the origin (0,0). 
</P>
<UL>
<LI>
<STRONG>region_id</STRONG>    - The region identifier. It is needed to change or 
remove a region. When adding a new region, this field will be set 
by the system. 
</LI>
<LI>
<STRONG>upper_left_x</STRONG> - X-coordinate of the upper left corner. 
</LI>
<LI>
<STRONG>upper_left_y</STRONG> - Y-coordinate of the upper left corner. 
</LI>
<LI>
<STRONG>lower_right_x</STRONG> - X-coordinate of the lower right corner. 
</LI>
<LI>
<STRONG>lower_right_y</STRONG> - Y-coordinate of the lower right corner. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_motion_detection_t"></a>
<PRE class="cdef">
typedef struct _sdvr_motion_detection {
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> threshold;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> enable;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> num_regions;
    <A HREF="#sdvr_sdk_html_Types__sdvr_region_t">sdvr_region_t</A> regions[<A HREF="#sdvr_sdk_html_Defines__SDVR_MAX_MD_REGIONS">SDVR_MAX_MD_REGIONS</A>];
} <A HREF="#sdvr_sdk_html_Types__sdvr_motion_detection_t">sdvr_motion_detection_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
Data structure for motion detection alarm. 
</P>
<UL>
<LI>
<STRONG>threshold</STRONG> - The threshold value for motion detection. 
Motion above the threshold is reported. 
A threshold of zero means the motion detection alarm is 
triggered constantly. The valid range is 0 - 99. 
The default is 20. 
</LI>
<LI>
<STRONG>enable</STRONG> - A value of 1 enables motion detection for all the specified 
regions. If no region is defined, the entire picture will be used for 
motion detection. A value of 0 disables the motion detection. 
</LI>
<LI>
<STRONG>num_regions</STRONG> - This field specifies the number of motion detection 
regions added to the current video channel. A value of zero means 
motion detection is applied to the entire picture. This is a read-only 
field. 
</LI>
<LI>
<STRONG>regions</STRONG> - An array of regions definition. The regions in this array 
are not in any order. Each array item has an ID to identify the region. 
This is a read-only field. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_blind_detection_t"></a>
<PRE class="cdef">
typedef struct _sdvr_blind_detection {
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> threshold;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> enable;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> num_regions;
    <A HREF="#sdvr_sdk_html_Types__sdvr_region_t">sdvr_region_t</A> regions[<A HREF="#sdvr_sdk_html_Defines__SDVR_MAX_BD_REGIONS">SDVR_MAX_BD_REGIONS</A>];
} <A HREF="#sdvr_sdk_html_Types__sdvr_blind_detection_t">sdvr_blind_detection_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
Data structure for blind detection alarm. 
</P>
<UL>
<LI>
<STRONG>threshold</STRONG> - The threshold value for blind detection. Blinding 
above the threshold is reported.  The valid range is 0 - 99. 
The default is 60. 
</LI>
<LI>
<STRONG>enable</STRONG> - A value of 1 enables blind detection for all the specified 
regions. If no region is defined, the entire picture will be used for 
blind detection. A value of 0 disables the blind detection. 
</LI>
<LI>
<STRONG>num_regions</STRONG> - This field specifies the number of blind detection 
regions added to the current video channel. A value of 0 means 
blind detection is applied to the entire picture. This is a read-only 
field. 
</LI>
<LI>
<STRONG>regions</STRONG> - An array of regions definition. The regions in this array 
are not in any order. Each array item has an ID to identify the region. 
This is a read-only field. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_night_detection_t"></a>
<PRE class="cdef">
typedef struct _sdvr_night_detection {
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> threshold;
    <A HREF="#sdvr_sdk_html_Types__sx_bool">sx_bool</A> enable;
} <A HREF="#sdvr_sdk_html_Types__sdvr_night_detection_t">sdvr_night_detection_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
Data structure for night detection alarm. 
</P>
<UL>
<LI>
<STRONG>night_detect_threshold</STRONG> - The threshold value for night detection. Values 
below the threshold are reported. Setting this value to 255 
disables night detection. The valid range is 0 - 255. 
The default is 40. 
</LI>
<LI>
<STRONG>enable</STRONG> - A value of 1 enables night detection. A value of 0 disables 
the night detection. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_privacy_region_t"></a>
<PRE class="cdef">
typedef struct _sdvr_privacy_region {
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> enable;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> num_regions;
    <A HREF="#sdvr_sdk_html_Types__sdvr_region_t">sdvr_region_t</A> regions[<A HREF="#sdvr_sdk_html_Defines__SDVR_MAX_PR_REGIONS">SDVR_MAX_PR_REGIONS</A>];
} <A HREF="#sdvr_sdk_html_Types__sdvr_privacy_region_t">sdvr_privacy_region_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
Data structure for privacy regions. 
</P>
<UL>
<LI>
<STRONG>enable</STRONG> - A value of 1 enables block out for all the specified 
regions. If no region is defined, the entire picture will be blocked 
out. A value of zero turns off privacy. 
</LI>
<LI>
<STRONG>num_regions</STRONG> - This field specifies the number of blocked out 
regions added to the current video channel. A value of 0 means 
the entire picture will be blocked out. This is a read-only field. 
</LI>
<LI>
<STRONG>regions</STRONG> - An array of regions definition. The regions in this array 
are not in any order. Each array item has an ID to identify the region. 
This is a read-only field. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_av_buffer_t"></a>
<PRE class="cdef">
typedef struct _sdvr_av_buffer_t {
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> signature;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> hdr_version;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> hdr_size;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> board_id;
    <A HREF="#sdvr_sdk_html_Types__sdvr_chan_type_e">sdvr_chan_type_e</A> channel_type;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> channel_id;
    <A HREF="#sdvr_sdk_html_Types__sdvr_frame_type_e">sdvr_frame_type_e</A> frame_type;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> motion_detected;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> blind_detected;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> night_detected;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> av_state_flags;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> stream_id;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved2;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> reserved3;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> payload_size;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> timestamp;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> timestamp_high;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> motion_value[4];
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> blind_value[4];
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> night_value[4];
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> active_width;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> padded_width;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> active_height;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> padded_height;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> seq_number;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> frame_number;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> frame_drop_count;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved4[3];
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> yuv_format;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> y_data_size;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> u_data_size;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> v_data_size;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> y_data_offset;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> u_data_offset;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> v_data_offset;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> uv_active_width;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> uv_padded_width;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> uv_active_height;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> uv_padded_height;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved[39];
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> payload[1];
} <A HREF="#sdvr_sdk_html_Types__sdvr_av_buffer_t">sdvr_av_buffer_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
The AV buffer structure used in the SDK for A/V frames. 
</P>
<P>
The AV buffer has a header followed by the payload. The header contains 
the following information: 
</P>
<UL>
<LI>
<STRONG>signature</STRONG> - Used by the SDK. 
</LI>
<LI>
<STRONG>hdr_version</STRONG> - Used by the SDK. 
</LI>
<LI>
<STRONG>hdr_size</STRONG> - Used by the SDK. 
</LI>
<LI>
<STRONG>board_id</STRONG> - The board ID from where the frame was received. 
</LI>
<LI>
<STRONG>channel_type</STRONG> - The type of channel (encoder or decoder). 
</LI>
<LI>
<STRONG>channel_id</STRONG> - The channel ID. 
</LI>
<LI>
<STRONG>frame_type</STRONG> - The type of video/audio frame associated with this buffer. 
</LI>
<LI>
<STRONG>motion_detected</STRONG> - The motion value detected on this channel. 
You must compare this value against the motion threshold 
to decide if there are any motions on this video frame. 
</LI>
<LI>
<STRONG>blind_detected</STRONG> - The blind value on this channel. 
You must compare this value against the blind threshold 
to decide if the camera is blinded. 
</LI>
<LI>
<STRONG>night_detected</STRONG> - The night value on this channel. 
You must compare this value against the night threshold 
to decide if night is detected. 
</LI>
<LI>
<STRONG>av_state_flags</STRONG> - A set of one-bit flags about the audio/video 
state of the camera. The loss occurs if the corresponding bit is 
set. The possible flags are <A HREF="#sdvr_sdk_html_Defines__SDVR_AV_STATE_VIDEO_LOST">SDVR_AV_STATE_VIDEO_LOST</A> &amp; <A HREF="#sdvr_sdk_html_Defines__SDVR_AV_STATE_AUDIO_LOST">SDVR_AV_STATE_AUDIO_LOST</A>. 
</LI>
<LI>
<STRONG>stream_id</STRONG> - This field is only used for encoded frames. It indicates 
whether the payload corresponds to a video frame from the primary (0) or 
the secondary (1) encoder on this encoded channel. 
</LI>
<LI>
<STRONG>payload_size</STRONG> - The size of the payload, in bytes, that follows the header. 
</LI>
<LI>
<STRONG>timestamp</STRONG> - A hardware-generated timestamp of when the frame was captured. 
Low 32 bits of hardware-generated timestamp. 
</LI>
<LI>
<STRONG>timestamp_high</STRONG> - A hardware-generated timestamp of when the frame was captured. 
High 32 bits of hardware-generated timestamp. 
<STRONG>NOTE</STRONG>: This field is valid only in firmware build versions 3.2.0.1 or later. 
</LI>
<UL>
<LI>
For video, the time stamp is generated using a 
100 KHz clock, and can be used for A/V synchronization. 
</LI>
<LI>
For audio, the time stamp is generated using an 
100 KHz clock, and can be used for A/V synchronization. 
</LI>
</UL>
<LI>
<STRONG>motion_value</STRONG> - Motion detect values for up to four regions of interest. 
motion_value[0] is the same as <EM>motion_detected</EM>. 
</LI>
<LI>
<STRONG>blind_value</STRONG> - Blind detect values for up to four regions of interest. 
blind_value[0] is the same as <EM>blind_detected</EM>. 
</LI>
<LI>
<STRONG>night_value</STRONG> - Night detect values for up to four regions of interest. 
blind_value[0] is the same as <EM>night_detected</EM>. 
</LI>
<LI>
<STRONG>active_width</STRONG> - Active width of video frame buffer. This field is 
valid only for RAW and encoded video frames. 
</LI>
<LI>
<STRONG>padded_width</STRONG> - Padded width of video frame buffer. This field is 
valid only for RAW and encoded video frames. 
</LI>
<LI>
<STRONG>active_height</STRONG> - Active height of video frame buffer. This field is 
valid only for RAW and encoded video frames. 
</LI>
<LI>
<STRONG>padded_height</STRONG> - Padded height of video frame buffer. This field is 
valid only for raw and encoded video frames. 
</LI>
<LI>
<STRONG>seq_number</STRONG> - Frame sequence number. This field is valid only 
for RAW and encoded video frames. Every channel and 
stream combination will have independent sequence numbering. The raw 
and encoded video streams from the same channel will have independent 
sequence numbering. 
</LI>
<LI>
<STRONG>frame_number</STRONG> - Number of frames seen on this channel so far. 
This field is valid only for raw and encoded video frames. The 
frame number and sequence number will be identical when the 
stream is being run at full frame rate. 
</LI>
<LI>
<STRONG>frame_drop_count</STRONG> - Number of frames dropped detected by the 
firmware on the current stream. 
</LI>
</UL>
<P>
In addition to the header, there is the <STRONG>payload</STRONG> that contains the 
data for the frame. 
</P>
<P>
We highly recommend that when storing each encoded frame to disk, 
both the payload and the header be stored. The header provides 
information that can be useful when searching through the file. 
</P>
<P>
Additionally, we recommend that the DVR Application create a separate 
data and tag file for each channel. The data file contains the 
payload, and the tag file contains the header information. This 
makes searching stored video a lot faster. 
</P>
<P>
The <STRONG>payload</STRONG> field points to the beginning of data 
for a frame. If you have a pointer to an <A HREF="#sdvr_sdk_html_Types__sdvr_av_buffer_t">sdvr_av_buffer_t</A> object 
(call this pointer p), then you can access the payload by: 
<PRE class="ccode">
     ... = (<A HREF="#sdvr_sdk_html_Types__sx_int8">sx_int8</A>) p-&gt;payload[0]; // First byte of buffer 
     ... = (<A HREF="#sdvr_sdk_html_Types__sx_int8">sx_int8</A>) p-&gt;payload[1]; // Second byte of buffer 
</PRE>
</P>
<P>
<STRONG>NOTE: You should not access fields in this data structure directly. Instead 
you should call functions in the <EM>Frame Buffer Field Access API</EM> group. 
It is possible in the future that the fields in this structure to be 
changed or removed.</STRONG> 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_rawv_formats_e"></a>
<PRE class="cdef">
typedef enum _sdvr_rawv_formats_e {
    <A name="sdvr_sdk_html_Types__SDVR_RAWV_FORMAT_YUV_4_2_0">SDVR_RAWV_FORMAT_YUV_4_2_0</A> = 1,
    <A name="sdvr_sdk_html_Types__SDVR_RAWV_FORMAT_YUV_4_2_2">SDVR_RAWV_FORMAT_YUV_4_2_2</A> = 2,
    <A name="sdvr_sdk_html_Types__SDVR_RAWV_FORMAT_YVU_4_2_0">SDVR_RAWV_FORMAT_YVU_4_2_0</A> = 4
} <A HREF="#sdvr_sdk_html_Types__sdvr_rawv_formats_e">sdvr_rawv_formats_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
The following constants describe various raw video formats. 
</P>
<P>
<A HREF="#sdvr_sdk_html_Types__SDVR_RAWV_FORMAT_YUV_4_2_0">SDVR_RAWV_FORMAT_YUV_4_2_0</A> - 4:2:0 YUV format. 
</P>
<P>
<A HREF="#sdvr_sdk_html_Types__SDVR_RAWV_FORMAT_YUV_4_2_2">SDVR_RAWV_FORMAT_YUV_4_2_2</A> - 4:2:2 YUV format. 
</P>
<P>
<A HREF="#sdvr_sdk_html_Types__SDVR_RAWV_FORMAT_YVU_4_2_0">SDVR_RAWV_FORMAT_YVU_4_2_0</A> - 4:2:0 YVU (YV12) format. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_yuv_buffer_t"></a>
<PRE class="cdef">
typedef struct _sdvr_yuv_buffer_t {
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> signature;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> hdr_version;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> hdr_size;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> board_id;
    <A HREF="#sdvr_sdk_html_Types__sdvr_chan_type_e">sdvr_chan_type_e</A> channel_type;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> channel_id;
    <A HREF="#sdvr_sdk_html_Types__sdvr_frame_type_e">sdvr_frame_type_e</A> frame_type;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> motion_detected;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> blind_detected;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> night_detected;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> av_state_flags;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> motion_value[4];
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> blind_value[4];
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> night_value[4];
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> timestamp;
    <A HREF="#sdvr_sdk_html_Types__sx_uint64">sx_uint64</A> timestamp_64;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> active_width;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> active_height;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> seq_number;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> frame_number;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> frame_drop_count;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> reserved1;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> reserved2;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> yuv_format;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> y_data_size;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> u_data_size;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> v_data_size;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> *y_data;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> *u_data;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> *v_data;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> reserved[46];
} <A HREF="#sdvr_sdk_html_Types__sdvr_yuv_buffer_t">sdvr_yuv_buffer_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
The YUV buffer structure used for holding a raw video 
frame. The structure contains three pointers to the Y, U, and V parts of 
a raw video frame. The default raw video is in YUV 4:2:0 format but this 
format can be changed by calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_yuv_format">sdvr_set_yuv_format</A>()</NOBR>. 
</P>
<UL>
<LI>
The AV buffer has a header followed by the payload. The header 
contains the following information: 
</LI>
<UL>
<LI>
<STRONG>signature</STRONG> - Used by the SDK. 
</LI>
<LI>
<STRONG>hdr_version</STRONG> - Used by the SDK. 
</LI>
<LI>
<STRONG>hdr_size</STRONG> - Used by the SDK. 
</LI>
<LI>
<STRONG>board_id</STRONG> - The board ID from where the frame was received. 
</LI>
<LI>
<STRONG>channel_type</STRONG> - The type of channel (encoder or decoder). 
</LI>
<LI>
<STRONG>channel_id</STRONG> - The channel ID. 
</LI>
<LI>
<STRONG>frame_type</STRONG> - The type of video/audio frame associated with this buffer. 
</LI>
<LI>
<STRONG>motion_detected</STRONG> - The motion value detected on this channel. 
You must compare this value against the motion threshold 
to decide if there are any motions on this video frame. 
</LI>
<LI>
<STRONG>blind_detected</STRONG> - The blind value on this channel. 
You must compare this value against the blind threshold 
to decide if the camera is blinded. 
</LI>
<LI>
<STRONG>night_detected</STRONG> - The night value on this channel. 
You must compare this value against the night threshold 
to decide if night is detected. 
</LI>
<LI>
<STRONG>av_state_flags</STRONG> - A set of one-bit flags about the audio/video 
state of the camera. The loss occurs if the corresponding bit is 
set. The possible flags are <A HREF="#sdvr_sdk_html_Defines__SDVR_AV_STATE_VIDEO_LOST">SDVR_AV_STATE_VIDEO_LOST</A> &amp; <A HREF="#sdvr_sdk_html_Defines__SDVR_AV_STATE_AUDIO_LOST">SDVR_AV_STATE_AUDIO_LOST</A>. 
</LI>
<LI>
<STRONG>timestamp</STRONG> - The low 32-bits hardware-generated time stamp of when the frame was captured. 
Use timestamp_64 field for the correct time. 
</LI>
<LI>
<STRONG>timestamp_64</STRONG> - A 64-bits hardware time stamp of when the frame was captured. 
</LI>
<UL>
<LI>
For live video, the time stamp is generated using a 
100 KHz clock, and can be used for A/V synchronization. 
</LI>
<LI>
For live audio, the time stamp is generated using an 
100 KHz clock, and can be used for A/V synchronization. 
</LI>
<LI>
For decoded audio and video, the time stamp generated during 
encoding (using the 90 KHz) clock is passed to the decoded 
audio and video frames. 
</LI>
</UL>
<LI>
<STRONG>motion_value</STRONG> - Motion detect values for up to four regions of interest. 
motion_value[0] is the same as <EM>motion_detected</EM>. 
</LI>
<LI>
<STRONG>blind_value</STRONG> - Blind detect values for up to four regions of interest. 
blind_value[0] is the same as <EM>blind_detected</EM>. 
</LI>
<LI>
<STRONG>night_value</STRONG> - Night detect values for up to four regions of interest. 
blind_value[0] is the same as <EM>night_detected</EM>. 
</LI>
<LI>
<STRONG>active_width</STRONG> - Active width of video frame buffer. This field is 
valid only for RAW and encoded video frames. 
</LI>
<LI>
<STRONG>padded_width</STRONG> - Padded width of video frame buffer. This field is 
valid only for RAW and encoded video frames. 
</LI>
<LI>
<STRONG>active_height</STRONG> - Active height of video frame buffer. This field is 
valid only for RAW and encoded video frames. 
</LI>
<LI>
<STRONG>padded_height</STRONG> - Padded height of video frame buffer. This field is 
valid only for raw and encoded video frames. 
</LI>
<LI>
<STRONG>seq_number</STRONG> - Frame sequence number. This field is valid only 
for RAW and encoded video frames. Every channel and 
stream combination will have independent sequence numbering. The raw 
and encoded video streams from the same channel will have independent 
sequence numbering. 
</LI>
<LI>
<STRONG>frame_number</STRONG> - Number of frames seen on this channel so far. 
This field is valid only for raw and encoded video frames. The 
frame number and sequence number will be identical when the 
stream is being run at full frame rate. 
</LI>
<LI>
<STRONG>frame_drop_count</STRONG> - Number of frames drop detected by the 
firmware on the current stream. 
</LI>
<LI>
<STRONG>yuv_format</STRONG> - The current YUV format. 
</LI>
<LI>
<STRONG>y_data_size</STRONG> - The size of the Y data in bytes. 
</LI>
<LI>
<STRONG>u_data_size</STRONG> - The size of the U data in bytes. 
</LI>
<LI>
<STRONG>v_data_size</STRONG> - The size of the V data in bytes. 
</LI>
<LI>
<STRONG>y_data</STRONG> - Pointer to a buffer containing the Y data of a raw frame. 
</LI>
<LI>
<STRONG>u_data</STRONG> - Pointer to a buffer containing the U data of a raw frame. 
</LI>
<LI>
<STRONG>v_data</STRONG> - Pointer to a buffer containing the V data of a raw frame. 
</LI>
</UL>
</UL>
<P>
NOTE: When you are ready to release the frame, you must pass this structure to 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_release_yuv_buffer">sdvr_release_yuv_buffer</A>()</NOBR>. 
</P>
<P>
NOTE: Raw audio is stored in <A HREF="#sdvr_sdk_html_Types__sdvr_av_buffer_t">sdvr_av_buffer_t</A>, and does not need a 
separate data structure. 
</P>
<P>
<STRONG>NOTE: You should not access fields in this data structure directly. Instead 
you should call functions in the <EM>Frame Buffer Field Access API</EM> group. 
It is possible in the future that the fields in this structure may be 
changed or removed.</STRONG> 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_osd_text_config_t"></a>
<PRE class="cdef">
typedef struct _sdvr_osd_text_config_t {
    char display_text[<A HREF="#sdvr_sdk_html_Defines__SDVR_MAX_OSD_TEXT">SDVR_MAX_OSD_TEXT</A> + 1];
    <A HREF="#sdvr_sdk_html_Types__sdvr_location_e">sdvr_location_e</A> text_location;
    <A HREF="#sdvr_sdk_html_Types__sx_bool">sx_bool</A> append_dts;
    <A HREF="#sdvr_sdk_html_Types__sdvr_dts_style_e">sdvr_dts_style_e</A> dts_style;
    <A HREF="#sdvr_sdk_html_Types__sx_bool">sx_bool</A> enable;
} <A HREF="#sdvr_sdk_html_Types__sdvr_osd_text_config_t">sdvr_osd_text_config_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
Data structure to a single-byte string OSD text. 
</P>
<UL>
<LI>
<STRONG>display_text</STRONG> - String to display as OSD text. This is a 
single-byte NULL terminated string, and cannot be longer than 
<A HREF="#sdvr_sdk_html_Defines__SDVR_MAX_OSD_TEXT">SDVR_MAX_OSD_TEXT</A> characters. 
</LI>
<LI>
<STRONG>text_location</STRONG> - Location of the string on the window. 
</LI>
<LI>
<STRONG>append_dts</STRONG> - True means date and time are appended to the text. 
</LI>
<LI>
<STRONG>dts_style</STRONG> - The style in which DTS is shown (time format). 
</LI>
<LI>
<STRONG>enable</STRONG> - A non-zero value indicates that the given OSD text is 
part of the video stream. A zero value disables OSD. 
</LI>
</UL>
<P>
<STRONG>NOTE: This data structure, and all of its supporting functions, will be replaced 
with a set of more general functions starting with version 3.4.x. 
You should plan to stop using this data structure.</STRONG> 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_osd_config_ex_t"></a>
<PRE class="cdef">
typedef struct _sdvr_osd_config_ex_t {
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> translucent;
    <A HREF="#sdvr_sdk_html_Types__sdvr_location_e">sdvr_location_e</A> location_ctrl;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> top_left_x;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> top_left_y;
    <A HREF="#sdvr_sdk_html_Types__sdvr_dts_style_e">sdvr_dts_style_e</A> dts_format;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> text_len;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> text[<A HREF="#sdvr_sdk_html_Defines__SDVR_MAX_OSD_EX_TEXT">SDVR_MAX_OSD_EX_TEXT</A>];
} <A HREF="#sdvr_sdk_html_Types__sdvr_osd_config_ex_t">sdvr_osd_config_ex_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This data structure is used to configure each one of the OSD items 
associated with video frames of any camera or player. The number of OSD 
items is currently limited to 2 text of 100 double-byte string per OSD item. 
</P>
<P>
After an OSD item is configured, it can be shown or hidden at any time. 
</P>
<UL>
<LI>
<STRONG>translucent</STRONG> - This field specifies the intensity of 
translucence when overlay OSD text is on the active video. 
0 means least translucent, 255 means most translucent. 
</LI>
<LI>
<STRONG>position_ctrl</STRONG> - The position of OSD text. 
It can be any of the predefined locations in 
<A HREF="#sdvr_sdk_html_Types__sdvr_location_e">sdvr_location_e</A> or a custom defined location. 
</LI>
<LI>
<STRONG>top_left_x</STRONG>, <STRONG>top_left_y</STRONG> - The top left coordinates of the OSD 
text when the custom <STRONG>position_ctrl</STRONG> is specified, otherwise 
these fields are ignored. The upper left corner of video frame 
is the origin (0,0). 
</LI>
<LI>
<STRONG>dts_format</STRONG> - The format of date and time to optionally 
be appended to the end of the OSD text. 
</LI>
<LI>
<STRONG>text_len</STRONG> - The number of unsigned double byte characters 
in the text field. 
</LI>
<LI>
<STRONG>text</STRONG> - Up to 100 unsigned double byte Unicode text to be displayed. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_font_table_t"></a>
<PRE class="cdef">
typedef struct _sdvr_font_table_t {
    char *font_file;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> font_table_id;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> font_table_format;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> start_font_code;
    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> end_font_code;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> color_y;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> color_u;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> color_v;
} <A HREF="#sdvr_sdk_html_Types__sdvr_font_table_t">sdvr_font_table_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This data structure is used to specify a new OSD font table. 
You can either use all the characters or sub-set of characters within 
the font file. Additionally, you can choose a color to be used for all 
the characters. The same OSD font is used for all the DVR boards that 
are connected at the time of calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_osd_set_font_table">sdvr_osd_set_font_table</A>()</NOBR>. 
</P>
<P>
<STRONG>font_file</STRONG> - Full path to a the font file. Currently this must be 
a .bdf file. 
</P>
<P>
<STRONG>font_table_id</STRONG> - The font table ID. User defined font table IDs are 
from 8 to 15, IDs 0 to 7 are reserved for system fonts. 
<STRONG>This field is ignored in this release.</STRONG> 
</P>
<P>
<STRONG>font_table_format</STRONG> - The format of font file. Currently the only 
supported font format is <A HREF="#sdvr_sdk_html_Defines__SDVR_FT_FORMAT_BDF">SDVR_FT_FORMAT_BDF</A>. <STRONG>This field is ignored 
in this release.</STRONG> 
</P>
<P>
<STRONG>start_font_code</STRONG> - The first font character to use within the font 
file. Use 0 for the lowest character code. 
</P>
<P>
<STRONG>end_font_code</STRONG> - The last font character to use within the font file. Use 
65535 for the highest character code. 
</P>
<P>
<STRONG>color_y</STRONG> - Y component color of the character in YUV space. Use 255 for 
white. 
</P>
<P>
<STRONG>color_u</STRONG> - U component color of the character in YUV space. Use 128 for 
white. 
</P>
<P>
<STRONG>color_v</STRONG> - V component color of the character in YUV space. Use 128 for 
white. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_smo_grid_t"></a>
<PRE class="cdef">
typedef struct _sdvr_smo_grid_t {
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> top_left_mb_x;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> top_left_mb_y;
    <A HREF="#sdvr_sdk_html_Types__sdvr_video_res_decimation_e">sdvr_video_res_decimation_e</A> res_decimation;
    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> dwell_time;
    <A HREF="#sdvr_sdk_html_Types__sx_bool">sx_bool</A> enable;
} <A HREF="#sdvr_sdk_html_Types__sdvr_smo_grid_t">sdvr_smo_grid_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This data structure is used to specify the spot monitor output 
grid pattern. The SMO display is divided into different grids specified 
by a top left location and a resolution decimation of the original video 
camera assigned to that grid. 
</P>
<P>
Each encode or decode video channel can display its raw image at a particular 
pixel position on the SMO display. 
</P>
<P>
Each grid on the SMO screen consists of one or more encode or decode channel 
outputs with a specific resolution decimation. 
</P>
<P>
After a grid is defined, you can temporarily enable or disable its output. 
</P>
<UL>
<LI>
<STRONG>top_left_mb_x</STRONG>, <STRONG>top_left_mb_y</STRONG> - These two numbers specify the top-left 
macro block coordinates of the display position and must be even number 
values.  The coordinate of the top-left corner of SMO is (0,0). 
</LI>
<LI>
<STRONG>res_decimation</STRONG> - The resolution to use to display the channels at this 
grid position. The image is resized based on this number. 
</LI>
<LI>
<STRONG>dwell_time</STRONG> - If you put multiple channels in the same grid, then you 
must specify the length of time each channel is displayed before switching to 
the next channel. The firmware cycles through all the channels 
periodically, and switches them every N seconds, where N is the dwell time. 
</LI>
<LI>
<STRONG>enable</STRONG> - To disable and not display this grid on the SMO, set the value 
of this field to zero. Otherwise, the channel assigned to this grid 
is displayed on the SMO. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_smo_capabilities_e"></a>
<PRE class="cdef">
typedef enum _sdvr_smo_capabilities_e {
    <A name="sdvr_sdk_html_Types__SDVR_SMO_CAP_OUTPUT">SDVR_SMO_CAP_OUTPUT</A> = 1,
    <A name="sdvr_sdk_html_Types__SDVR_SMO_CAP_OSD">SDVR_SMO_CAP_OSD</A> = 2,
    <A name="sdvr_sdk_html_Types__SDVR_SMO_CAP_ALPHA_BLENDING">SDVR_SMO_CAP_ALPHA_BLENDING</A> = 4,
    <A name="sdvr_sdk_html_Types__SDVR_SMO_CAP_TILING">SDVR_SMO_CAP_TILING</A> = 8,
    <A name="sdvr_sdk_html_Types__SDVR_SMO_CAP_ANALOG">SDVR_SMO_CAP_ANALOG</A> = 16
} <A HREF="#sdvr_sdk_html_Types__sdvr_smo_capabilities_e">sdvr_smo_capabilities_e</A>; 
</PRE>
<DIV CLASS="descr">
<P>
The following enum describes various supported SMO capabilities. 
Each feature is supported by the SMO port if the corresponding bit is set. 
</P>
<P>
<A HREF="#sdvr_sdk_html_Types__SDVR_SMO_CAP_OUTPUT">SDVR_SMO_CAP_OUTPUT</A> - Supports outputing of DVR Host Application 
generated raw video. 
</P>
<P>
<A HREF="#sdvr_sdk_html_Types__SDVR_SMO_CAP_OSD">SDVR_SMO_CAP_OSD</A> - Supports OSD text that is displayed only on this SMO port. 
</P>
<P>
<A HREF="#sdvr_sdk_html_Types__SDVR_SMO_CAP_ALPHA_BLENDING">SDVR_SMO_CAP_ALPHA_BLENDING</A> - Supports alpha blending of OSD. 
</P>
<P>
<A HREF="#sdvr_sdk_html_Types__SDVR_SMO_CAP_TILING">SDVR_SMO_CAP_TILING</A> - Supports tiling of video, streaming from different 
cameras or host output on this SMO display. 
</P>
<P>
<A HREF="#sdvr_sdk_html_Types__SDVR_SMO_CAP_ANALOG">SDVR_SMO_CAP_ANALOG</A> - Supports full analog video, streaming from one 
camera at a time in full resolution on this SMO display. OSD text per camera 
or tiling of multiple cameras is not supported in this mode. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_smo_attribute_t"></a>
<PRE class="cdef">
typedef struct _sdvr_smo_attribute_t {
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> video_formats;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> width;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> height;
    <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> cap_flags;
} <A HREF="#sdvr_sdk_html_Types__sdvr_smo_attribute_t">sdvr_smo_attribute_t</A>;
</PRE>
<DIV CLASS="descr">
<P>
This data structure holds attributes for a specified Spot Montior 
Out (SMO). 
</P>
<UL>
<LI>
<STRONG>video_formats</STRONG> - A bit map to indicate supported raw video formats. 
see <A HREF="#sdvr_sdk_html_Types__sdvr_rawv_formats_e">sdvr_rawv_formats_e</A>. 
</LI>
<LI>
<STRONG>width</STRONG> - The width of the SMO display. 
</LI>
<LI>
<STRONG>height</STRONG> - The number of lines of the SMO display 
</LI>
<LI>
<STRONG>cap_flags</STRONG> - A bit map specifying all the capabilities of the 
<STRONG>cap_flags</STRONG> - A bit map specifying all the capabilities of the 
<STRONG>cap_flags</STRONG> - A bit map specifying all the capabilities of the 
requested SMO port. See <A HREF="#sdvr_sdk_html_Types__sdvr_smo_capabilities_e">sdvr_smo_capabilities_e</A>. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_video_alarm_callback"></a>
<PRE class="cdef">
typedef void (*<A HREF="#sdvr_sdk_html_Types__sdvr_video_alarm_callback">sdvr_video_alarm_callback</A>)(<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A> handle,
                                          <A HREF="#sdvr_sdk_html_Types__sdvr_video_alarm_e">sdvr_video_alarm_e</A> alarm_type,
                                          <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> data);
</PRE>
<DIV CLASS="descr">
<P>
Typedef for video alarm callback function. This function has 
to be written by the DVR Application writer and be registered as a 
callback. Through this callback mechanism, the SDK will alert the DVR 
Application when video alarms happen above the specified threshold for 
the specific alarm. 
</P>
<P>
The video alarm callback function is called whenever the encoder detects 
motion, blinding, nighttime light conditions, or video loss or detection.. 
The callback function takes as its arguments the channel handle, 
the type of alarm, and alarm data. The meaning of alarm data varies 
depending on the type of alarm (i.e., for motion alarm, the alarm data 
is the actual amount of motion over the given threshold). 
These arguments are set by the SDK so that the callback function can 
determine which board and which video channel the alarm is coming from, 
and the type of alarm. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_sensor_callback"></a>
<PRE class="cdef">
typedef void (*<A HREF="#sdvr_sdk_html_Types__sdvr_sensor_callback">sdvr_sensor_callback</A>)(<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> board_index,
                                     <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> sensor_map);
</PRE>
<DIV CLASS="descr">
<P>
Typedef for sensor callback function. This function has 
to be written by the DVR Application writer and be registered as a 
callback. Through this callback mechanism, the SDK alerts the DVR 
Application when sensors trigger. 
</P>
<P>
The sensor callback is called whenever one or more sensors on each 
board are triggered. The callback function takes as its arguments the 
board index and the sensor map. These arguments are set by the SDK 
so that the callback function can determine which board and which sensors 
have triggered. The sensors that have triggered are in 
sensor_map, with bit 0 corresponding to sensor 0, bit 1 to sensor 1, 
and so on. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_av_frame_callback"></a>
<PRE class="cdef">
typedef void (*<A HREF="#sdvr_sdk_html_Types__sdvr_av_frame_callback">sdvr_av_frame_callback</A>)(<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A> handle,
                                       <A HREF="#sdvr_sdk_html_Types__sdvr_frame_type_e">sdvr_frame_type_e</A> frame_type,
                                       <A HREF="#sdvr_sdk_html_Types__sx_bool">sx_bool</A> primary_frame);
</PRE>
<DIV CLASS="descr">
<P>
Typedef for AV frame callback function. This function has 
to be written by the DVR Application writer and be registered as a 
callback. Through this callback mechanism, the SDK alerts the DVR 
Application whenever encoded or raw AV frames are available. 
</P>
<P>
The AV frame callback function is called whenever a new 
encoded AV frame is available, or when a raw video or 
audio frame is available. The callback function takes as its arguments 
the channel handle and the frame type to 
determine what the frame is and where it came from. The last argument is 
to distinguish between primary and secondary subchannels in a 
particular encoding channel. This parameter is only valid for 
encoded video frames and has no meaning for audio or raw video frames. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_display_debug_callback"></a>
<PRE class="cdef">
typedef void (*<A HREF="#sdvr_sdk_html_Types__sdvr_display_debug_callback">sdvr_display_debug_callback</A>)(char *message);
</PRE>
<DIV CLASS="descr">
<P>
Typedef for displaying debug callback function. This function has 
to be written by the DVR Application writer and be registered as a 
callback. Through this callback mechanism, the SDK alerts the DVR 
Application whenever tracing error messages need to be displayed on the 
screen. 
</P>
<P>
The callback function takes as its argument the string buffer to display. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_signals_callback"></a>
<PRE class="cdef">
typedef void (*<A HREF="#sdvr_sdk_html_Types__sdvr_signals_callback">sdvr_signals_callback</A>)(<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> board_index,
                                      <A HREF="#sdvr_sdk_html_Types__sdvr_signal_info_t">sdvr_signal_info_t</A> *signal_info);
</PRE>
<DIV CLASS="descr">
<P>
Typedef for firmware asynchronous send message callback function. 
This function has to be written by the DVR Application writer and be 
registered as a callback. Through this callback mechanism, the SDK will 
signal the DVR Application when firmware needs to send messages to the DVR 
Application without the application initiating a request. These messages 
are currently only error conditions generated on the firmware side, but in 
the future it could include other types of messages. 
</P>
<P>
The callback function takes as its argument the signal type and a pointer 
to the signal information data structure. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Types__sdvr_send_confirmation_callback"></a>
<PRE class="cdef">
typedef void (*<A HREF="#sdvr_sdk_html_Types__sdvr_send_confirmation_callback">sdvr_send_confirmation_callback</A>)(<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A> handle);
</PRE>
<DIV CLASS="descr">
<P>
Typedef for send frame confirmation callback function. This function has 
to be written by the DVR Application writer and be registered as a 
callback. Through this callback mechanism, the SDK alerts the DVR 
Application that the frame was received by the DVR firmware. 
</P>
<P>
The send frame confirmation callback function is called whenever 
the frame that was sent to the DVR firmware is 
processed and released. Encode frames to be decoded or DVR host 
provided raw video frames are examples for such confirmation. 
The callback function takes as its argument 
the channel handle that sent the frame. 
</P>
</DIV>

</DIV>

<!-- SEC_TYPES_CLOSE -->

<!-- SEC_DEFINES_START -->

<a name="sdvr_sdk_html_Top__Defines"></a>
<H2>4.9 &nbsp; Defines</H2>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Defines__true"></a>
<PRE class="cdef">
#define <A HREF="#sdvr_sdk_html_Defines__true">true</A>
</PRE>
<DIV CLASS="descr">
<P>
<A HREF="#sdvr_sdk_html_Defines__true">true</A> is a non-zero value 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Defines__false"></a>
<PRE class="cdef">
#define <A HREF="#sdvr_sdk_html_Defines__false">false</A>
</PRE>
<DIV CLASS="descr">
<P>
<A HREF="#sdvr_sdk_html_Defines__false">false</A> is zero value 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Defines__SDVR_REGION_MAP_D1_WIDTH"></a>
<a name="sdvr_sdk_html_Defines__SDVR_REGION_MAP_4CIF_WIDTH"></a>
<a name="sdvr_sdk_html_Defines__SDVR_REGION_MAP_LINE_NTSC"></a>
<a name="sdvr_sdk_html_Defines__SDVR_REGION_MAP_LINE_PAL"></a>
<PRE class="cdef">
#define <A HREF="#sdvr_sdk_html_Defines__SDVR_REGION_MAP_D1_WIDTH">SDVR_REGION_MAP_D1_WIDTH</A> 45 
#define <A HREF="#sdvr_sdk_html_Defines__SDVR_REGION_MAP_4CIF_WIDTH">SDVR_REGION_MAP_4CIF_WIDTH</A> 44 
#define <A HREF="#sdvr_sdk_html_Defines__SDVR_REGION_MAP_LINE_NTSC">SDVR_REGION_MAP_LINE_NTSC</A> 30 
#define <A HREF="#sdvr_sdk_html_Defines__SDVR_REGION_MAP_LINE_PAL">SDVR_REGION_MAP_LINE_PAL</A> 36 
</PRE>
<DIV CLASS="descr">
<P>
The width and number of lines to be used to calculate regions of 
interest (ROI) map buffer for different video standards. The size of ROI 
map buffer is calculated by (width x lines) for the currently specified 
video standard. 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Defines__SDVR_REGION_MAP_D1_WIDTH">SDVR_REGION_MAP_D1_WIDTH</A> - The width of ROI map for a D1 NTSC or PAL 
video standard. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Defines__SDVR_REGION_MAP_4CIF_WIDTH">SDVR_REGION_MAP_4CIF_WIDTH</A> - The width of ROI map for a 4-CIF NTSC or 
PAL video standard. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Defines__SDVR_REGION_MAP_LINE_NTSC">SDVR_REGION_MAP_LINE_NTSC</A> - The number of lines in ROI map for a NTSC video 
standard. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Defines__SDVR_REGION_MAP_LINE_PAL">SDVR_REGION_MAP_LINE_PAL</A> - The number of lines in ROI map for a PAL video 
standard. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Defines__SDVR_AV_STATE_VIDEO_LOST"></a>
<a name="sdvr_sdk_html_Defines__SDVR_AV_STATE_AUDIO_LOST"></a>
<PRE class="cdef">
#define <A HREF="#sdvr_sdk_html_Defines__SDVR_AV_STATE_VIDEO_LOST">SDVR_AV_STATE_VIDEO_LOST</A> 0x01 
#define <A HREF="#sdvr_sdk_html_Defines__SDVR_AV_STATE_AUDIO_LOST">SDVR_AV_STATE_AUDIO_LOST</A> 0x02 
</PRE>
<DIV CLASS="descr">
<P>
The current audio/video signal state on the channel in the 
<A HREF="#sdvr_sdk_html_Types__sdvr_av_buffer_t">sdvr_av_buffer_t</A> structure. 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Defines__SDVR_AV_STATE_VIDEO_LOST">SDVR_AV_STATE_VIDEO_LOST</A> - No video signal is being detected on the channel. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Defines__SDVR_AV_STATE_AUDIO_LOST">SDVR_AV_STATE_AUDIO_LOST</A> - No audio signal is being detected on the channel. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Defines__SDVR_BOARD_SERIAL_LENGTH"></a>
<PRE class="cdef">
#define <A HREF="#sdvr_sdk_html_Defines__SDVR_BOARD_SERIAL_LENGTH">SDVR_BOARD_SERIAL_LENGTH</A>
</PRE>
<DIV CLASS="descr">
<P>
Length of the serial number string. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Defines__DEBUG_FLAG_DEBUGGING_ON"></a>
<a name="sdvr_sdk_html_Defines__DEBUG_FLAG_ALL"></a>
<a name="sdvr_sdk_html_Defines__DEBUG_FLAG_WRITE_TO_FILE"></a>
<a name="sdvr_sdk_html_Defines__DEBUG_FLAG_OUTPUT_TO_SCREEN"></a>
<a name="sdvr_sdk_html_Defines__DEBUG_FLAG_ENCODER"></a>
<a name="sdvr_sdk_html_Defines__DEBUG_FLAG_DECODER"></a>
<a name="sdvr_sdk_html_Defines__DEBUG_FLAG_VIDEO_ALARM"></a>
<a name="sdvr_sdk_html_Defines__DEBUG_FLAG_SENSORS_RELAYS"></a>
<a name="sdvr_sdk_html_Defines__DEBUG_FLAG_AUDIO_OPERATIONS"></a>
<a name="sdvr_sdk_html_Defines__DEBUG_FLAG_DISPLAY_OPERATIONS"></a>
<a name="sdvr_sdk_html_Defines__DEBUG_FLAG_BOARD"></a>
<a name="sdvr_sdk_html_Defines__DEBUG_FLAG_GENERAL_SDK"></a>
<a name="sdvr_sdk_html_Defines__DEBUG_FLAG_SMO"></a>
<a name="sdvr_sdk_html_Defines__DEBUG_FLAG_OSD"></a>
<a name="sdvr_sdk_html_Defines__DEBUG_FLAG_CHANNEL"></a>
<a name="sdvr_sdk_html_Defines__DEBUG_FLAG_VIDEO_FRAME"></a>
<a name="sdvr_sdk_html_Defines__DEBUG_FLAG_FW_WRITE_TO_FILE"></a>
<a name="sdvr_sdk_html_Defines__DEBUG_FLAG_RECORD_TO_FILE"></a>
<PRE class="cdef">
#define <A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_DEBUGGING_ON">DEBUG_FLAG_DEBUGGING_ON</A> 0x1 
#define <A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_ALL">DEBUG_FLAG_ALL</A> 0xFFFFFFFE 
#define <A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_WRITE_TO_FILE">DEBUG_FLAG_WRITE_TO_FILE</A> 0x2 
#define <A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_OUTPUT_TO_SCREEN">DEBUG_FLAG_OUTPUT_TO_SCREEN</A> 0x4 
#define <A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_ENCODER">DEBUG_FLAG_ENCODER</A> 0x8 
#define <A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_DECODER">DEBUG_FLAG_DECODER</A> 0x10 
#define <A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_VIDEO_ALARM">DEBUG_FLAG_VIDEO_ALARM</A> 0x20 
#define <A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_SENSORS_RELAYS">DEBUG_FLAG_SENSORS_RELAYS</A> 0x40 
#define <A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_AUDIO_OPERATIONS">DEBUG_FLAG_AUDIO_OPERATIONS</A> 0x80 
#define <A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_DISPLAY_OPERATIONS">DEBUG_FLAG_DISPLAY_OPERATIONS</A> 0x100 
#define <A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_BOARD">DEBUG_FLAG_BOARD</A> 0x200 
#define <A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_GENERAL_SDK">DEBUG_FLAG_GENERAL_SDK</A> 0x400 
#define <A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_SMO">DEBUG_FLAG_SMO</A> 0x800 
#define <A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_OSD">DEBUG_FLAG_OSD</A> 0x1000 
#define <A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_CHANNEL">DEBUG_FLAG_CHANNEL</A> 0x2000 
#define <A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_VIDEO_FRAME">DEBUG_FLAG_VIDEO_FRAME</A> 0x4000 
#define <A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_FW_WRITE_TO_FILE">DEBUG_FLAG_FW_WRITE_TO_FILE</A> 0x8000 
#define <A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_RECORD_TO_FILE">DEBUG_FLAG_RECORD_TO_FILE</A> 0x00010000 
</PRE>
<DIV CLASS="descr">
<P>
These debug flags are available to help you turn on 
debugging in the SDK. 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_DEBUGGING_ON">DEBUG_FLAG_DEBUGGING_ON</A> - Turn on debugging. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_ALL">DEBUG_FLAG_ALL</A> - Turn on all debugging flags. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_WRITE_TO_FILE">DEBUG_FLAG_WRITE_TO_FILE</A> - Turn on writing debug information to file. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_OUTPUT_TO_SCREEN">DEBUG_FLAG_OUTPUT_TO_SCREEN</A> - Write debug information to TTY. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_ENCODER">DEBUG_FLAG_ENCODER</A> - Turn on debugging for encoder. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_DECODER">DEBUG_FLAG_DECODER</A> - Turn on debugging for decoder. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_VIDEO_ALARM">DEBUG_FLAG_VIDEO_ALARM</A> - Turn on debugging for video alarm. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_SENSORS_RELAYS">DEBUG_FLAG_SENSORS_RELAYS</A> - Turn on debugging for sensors and relays. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_AUDIO_OPERATIONS">DEBUG_FLAG_AUDIO_OPERATIONS</A> - Turn on debugging for audio operations. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_DISPLAY_OPERATIONS">DEBUG_FLAG_DISPLAY_OPERATIONS</A> - Turn on debugging for video operations. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_BOARD">DEBUG_FLAG_BOARD</A> - Turn on debugging for board configuration. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_GENERAL_SDK">DEBUG_FLAG_GENERAL_SDK</A> - Turn on debugging for SDK configuration. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_SMO">DEBUG_FLAG_SMO</A> - Turn on debugging for SMO configuration. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_OSD">DEBUG_FLAG_OSD</A> - Turn on debugging for OSD configuration. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_CHANNEL">DEBUG_FLAG_CHANNEL</A> - Turn on debugging for channel configuration. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_VIDEO_FRAME">DEBUG_FLAG_VIDEO_FRAME</A> - Turn on debugging of video frames. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_FW_WRITE_TO_FILE">DEBUG_FLAG_FW_WRITE_TO_FILE</A> - Turn on firmware only messages. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_RECORD_TO_FILE">DEBUG_FLAG_RECORD_TO_FILE</A> - Turn on debugging of recording the 
audio and video frame to a file. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Defines__SDVR_MAX_MD_REGIONS"></a>
<a name="sdvr_sdk_html_Defines__SDVR_MAX_BD_REGIONS"></a>
<a name="sdvr_sdk_html_Defines__SDVR_MAX_PR_REGIONS"></a>
<PRE class="cdef">
#define <A HREF="#sdvr_sdk_html_Defines__SDVR_MAX_MD_REGIONS">SDVR_MAX_MD_REGIONS</A> 4 
#define <A HREF="#sdvr_sdk_html_Defines__SDVR_MAX_BD_REGIONS">SDVR_MAX_BD_REGIONS</A> 4 
#define <A HREF="#sdvr_sdk_html_Defines__SDVR_MAX_PR_REGIONS">SDVR_MAX_PR_REGIONS</A> 4 
</PRE>
<DIV CLASS="descr">
<P>
These defines specify the different maximum regions. These limits 
apply to regions that defined based on pixels and not Macro Blocks. 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Defines__SDVR_MAX_MD_REGIONS">SDVR_MAX_MD_REGIONS</A> - Maximum number of motion detection regions. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Defines__SDVR_MAX_BD_REGIONS">SDVR_MAX_BD_REGIONS</A> - Maximum number of blind detection regions. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Defines__SDVR_MAX_PR_REGIONS">SDVR_MAX_PR_REGIONS</A> - Maximum number of privacy regions. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Defines__SDVR_MAX_OSD_TEXT"></a>
<a name="sdvr_sdk_html_Defines__SDVR_MAX_OSD_EX_TEXT"></a>
<PRE class="cdef">
#define <A HREF="#sdvr_sdk_html_Defines__SDVR_MAX_OSD_TEXT">SDVR_MAX_OSD_TEXT</A> 10 
#define <A HREF="#sdvr_sdk_html_Defines__SDVR_MAX_OSD_EX_TEXT">SDVR_MAX_OSD_EX_TEXT</A> 100 
</PRE>
<DIV CLASS="descr">
<P>
This defines the maximum number of OSD text characters that can be display as an 
OSD text string. 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Defines__SDVR_MAX_OSD_TEXT">SDVR_MAX_OSD_TEXT</A> - The maximum size of OSD text for single byte 
OSD APIs is 10 characters. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Defines__SDVR_MAX_OSD_EX_TEXT">SDVR_MAX_OSD_EX_TEXT</A> - The maximum length of OSD text in OSD APIs 
supporting double byte is 100 unsigned short. 
Available only in firmware version 3.2.0.0 or later. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Defines__SDVR_MAX_OSD"></a>
<PRE class="cdef">
#define <A HREF="#sdvr_sdk_html_Defines__SDVR_MAX_OSD">SDVR_MAX_OSD</A> 2 
</PRE>
<DIV CLASS="descr">
<P>
This defines the maximum number of OSD item that can be configure 
per each channel. Available only in firmware version 3.2.0.0 or later. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Defines__INVALID_CHAN_HANDLE"></a>
<PRE class="cdef">
#define <A HREF="#sdvr_sdk_html_Defines__INVALID_CHAN_HANDLE">INVALID_CHAN_HANDLE</A> (<A HREF="#sdvr_sdk_html_Types__sx_int32">sx_int32</A>)0xFFFFFFFF 
</PRE>
<DIV CLASS="descr">
<P>
This defines the invalid channel handle. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Defines__SDVR_ICFLAG_ALL"></a>
<a name="sdvr_sdk_html_Defines__SDVR_ICFLAG_HUE"></a>
<a name="sdvr_sdk_html_Defines__SDVR_ICFLAG_SATURATION"></a>
<a name="sdvr_sdk_html_Defines__SDVR_ICFLAG_BRIGHTNESS"></a>
<a name="sdvr_sdk_html_Defines__SDVR_ICFLAG_CONTRAST"></a>
<a name="sdvr_sdk_html_Defines__SDVR_ICFLAG_SHARPNESS"></a>
<PRE class="cdef">
#define <A HREF="#sdvr_sdk_html_Defines__SDVR_ICFLAG_ALL">SDVR_ICFLAG_ALL</A> 0xFFFF 
#define <A HREF="#sdvr_sdk_html_Defines__SDVR_ICFLAG_HUE">SDVR_ICFLAG_HUE</A> 0x1 
#define <A HREF="#sdvr_sdk_html_Defines__SDVR_ICFLAG_SATURATION">SDVR_ICFLAG_SATURATION</A> 0x2 
#define <A HREF="#sdvr_sdk_html_Defines__SDVR_ICFLAG_BRIGHTNESS">SDVR_ICFLAG_BRIGHTNESS</A> 0x4 
#define <A HREF="#sdvr_sdk_html_Defines__SDVR_ICFLAG_CONTRAST">SDVR_ICFLAG_CONTRAST</A> 0x8 
#define <A HREF="#sdvr_sdk_html_Defines__SDVR_ICFLAG_SHARPNESS">SDVR_ICFLAG_SHARPNESS</A> 0x10 
</PRE>
<DIV CLASS="descr">
<P>
These defines specify the flags that can be used in order 
to change one or more of image control parameters associated to each 
video-in data port by ORing each defines when calling 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_video_in_params">sdvr_set_video_in_params</A>()</NOBR>. 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Defines__SDVR_ICFLAG_ALL">SDVR_ICFLAG_ALL</A> - Use this define to change all the image 
control parameters. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Defines__SDVR_ICFLAG_HUE">SDVR_ICFLAG_HUE</A> - - Change the hue image value. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Defines__SDVR_ICFLAG_SATURATION">SDVR_ICFLAG_SATURATION</A> - Change the saturation image value. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Defines__SDVR_ICFLAG_BRIGHTNESS">SDVR_ICFLAG_BRIGHTNESS</A> - Change the brightness image value. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Defines__SDVR_ICFLAG_CONTRAST">SDVR_ICFLAG_CONTRAST</A> - Change the contrast image value. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Defines__SDVR_ICFLAG_SHARPNESS">SDVR_ICFLAG_SHARPNESS</A> - Change the sharpness image value. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Defines__SDVR_DATA_HDR_SIG"></a>
<PRE class="cdef">
#define <A HREF="#sdvr_sdk_html_Defines__SDVR_DATA_HDR_SIG">SDVR_DATA_HDR_SIG</A>
</PRE>
<DIV CLASS="descr">
<P>
Data header signature value. Only present in new-style header. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Defines__SDVR_DATA_HDR_VER"></a>
<PRE class="cdef">
#define <A HREF="#sdvr_sdk_html_Defines__SDVR_DATA_HDR_VER">SDVR_DATA_HDR_VER</A>
</PRE>
<DIV CLASS="descr">
<P>
Current data header version. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Defines__SDVR_FT_FONT_ENGLISH"></a>
<PRE class="cdef">
#define <A HREF="#sdvr_sdk_html_Defines__SDVR_FT_FONT_ENGLISH">SDVR_FT_FONT_ENGLISH</A> 0 
</PRE>
<DIV CLASS="descr">
<P>
Stretch DVR pre-loaded font tables. 
</P>
<P>
<A HREF="#sdvr_sdk_html_Defines__SDVR_FT_FONT_ENGLISH">SDVR_FT_FONT_ENGLISH</A> - Fonts for English character sets. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Defines__SDVR_FT_FORMAT_BDF"></a>
<PRE class="cdef">
#define <A HREF="#sdvr_sdk_html_Defines__SDVR_FT_FORMAT_BDF">SDVR_FT_FORMAT_BDF</A> 1 
</PRE>
<DIV CLASS="descr">
<P>
The format of the font file. 
</P>
<P>
<A HREF="#sdvr_sdk_html_Defines__SDVR_FT_FORMAT_BDF">SDVR_FT_FORMAT_BDF</A> - The Glyph Bitmap Distribution Format (BDF) by 
Adobe is a file format for storing bitmap fonts. BDF is most commonly 
used font file within the linux operating system. 
Currently, this is the only supported format. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Defines__EXTERN"></a>
<PRE class="cdef">
#define <A HREF="#sdvr_ui_sdk_html_Defines__EXTERN">EXTERN</A>
</PRE>
<DIV CLASS="descr">
<P>
A necessary evil introduced for C++ compatibility.  C source files must 
not declare a function <EM>extern</EM> ; instead, they must declare the function 
<EM>EXTERN</EM>.  For example: 
<PRE class="ccode">
    <A HREF="#sdvr_ui_sdk_html_Defines__EXTERN">EXTERN</A> void my_external_symbol(int a, double f); 
</PRE>
This specifies that the function has C linkage so that it can be used 
when compiled with a C++ compiler. 
</P>
</DIV>

</DIV>

<!-- SEC_DEFINES_CLOSE -->

<!-- SEC_ROUTINES_START -->

<a name="sdvr_sdk_html_Top__Routines"></a>
<H2>4.10 &nbsp; Routines</H2>

<a name="sdvr_sdk_html_Routines__System___Set___Up______SDK___and___Board___Initialization___API"></a>
<H3>4.10.1 &nbsp; System Set Up, SDK and Board Initialization API</H3>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_error_text"></a>
<PRE class="cdef">
char * <A HREF="#sdvr_sdk_html_Routines__sdvr_get_error_text">sdvr_get_error_text</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> error_no);
</PRE>
<DIV CLASS="descr">
<P>
This function returns the text string mnemonic for the given error number. If the 
given error number is not valid, a string with the number is returned. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>error_no</EM> - The error number for the text string 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
A pointer to a null terminated string with the text of the error. 
<STRONG>NOTE: This string should not be freed.</STRONG> 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_sdk_init"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_sdk_init">sdvr_sdk_init</A> ();
</PRE>
<DIV CLASS="descr">
<P>
This function initializes the SDK and the driver, allocates system resources 
required by them, and discovers all SDVR cards in the system. NOTE: the 
cards are not initialized by this function.  
</P>
<P>
This is the first call that you must make in your application before 
you can use any of the other API functions with the exception of get version 
or set callback calls. Also, this function should be called only once per session. 
</P>
<P>
Parameters:  
</P>
<UL>
<LI>
None. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_sdk_close"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_sdk_close">sdvr_sdk_close</A> ();
</PRE>
<DIV CLASS="descr">
<P>
This function closes the SDK and the driver, and frees up the system 
resources used by them. You must call this function prior to exiting 
your DVR Application for a clean shutdown of your system.  
No other API function calls, except <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_sdk_init">sdvr_sdk_init</A>()</NOBR>, are allowed after  
this function is called.  
</P>
<P>
Parameters:  
</P>
<UL>
<LI>
None. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_board_count"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_board_count">sdvr_get_board_count</A> ();
</PRE>
<DIV CLASS="descr">
<P>
This function returns the number of SDVR boards in the system. Only boards  
that are functioning properly are discovered and reported by this 
function.  
</P>
<P>
Parameters:  
</P>
<UL>
<LI>
None 
</LI>
</UL>
<P>
Returns:  
</P>
<UL>
<LI>
The number of SDVR boards discovered. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_board_attributes"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_board_attributes">sdvr_get_board_attributes</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>             board_index,
                                      <A HREF="#sdvr_sdk_html_Types__sdvr_board_attrib_t">sdvr_board_attrib_t</A> * board_attrib);
</PRE>
<DIV CLASS="descr">
<P>
This function returns the board attributes of each board. Use this function 
to discover which PCI slot the board is connected to and its  
type, as well as all the video standards supported  by the firmware. 
</P>
<P>
Parameters:  
</P>
<UL>
<LI>
<EM>board_index</EM> - The number of the board whose attributes you want.  
This is a zero based number. It means the first board number  
is index zero, second board number is index one, and so on. 
</LI>
<LI>
<EM>board_attrib</EM> - A pointer to a variable that will hold the attributes 
when this function returns. 
</LI>
</UL>
<P>
Returns:  
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise see the error code list. 
</LI>
</UL>
<P>
Remark: 
</P>
<UL>
<LI>
Call this function or <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_supported_vstd">sdvr_get_supported_vstd</A>()</NOBR> before calling  
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_board_connect">sdvr_board_connect</A>()</NOBR> to select one of the supported video standards  
by the firmware. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_pci_attrib"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_pci_attrib">sdvr_get_pci_attrib</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>           board_index,
                                <A HREF="#sdvr_sdk_html_Types__sdvr_pci_attrib_t">sdvr_pci_attrib_t</A> * pci_attrib);
</PRE>
<DIV CLASS="descr">
<P>
This function returns the board PCI attributes of each board. Use this function 
to discover which PCI slot the board is connected to, its  
type, vendor and device ID, and serial number. 
</P>
<P>
Parameters:  
</P>
<UL>
<LI>
<EM>board_index</EM> - The board number for which to get PCI information. 
This is a zero based number. It means the first board number  
is index zero, second board number is index one, and so on. 
</LI>
<LI>
<EM>pci_attrib</EM> - A pointer to a variable that will hold the PCI information 
when this function returns successfully. 
</LI>
</UL>
<P>
Returns:  
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise see the error code list. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
This function can be called before the call to <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_board_connect">sdvr_board_connect</A>()</NOBR> or 
before loading a firmware into the DVR board. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_board_reset"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_board_reset">sdvr_board_reset</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> board_index);
</PRE>
<DIV CLASS="descr">
<P>
This function resets the firmware on the given board. We recommend that you not 
connect to any board prior calling this function.  After calling  
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_board_reset">sdvr_board_reset</A>()</NOBR>, you must reload the firmware if it is not already flashed 
on the board. Additionally, your system also needs to be reconfigured after  
board reset.  
</P>
<P>
The usage of this function is heavily discouraged because it can put the 
SDK in an indeterminate stage. In general, if the firmware is not already flashed 
on the DVR board, this function should not be called. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>board_index</EM> - The number of the board that you want to reset. 
This is a zero based number. It means the first board number  
is index zero, second board number is index one, and so on. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_board_connect"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_board_connect">sdvr_board_connect</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>          board_index,
                               <A HREF="#sdvr_sdk_html_Types__sdvr_video_std_e">sdvr_video_std_e</A>   video_std,
                               <A HREF="#sdvr_sdk_html_Types__sx_bool">sx_bool</A>            is_h264_SCE);
</PRE>
<DIV CLASS="descr">
<P>
This function connects to a board and sets up communication channels and 
other system resources required to handle the board. 
</P>
<P>
This function should only be called once per board.  
</P>
<P>
<STRONG>NOTE: To change and set a new video standard, the DVR firmware 
is reset every time the DVR board is connected.</STRONG> 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>board_index</EM> - The number of the board to which you want to connect. 
This is a zero based number. It means the first board number  
is index zero, second board number is index one, and so on. 
</LI>
<LI>
<EM>video_std</EM> - The video standard and maximum system-wide resolution 
of all the cameras connected to the board.  
</LI>
<LI>
<EM>is_h264_SCE</EM> - This field specifies whether the SDK or the H.264  
encoder should perform  start code emulation (SCE) for h.264 video  
frames. For performance reasons,  
it is highly recommended to always set this field to 1 so that the  
SDK performs SCE, except for the embedded DVR Applications it  
must be set to 0 which means the encoder to perform this task. 
</LI>
<LI>
This field is ignored if connected to any firmware version prior to 
3.2.0.19. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
<P>
Remark: 
</P>
<UL>
<LI>
All the cameras connected to the board must be of the same video  
standard (NTSC or PAL). In the event that you have connected mixed video standard 
cameras, the video frames for any camera that is different from the 
specified video standard will be distorted. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_board_disconnect"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_board_disconnect">sdvr_board_disconnect</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> board_index);
</PRE>
<DIV CLASS="descr">
<P>
This function disconnects from a board, and releases all the board 
specific resources allocated in the SDK and driver.  
After this call, all attempts to communicate with the board fail.  
</P>
<P>
To shut down your system cleanly, you must call this function for every  
SDVR board to which you were connected before you exit your application. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>board_index</EM> - The number of the board from which you want to disconnect.  
This is a zero based number. It means the first board number  
is index zero, second board number is index one, and so on. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
If disconnect fails, you must restart your application before you  
can connect to the same board again. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
You must call <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_upgrade_firmware">sdvr_upgrade_firmware</A>()</NOBR> to load the firmware every time  
prior to connecting to the DVR board if no firmware is loaded into  
the board's none-volatile  memory. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_upgrade_firmware"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_upgrade_firmware">sdvr_upgrade_firmware</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>   board_index,
                                  char      * firmware_file_name);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to load a firmware on to the board. This function  
loads the contents of the given file (which is required to be in a  
.rom format) into the board memory, and directs the board to  
burn it into volatile memory. The board then automatically <EM>reboots</EM>,  
i.e., starts up with the new firmware, without requiring a PC reboot.  
</P>
<P>
Before you load the firmware, you must disconnect from the board using  
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_board_disconnect">sdvr_board_disconnect</A>()</NOBR>. You must shut down all board functionality before  
attempting to load a new firmware. Also, after you upgrade firmware,  
you must reconnect to the board using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_board_connect">sdvr_board_connect</A>()</NOBR>.  
</P>
<P>
<STRONG>NOTE:  You must load the firmware every time prior to connecting  
to the DVR board if no firmware is loaded into the board's none-volatile  
memory.</STRONG> 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>board_index</EM> - The number of the board that you want to upgrade.  
This is a zero based number. It means the first board number  
is index zero, second board number is index one, and so on. 
</LI>
<LI>
<EM>firmware_file_name</EM> - A string containing the name of the new 
firmware file in .rom format. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_sdk_params"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_sdk_params">sdvr_get_sdk_params</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_sdk_params_t">sdvr_sdk_params_t</A> *sdk_params);
</PRE>
<DIV CLASS="descr">
<P>
This function gets the SDK parameters that control resource allocation 
in the SDK.  
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>sdk_params</EM> - A pointer to a structure containing the SDK information  
that will be filled when this function returns. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
We recommend that you call this function prior to the call to  
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_sdk_params">sdvr_set_sdk_params</A>()</NOBR> to preserve the default values of any 
SDK parameters that do not need to be changed. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_set_sdk_params"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_set_sdk_params">sdvr_set_sdk_params</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_sdk_params_t">sdvr_sdk_params_t</A> *sdk_params);
</PRE>
<DIV CLASS="descr">
<P>
This function sets the SDK parameters that control resource allocation 
in the SDK. It must be called before you connect to any boards 
to assign buffer resources. Otherwise, the default buffer resource values 
will be used by the SDK. Any subsequent calls to this function after  
being connected will only result in changing the debug information  
or the PCI response timeout value. 
</P>
<P>
We highly recommend that you not change the default buffer size or numbers 
unless it is needed for performance reasons. 
</P>
<P>
To change only some SDK parameters and keep the default setting for the 
rest, you should call <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_sdk_params">sdvr_get_sdk_params</A>()</NOBR> to get the existing  
parameter settings, change the desired parameters, and then call  
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_sdk_params">sdvr_set_sdk_params</A>()</NOBR>. 
</P>
<P>
There must be at least one buffer specified for each of the  
system buffers. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>sdk_params</EM> - A pointer to a structure containing the SDK information  
that you want to set. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
See <A HREF="#sdvr_sdk_html_Types__sdvr_sdk_params_t">sdvr_sdk_params_t</A> for detail SDK parameter information and  
buffer size limits. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_sdk_version"></a>
<PRE class="cdef">
void <A HREF="#sdvr_sdk_html_Routines__sdvr_get_sdk_version">sdvr_get_sdk_version</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> * major,
                           <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> * minor,
                           <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> * revision,
                           <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> * build);
</PRE>
<DIV CLASS="descr">
<P>
This function returns the SDK version. 
</P>
<P>
Stretch follows the convention of using four numbers for version  
control. A change in the major number indicates major changes to  
functionality, a change in the minor number indicates minor  
changes to functionality, and a change in the revision number indicates 
significant bug fixes that were introduced in the minor change functionality.  
A change to the build number indicates only bug fixes that do not  
change functionality.  
</P>
<P>
This function can be called before or after <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_sdk_init">sdvr_sdk_init</A>()</NOBR>; 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>major</EM> - Pointer to a variable that will hold the major version of the  
SDK when this function returns.  
</LI>
<LI>
<EM>minor</EM> - Pointer to a variable that will hold the minor version of  
the SDK when this function returns.  
</LI>
<LI>
<EM>revision</EM> - Pointer to a variable that will hold the revision version of the  
SDK when this function returns.  
</LI>
<LI>
<EM>build</EM> - Pointer to a variable that will hold the build or bug fix  
version of the SDK when this function returns.  
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
Nothing.  
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_driver_version"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_driver_version">sdvr_get_driver_version</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>   board_index,
                                    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>  * major,
                                    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>  * minor,
                                    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>  * revision,
                                    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>  * build);
</PRE>
<DIV CLASS="descr">
<P>
This function returns the driver version. 
</P>
<P>
Stretch follows the convention of using four numbers for version  
control. A change in the major number indicates major changes to  
functionality, a change in the minor number indicates minor  
changes to functionality, and a change in the revision number indicates 
significant bug fixes that were introduced in the minor change functionality.  
A change to the build number indicates only bug fixes that do not  
change functionality.  
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>board_index</EM> - The number of the board whose driver version we want. 
This is a zero based number. It means the first board number  
is index zero, second board number is index one, and so on. 
</LI>
<LI>
<EM>major</EM> - Pointer to a variable that will hold the major version of the  
driver when this function returns.  
</LI>
<LI>
<EM>minor</EM> - Pointer to a variable that will hold the minor version of  
the driver when this function returns. 
</LI>
<LI>
<EM>revision</EM> - Pointer to a variable that will hold the revision version of the  
driver when this function returns.  
</LI>
<LI>
<EM>build</EM> - Pointer to a variable that will hold the build or bug fix  
version of the driver when this function returns.  
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_firmware_version_ex"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_firmware_version_ex">sdvr_get_firmware_version_ex</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>             board_index,
                                         <A HREF="#sdvr_sdk_html_Types__sdvr_firmware_ver_t">sdvr_firmware_ver_t</A> * version_info);
</PRE>
<DIV CLASS="descr">
<P>
This function returns the firmware and boot loader version. 
</P>
<P>
Stretch follows the convention of using four numbers for version  
control. A change in the major number indicates major changes to  
functionality, a change in the minor number indicates minor  
changes to functionality, and a change in the revision number indicates 
significant bug fixes that were introduced in the minor change functionality.  
A change to the build number indicates only bug fixes that do not  
change functionality.  
</P>
<P>
You can access the build date of the firmware in addition to the firmware version and 
version of the boot loader. 
</P>
<P>
This function must be called after calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_upgrade_firmware">sdvr_upgrade_firmware</A>()</NOBR> to 
get the boot loader information and after <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_board_connect">sdvr_board_connect</A>()</NOBR> 
to get both the firmware and boot loader versions. 
</P>
<P>
This function can still be used to get the BSP and bootloader version even if 
the call to <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_upgrade_firmware">sdvr_upgrade_firmware</A>()</NOBR> returns an error. In such cases, no other 
version information is available. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>board_index</EM> - The number of the board whose firmware version we want. 
This is a zero based number. It means the first board number  
is index zero, second board number is index one, and so on. 
</LI>
<LI>
<EM>version_info</EM> - A pointer to a structure that holds the firmware 
and boot loader version numbers. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - Both the firmware and boot loader version information 
are returned. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_BOARD_NOT_CONNECTED">SDVR_ERR_BOARD_NOT_CONNECTED</A> - The firmware version is not returned 
because the given board number is not connected. But the 
boot loader information might have been returned if it is non-zero. 
</LI>
<LI>
Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_set_sensor_callback"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_sensor_callback">sdvr_sensor_callback</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_set_sensor_callback">sdvr_set_sensor_callback</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_sensor_callback">sdvr_sensor_callback</A>   sensor_callback);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to register the sensor callback function. There 
can be only one function registered for this callback.  
</P>
<P>
For the DVR Application to be notified of sensor events, it has 
to register a callback. The callback function has as its arguments the  
board index and the sensor map that contains a bit pattern describing the 
sensors that have triggered. This information can be  
used in the callback function to determine which sensors have  
triggered and take the appropriate action. Bit 0 in the 
sensor map corresponds to sensor 0, bit 1 to sensor 1, and so on. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>sensor_callback</EM> -  A pointer to the callback function.  
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
Returns a pointer to the previous function that was registered for  
this callback. If no function was registered previously, the return value is a  
NULL function pointer. This can be used to temporarily override a  
callback function with another and then to restore the original callback.  
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_set_video_alarm_callback"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_video_alarm_callback">sdvr_video_alarm_callback</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_set_video_alarm_callback">sdvr_set_video_alarm_callback</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_video_alarm_callback">sdvr_video_alarm_callback</A>   video_alarm_callback);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to register the video alarm callback. There 
can only be one function registered for this callback.  
</P>
<P>
For the DVR Application to be notified of video alarm events,  
it has to register a callback. The callback function has as its  
arguments the video channel handle, the alarm type, and the value 
associated with the alarm. 
This information can be used in the callback function to determine the  
type of event that occurred and, to take the appropriate action. 
There is one callback per video event, even if the events 
happen simultaneously. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>alarm_callback</EM> - A pointer to the callback function. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
Returns a pointer to the previous function that was registered for this  
callback. If no function was registered previously, the return value is a NULL  
function pointer. This can be used to temporarily override a  
callback function with another and then restore the original callback.  
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
See <A HREF="#sdvr_sdk_html_Types__sdvr_video_alarm_callback">sdvr_video_alarm_callback</A> definition for more detailed information. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_set_av_frame_callback"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_av_frame_callback">sdvr_av_frame_callback</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_set_av_frame_callback">sdvr_set_av_frame_callback</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_av_frame_callback">sdvr_av_frame_callback</A>   av_frame_callback);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to register the AV frame callback function. There 
can be only one function registered for this callback.  
The callback is called every time encoded AV, raw video, and raw  
audio frames are received from the SDVR boards. The function  
has as its arguments the board index, the channel number, the  
frame type, and whether the frame is from a primary channel.  
This information can be used in the callback function to perform the  
appropriate action; encoded frames are saved to disk, raw video  
frames are displayed, and raw audio frames are played.  
</P>
<P>
The callback function is used for asynchronous notification, somewhat like 
a hardware interrupt. We recommend that you note the information 
provided in the callback, but not process the A/V frame itself in the 
callback function. That should be done in the appropriate routine or thread 
dedicated to processing encoded and raw frames. 
</P>
<P>
<STRONG>NOTE: It is not necessary to register this callback. A polling mechanism 
can be used with <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_av_buffer">sdvr_get_av_buffer</A>()</NOBR> to get the buffers.</STRONG> 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>av_frame_callback</EM> - A pointer to the callback function. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
Returns a pointer to the previous function that was registered for this  
callback. If no function was registered previously, the return value is a NULL  
function pointer. This can be used to temporarily override a  
callback function with another and then to restore the original callback. 
</LI>
</UL>
<P>
Example callback function: 
<PRE class="ccode">
  void av_frame_callback(<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A> handle, 
     <A HREF="#sdvr_sdk_html_Types__sdvr_frame_type_e">sdvr_frame_type_e</A> frame_type, <A HREF="#sdvr_sdk_html_Types__sx_bool">sx_bool</A> is_primary) 
  { 
      <A HREF="#sdvr_sdk_html_Types__sdvr_av_buffer_t">sdvr_av_buffer_t</A>  *av_buffer; 
      <A HREF="#sdvr_sdk_html_Types__sdvr_yuv_buffer_t">sdvr_yuv_buffer_t</A> *yuv_buf; 
      switch (frame_type) 
      { 
      case <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_AUDIO_ENCODED">SDVR_FRAME_AUDIO_ENCODED</A>: 
          if (<A HREF="#sdvr_sdk_html_Routines__sdvr_get_av_buffer">sdvr_get_av_buffer</A>(handle, <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_AUDIO_ENCODED">SDVR_FRAME_AUDIO_ENCODED</A>,  
                                 &amp;av_buffer) == <A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A>) 
          { 
                &lt;add the buffer to an audio queue to be processed from  
                a different thread&gt; 
                &lt;The buffer should be released from that thread when  
                you processed the audio frame.&gt; 
          } 
          break; 
      case <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_RAW_VIDEO">SDVR_FRAME_RAW_VIDEO</A>: 
          if (<A HREF="#sdvr_sdk_html_Routines__sdvr_get_yuv_buffer">sdvr_get_yuv_buffer</A>(handle, &amp;yuv_buf) == <A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A>) 
          { 
                &lt;add the buffer to a YUV queue to be processed from  
                a different thread&gt; 
                &lt;The YUV buffer should be released from that thread 
                when you processed the frame.&gt; 
          } 
          break; 
      case <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_H264_IDR">SDVR_FRAME_H264_IDR</A>: 
      case <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_H264_I">SDVR_FRAME_H264_I</A>: 
      case <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_H264_P">SDVR_FRAME_H264_P</A>: 
      case <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_H264_B">SDVR_FRAME_H264_B</A>: 
      case <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_H264_SPS">SDVR_FRAME_H264_SPS</A>: 
      case <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_H264_PPS">SDVR_FRAME_H264_PPS</A>: 
      case <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_JPEG">SDVR_FRAME_JPEG</A>: 
      case <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_MPEG4_I">SDVR_FRAME_MPEG4_I</A>: 
      case <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_MPEG4_P">SDVR_FRAME_MPEG4_P</A>: 
      case <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_MPEG4_VOL">SDVR_FRAME_MPEG4_VOL</A>: 
          if (<A HREF="#sdvr_sdk_html_Routines__sdvr_get_av_buffer">sdvr_get_av_buffer</A>(handle,  
            is_primary ? <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_VIDEO_ENCODED_PRIMARY">SDVR_FRAME_VIDEO_ENCODED_PRIMARY</A> :  
            <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_VIDEO_ENCODED_SECONDARY">SDVR_FRAME_VIDEO_ENCODED_SECONDARY</A>, &amp;av_buffer) == <A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A>) 
          { 
                &lt;add the buffer to a video encoded queue to be processed 
                from a different thread.&gt; 
                &lt;The buffer should be released from that thread when  
                you processed the video frame.&gt; 
          } 
          break; 
      } 
      NOTE: Any buffer that is not retrieved(i.e. no call to the 
            "sdvr_get_xxx_buffer") will be freed by the SDK once 
            the frame queue is full. 
  } 
</PRE>
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_set_display_debug"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_display_debug_callback">sdvr_display_debug_callback</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_set_display_debug">sdvr_set_display_debug</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_display_debug_callback">sdvr_display_debug_callback</A>   display_debug_callback);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to register the callback function that displays the 
debug message. 
</P>
<P>
Through this callback mechanism, the SDK alerts the DVR  
Application whenever tracing error messages need to be displayed on the 
screen. 
</P>
<P>
The callback function takes as its argument the string buffer to display. 
</P>
<P>
<STRONG>NOTE: If this callback is not registered and you enable the display-to-screen 
flag, the message is written to stdout.</STRONG> 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>display_debug_callback</EM> - A pointer to the callback function.  
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
Returns a pointer to the previous function that was registered for this  
callback. If no function was previously registered, the return value is a NULL  
function pointer. This can be used to temporarily override a  
callback function with another and then to restore the original callback. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_set_signals_callback"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_signals_callback">sdvr_signals_callback</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_set_signals_callback">sdvr_set_signals_callback</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_signals_callback">sdvr_signals_callback</A>   signals_callback);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to register the signal callback function. There 
can be only one function registered for this callback.  
</P>
<P>
For the DVR Application to be notified of asynchronous events such as 
error conditions in the DVR firmware, it has to register a callback.  
The callback function has as its arguments the  
board index and a pointer to data structure associated with the signal event.  
This information  can be used in the callback function to determine which 
device caused the signal to be triggered and whether the DVR Application 
should be closed or continue the execution. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>signals_callback</EM> -  A pointer to the callback function.  
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
Returns a pointer to the previous function that was registered for  
this callback. If no function was registered previously, the return value is a  
NULL function pointer. This can be used to temporarily override a  
callback function with another and then to restore the original callback.  
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_set_confirmation_callback"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_send_confirmation_callback">sdvr_send_confirmation_callback</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_set_confirmation_callback">sdvr_set_confirmation_callback</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_send_confirmation_callback">sdvr_send_confirmation_callback</A>   conf_callback);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to register the video send confirmation callback. There 
can only be one function registered for this callback.  
</P>
<P>
For the DVR Application to be notified of video sent confirmation,  
it has to register a callback. The callback function has as its  
arguments the channel handle. 
This information can be used in the callback function to determine   
for which channel the video was sent. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>conf_callback</EM> - A pointer to the callback function. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
Returns a pointer to the previous function that was registered for this  
callback. If no function was registered previously, the return value is a NULL  
function pointer. This can be used to temporarily override a  
callback function with another and then restore the original callback.  
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
See <A HREF="#sdvr_sdk_html_Types__sdvr_send_confirmation_callback">sdvr_send_confirmation_callback</A> definition for more detailed information. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_board_config"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_board_config">sdvr_get_board_config</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>             board_index,
                                  <A HREF="#sdvr_sdk_html_Types__sdvr_board_config_t">sdvr_board_config_t</A> * board_config);
</PRE>
<DIV CLASS="descr">
<P>
This function returns the board configuration parameters, i.e., the 
number of cameras, number of sensors and relays, and so on. 
</P>
<P>
There is no corresponding function to set these parameters 
because the configuration information returned by this function cannot 
be changed. The configuration information essentially is a description  
of the capabilities of the board. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>board_index</EM> - The index of the board for which you want this information. 
This is a zero based number. It means the first board number  
is index zero, second board number is index one, and so on. 
</LI>
<LI>
<EM>board_config</EM> - A pointer to a configuration data structure that  
is filled appropriately when this function returns. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise see the error code list. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
It is not necessary to connect to the board to call this function. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_supported_vstd"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_supported_vstd">sdvr_get_supported_vstd</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>   board_index,
                                    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> * video_stds);
</PRE>
<DIV CLASS="descr">
<P>
This function gets a list all video standards supported by the 
firmware for a given board. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>board_index</EM> - The index of the board. 
This is a zero based number. It means the first board number  
is index zero, second board number is index one, and so on. 
</LI>
<LI>
<EM>video_stds</EM> - A pointer to a variable that contains all the supported   
video standards. It is a bit OR of <A HREF="#sdvr_sdk_html_Types__sdvr_video_std_e">sdvr_video_std_e</A>. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise see the error code list. 
</LI>
</UL>
<P>
Remark: 
</P>
<UL>
<LI>
Call this function or <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_board_attributes">sdvr_get_board_attributes</A>()</NOBR> before calling  
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_board_connect">sdvr_board_connect</A>()</NOBR> to select one of the supported video standards  
by the firmware. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_video_standard"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_video_standard">sdvr_get_video_standard</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>          board_index,
                                    <A HREF="#sdvr_sdk_html_Types__sdvr_video_std_e">sdvr_video_std_e</A> * video_std_type);
</PRE>
<DIV CLASS="descr">
<P>
This function returns the current video standard for a particular board.  
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>board_index</EM> - The index of the board. 
This is a zero based number. It means the first board number  
is index zero, second board number is index one, and so on. 
</LI>
<LI>
<EM>video_std_type</EM> - A pointer to a variable that will contain the video  
standard when this function returns.  
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise see the error code list. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
All boards in a system must have the same video standard.  
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_set_watchdog_state"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_set_watchdog_state">sdvr_set_watchdog_state</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>   board_index,
                                    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>   enable);
</PRE>
<DIV CLASS="descr">
<P>
This function enables or disables the watchdog timer. By default each board is  
equipped with a watchdog timer to expire in 10 second once it is enabled.  
When the watchdog timer expires, the board is reset and a reset 
signal is issued from the board. If this reset signal is tied to the  
reset signal on the PC's motherboard, the entire PC is reset and 
rebooted.  
</P>
<P>
To change the default watchdog timer period call <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_watchdog_state_ex">sdvr_set_watchdog_state_ex</A>()</NOBR>. 
</P>
<P>
<STRONG>NOTE: When the watchdog timer expires, data on the way to the disk  
maybe lost and the system may be left in an inconsistent state. Therefore,  
use this function with caution and make sure to re-boot the PC before 
loading the firmware to it.</STRONG> 
</P>
<P>
If you are going to use this function, to guard against the system hanging 
indefinitely, then set the watchdog timer on all boards in your system.  
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>board_index</EM> - Index of the board on which to set the watchdog timer. 
This is a zero based number. It means the first board number  
is index zero, second board number is index one, and so on. 
</LI>
<LI>
<EM>enable</EM> - Enable or disable the watchdog timer. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise see the error code list. 
</LI>
</UL>
<P>
Remark: 
</P>
<UL>
<LI>
Whatever watchdog timer is set at 10 seconds, it is recommended to call 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_watchdog_state">sdvr_set_watchdog_state</A>()</NOBR> every 5 seconds to prevent the timer from 
expiring. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_set_watchdog_state_ex"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_set_watchdog_state_ex">sdvr_set_watchdog_state_ex</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>   board_index,
                                       <A HREF="#sdvr_sdk_html_Types__sx_bool">sx_bool</A>     enable,
                                       <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>   msec);
</PRE>
<DIV CLASS="descr">
<P>
This function sets the state of the watchdog timer as well as the  
timer interval. See <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_watchdog_state">sdvr_set_watchdog_state</A>()</NOBR> for detailed  
description. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>board_index</EM> - Index of the board on which to set the watchdog timer. 
This is a zero based number. It means the first board number  
is index zero, second board number is index one, and so on. 
</LI>
<LI>
<EM>enable</EM>  Set to <A HREF="#sdvr_sdk_html_Defines__true">true</A> to enable the watchdog timer,  
<A HREF="#sdvr_sdk_html_Defines__false">false</A> to disable it. Once enabled, the timer must 
be refreshed at intervals not exceeding the specified timeout. 
</LI>
<LI>
<EM>msec</EM> - Specifies the watchdog timer duration in milliseconds.  
The valid range is 1-10,000. If this field is zero and the enable  
flag is set then the timeout period defaults to 10,000 milliseconds (10 seconds).  
This field is ignored if <EM>enable</EM> is <A HREF="#sdvr_sdk_html_Defines__false">false</A>. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise see the error code list. 
</LI>
</UL>
<P>
Remark: 
</P>
<UL>
<LI>
Since watchdog timer is set at 10 seconds, it is recommended to call 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_watchdog_state_ex">sdvr_set_watchdog_state_ex</A>()</NOBR> every 5 seconds to prevent the timer from 
expiring. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_watchdog_state"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_watchdog_state">sdvr_get_watchdog_state</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>   board_index,
                                    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> * enable);
</PRE>
<DIV CLASS="descr">
<P>
This function returns the current enable state of the watchdog timer.  
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>board_index</EM> - The index of the board whose watchdog timer value you  
want to get. This is a zero based number. It means the first board number  
is index zero, second board number is index one, and so on. 
</LI>
<LI>
<EM>enable</EM> -  A pointer to a variable that will have the enable state 
of watchdog timer on success return. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_set_date_time"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_set_date_time">sdvr_set_date_time</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> board_index, <A HREF="#sdvr_sdk_html_Types__time_t">time_t</A> time);
</PRE>
<DIV CLASS="descr">
<P>
This function sets the date and time in the firmware of a particular  
SDVR board. The time is specified as a 32-bit value, which is the number 
of seconds elapsed since midnight of January 1, 1970.  
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>board_index</EM> - Index of the board on which to set the time. 
This is a zero based number. It means the first board number  
is index zero, second board number is index one, and so on. 
</LI>
<LI>
<EM>time</EM> - The time value to be set.  
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_date_time"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_date_time">sdvr_get_date_time</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> board_index, <A HREF="#sdvr_sdk_html_Types__time_t">time_t</A> *time);
</PRE>
<DIV CLASS="descr">
<P>
This function returns the date and time set in the firmware of a particular 
SDVR board. The time returned is a 32-bit value, which gives the number 
of seconds elapsed since midnight of January 1, 1970.  
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>board_index</EM> - Index of the board for which the time is requested. 
This is a zero based number. It means the first board number  
is index zero, second board number is index one, and so on. 
</LI>
<LI>
<EM>time</EM> - A pointer to a <A HREF="#sdvr_sdk_html_Types__time_t">time_t</A> type that will hold the value of time 
when this function returns.  
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_run_diagnostics"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_run_diagnostics">sdvr_run_diagnostics</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>          board_index,
                                 char             * diag_file_name,
                                 <A HREF="#sdvr_sdk_html_Types__sdvr_diag_code_e">sdvr_diag_code_e</A> * diag_code,
                                 int              * diag_code_size);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to run diagnostics on the board. It accepts the 
name of the diagnostics firmware file and returns the diagnostics result 
in the given diag_code parameter. This function overwrites the  
existing DVR firmware, so you must reload the DVR firmware for the DVR 
to function properly. 
</P>
<P>
Running diagnostics can take some time.  
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>board_index</EM> - Index of the board for which to run the diagnostics. 
This is a zero based number. It means the first board number  
is index zero, second board number is index one, and so on. 
</LI>
<LI>
<EM>diag_file_name</EM> - A string containing the name of the file  
containing the diagnostics firmware. 
</LI>
<LI>
<EM>diag_code</EM> - A pointer to an array of <STRONG>thirty-two</STRONG> 32-bit variables that 
hold the diagnostics results for each PE. Upon return diag_code[0] will 
hold the result for PE0, diag_code[1] has the result for PE1, and so on. 
Refer to <A HREF="#sdvr_sdk_html_Types__sdvr_diag_code_e">sdvr_diag_code_e</A> for the possible values. 
</LI>
<LI>
<EM>diag_code_size</EM> - A pointer to an integer which holds the actual 
number of valid diagnostics results in the <EM>diag_code</EM> parameter. 
(i.e., In a five PE DVR board, the variable will be set to five on 
successful return.) 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_board_index"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_board_index">sdvr_get_board_index</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A> handle);
</PRE>
<DIV CLASS="descr">
<P>
This function returns the board number, given a channel handle. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - A channel handle. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
Zero-based board index corresponding to this handle. A return value of 0xFF  
indicates that the channel handle is invalid. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_chan_num"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_chan_num">sdvr_get_chan_num</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A> handle);
</PRE>
<DIV CLASS="descr">
<P>
This function returns the channel number, given a channel handle. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - A channel handle. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
Channel number corresponding to this handle. A return value of 0xFF  
indicates that the channel handle is invalid. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_chan_type"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_chan_type_e">sdvr_chan_type_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_chan_type">sdvr_get_chan_type</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A> handle);
</PRE>
<DIV CLASS="descr">
<P>
This function returns the channel type, given a handle. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - A channel handle. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_CHAN_TYPE_ENCODER">SDVR_CHAN_TYPE_ENCODER</A> - For an encoding channel. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_CHAN_TYPE_DECODER">SDVR_CHAN_TYPE_DECODER</A> - For a decoding channel. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_CHAN_TYPE_OUTPUT">SDVR_CHAN_TYPE_OUTPUT</A> - Internal use to the SDK only for videoout. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_CHAN_TYPE_NONE">SDVR_CHAN_TYPE_NONE</A> - For a channel whose type is either not set, or 
the channel handle is invalid. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_write_ioctl"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_write_ioctl">sdvr_write_ioctl</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>   handle,
                             <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>             device_id,
                             <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>             reg_num,
                             <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A>            value);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to send any random value to a given 
I/O device of particular camera. This function is intended for testing or  
experimenting the I/O device hardware. As such, there is no 
error checking and must be used with cautious. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - An encoding channel handle. 
</LI>
<LI>
<EM>device_id</EM> - Device ID to update its register. 
</LI>
<LI>
<EM>reg_num</EM> - Register number to on the given device to write. 
</LI>
<LI>
<EM>value</EM> - The value to write to the given register on the 
I/O device. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_read_ioctl"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_read_ioctl">sdvr_read_ioctl</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>   handle,
                            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>             device_id,
                            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>             reg_num,
                            <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A>          * value_ptr);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to read a 16-bit value from a given 
I/O device of a particular camera. This function is intended for testing or  
experimenting with the I/O device hardware. As such, there is no 
error checking and must be used with cautious.  
</P>
<P>
In many cases, you may need to call <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_write_ioctl">sdvr_write_ioctl</A>()</NOBR> before 
calling this function to get a value. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - An encoding channel handle. 
</LI>
<LI>
<EM>device_id</EM> - Device ID to update its register. 
</LI>
<LI>
<EM>reg_num</EM> - Register number to on the given device to read. 
</LI>
<LI>
<EM>value_ptr</EM> - A pointer to a 16-bit value to read from the given  
register on the I/O device. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>

<a name="sdvr_sdk_html_Routines__Channel___Set___Up___API"></a>
<H3>4.10.2 &nbsp; Channel Set Up API</H3>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_create_chan"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_create_chan">sdvr_create_chan</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_def_t">sdvr_chan_def_t</A>    * chan_def,
                             <A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A> * handle_ptr);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to create an encoding, decoding, or HMO-only channel. 
</P>
<P>
Each board can have a certain number of cameras connected to it.  
Call this number M. The encoding channels on the board 
are then numbered from 0 to M-1. Any channel number in this range 
is an encoding channel and corresponds to the physical camera connection 
on the board. Additionally, you can have a certain number of decoders. 
Call this number N. The decoding channels on the board are also numbered 
from 0 to N-1. These decoder channel number are virtual because there is no 
physical hardware attached to them unlike the encoder channels. 
</P>
<P>
Each Stretch chip is capable of encoding or decoding four D1 video channels, 
but the sum of encoding and decoding channels may not exceed six.  
This means that channel numbers 0 to 3 are assigned to first Stretch chip,  
the next four channel numbers are assigned to the second Stretch chip and so on. 
</P>
<P>
The number of decoding channels 
that can be setup depends on the processing power left after all encoding 
channels are assigned. When this function is called to set up a decoding 
channel, it may fail because there is no more processing power left for 
decoding. If the call is successful in setting up a decoding channel, 
another call to this function can be tried to set up an additional  
decoding channel. This procedure can be repeated until the calls fails,  
which indicates that there is no more processing power left. 
</P>
<P>
Even though you can have 0 to M-1 encoding channels, you do not have 
to use all of them for encoding (perhaps because not that many cameras 
are connected to the board). This allows you to have more decoding 
channels. Use this function to set the encoding channels to the ones 
that have cameras connected to them.  
</P>
<P>
A video encoding channel can have up to two different video encoder, as  
well as an optional audio encoder. By specifying 
a secondary video encoder for a channel, you are taking a way 
more computing power which may not allow you to have four D1 video 
encoding or decoding channels. 
</P>
<P>
Upon success, this call returns a handle to a channel that is 
used for all other calls that need a channel identifier. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>chan_def</EM> - Data structure defining the new channel attributes. 
</LI>
<LI>
<EM>handle_ptr</EM> - Upon return, if there is no error, this field holds 
the channel handle. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_set_channel_default"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_set_channel_default">sdvr_set_channel_default</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A> handle);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to reset an encoding or decoding channel to its factory  
default settings.  
Make sure to close down the channel (stop encoding or decoding) before  
resetting the channel. 
</P>
<P>
The default settings of an encoding channel can be found in the  
description of the <A HREF="#sdvr_sdk_html_Types__sdvr_video_enc_chan_params_t">sdvr_video_enc_chan_params_t</A> data structure.  
The call to this function for decoder channel results in no operation 
since currently there is no decoder parameters defined. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - An encoding or decoding channel handle. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_destroy_chan"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_destroy_chan">sdvr_destroy_chan</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A> handle);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to destroy the given channel handle.  
</P>
<P>
After you have setup some encoder or decoder channels, and you need to add 
more, you may get an error message that there is not enough CPU power to 
add the new channel. In this case, you may decide to temporarily destroy 
one or more channels and add the new channel type. 
</P>
<P>
NOTE: You must stop all A/V streaming on this channel before  
destroying it. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - The channel handle to be destroyed. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_set_chan_user_data"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_set_chan_user_data">sdvr_set_chan_user_data</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>   handle,
                                    <A HREF="#sdvr_sdk_html_Types__sx_uint64">sx_uint64</A>            user_data);
</PRE>
<DIV CLASS="descr">
<P>
In your DVR Application, you may need to access a certain data structure 
which is associated with an encoder or decoder channel. 
</P>
<P>
This function allows you to associate a 64-bit variable to a specified channel  
handle. This data can be retrieved at any time by calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_chan_user_data">sdvr_get_chan_user_data</A>()</NOBR>. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - An encoding or decoding video channel handle. 
</LI>
<LI>
<EM>user_data</EM> - Specifies the data to be associated with the channel. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_chan_user_data"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_chan_user_data">sdvr_get_chan_user_data</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>   handle,
                                    <A HREF="#sdvr_sdk_html_Types__sx_uint64">sx_uint64</A>          * user_data);
</PRE>
<DIV CLASS="descr">
<P>
This function lets you retrieve the application-defined data associated  
with the specified channel handle. This 64-bit variable was set by calling  
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_chan_user_data">sdvr_get_chan_user_data</A>()</NOBR>. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - An encoding or decoding video channel handle. 
</LI>
<LI>
<EM>user_data</EM> - A pointer to hold the data associated with this  
channel. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_set_video_encoder_channel_params"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_set_video_encoder_channel_params">sdvr_set_video_encoder_channel_params</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>             handle,
                                                  <A HREF="#sdvr_sdk_html_Types__sdvr_sub_encoders_e">sdvr_sub_encoders_e</A>            sub_chan_enc,
                                                  <A HREF="#sdvr_sdk_html_Types__sdvr_video_enc_chan_params_t">sdvr_video_enc_chan_params_t</A> * video_enc_params);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to set the video parameters for either the primary or 
secondary encoder of a video encoder channel. 
The encoder channel parameters are determined by the type of connected camera, 
the resolution, frame rate, and so on. All of these parameters are 
defined in <A HREF="#sdvr_sdk_html_Types__sdvr_video_enc_chan_params_t">sdvr_video_enc_chan_params_t</A>, and are set using this 
function. Any video encoder parameter except the video resolution can 
be changed regardless of the encoder enable status. This means to change 
the video resolution of a channel the encoder must be disabled first before 
calling this function. 
</P>
<P>
There are no corresponding functions for setting the parameters 
for a video decoding channel. This is because the video decoding  
channel takes its parameters from the encoded stream.  
</P>
<P>
The encoder-specific parameters are ignored for any channel 
that has its primary encoder set to <A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_ENC_NONE">SDVR_VIDEO_ENC_NONE</A>. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - An encoding channel handle. 
</LI>
<LI>
<EM>sub_chan_enc</EM> - Specifies whether to set the parameters for the primary 
or secondary encoder. 
</LI>
<LI>
<EM>video_enc_params</EM> - The parameters for the video encoder channel.  
See <A HREF="#sdvr_sdk_html_Types__sdvr_video_enc_chan_params_t">sdvr_video_enc_chan_params_t</A> for detailed information of each 
parameter. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
Any of the video encoder parameters can be changed while the encoder is enabled, 
except video resolution. If the encoder is enabled, all the encoder 
parameter changes take place at the beginning of the next GOP with the exception of 
frame rate and GOP size which takes place immediately. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_video_encoder_channel_params"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_video_encoder_channel_params">sdvr_get_video_encoder_channel_params</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>             handle,
                                                  <A HREF="#sdvr_sdk_html_Types__sdvr_sub_encoders_e">sdvr_sub_encoders_e</A>            sub_chan_enc,
                                                  <A HREF="#sdvr_sdk_html_Types__sdvr_video_enc_chan_params_t">sdvr_video_enc_chan_params_t</A> * video_enc_params);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to get the parameters of a video encoder channel.  
</P>
<P>
The encoder-specific parameters for any channel 
that has its primary encoder set to <A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_ENC_NONE">SDVR_VIDEO_ENC_NONE</A> have no meaning. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - An encoding channel handle. 
</LI>
<LI>
<EM>sub_chan_enc</EM> - Specifies whether to set the parameters for the primary 
or secondary encoder. 
</LI>
<LI>
<EM>video_enc_params</EM> - A pointer to a variable that will be filled with 
encoder channel parameters when this function returns.  
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_set_alarm_video_encoder_params"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_set_alarm_video_encoder_params">sdvr_set_alarm_video_encoder_params</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>              handle,
                                                <A HREF="#sdvr_sdk_html_Types__sdvr_sub_encoders_e">sdvr_sub_encoders_e</A>             sub_chan_enc,
                                                <A HREF="#sdvr_sdk_html_Types__sdvr_alarm_video_enc_params_t">sdvr_alarm_video_enc_params_t</A> * alarm_video_enc_params);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to set the parameters of a video encoder channel 
after any of the alarms are triggered. You can specify two sets of 
video encoder parameters. One to be used on streaming of video encoded 
frames before alarms are triggered. The other to be used after any of the 
alarms is triggered for a minimum duration.  
</P>
<P>
Note: These parameters are used only for encoded channels and while  
they are enabled. Otherwise, the value of the encoder parameters for both 
pre- and post-alarm condition is ignored. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - Handle of an encoding channel. 
</LI>
<LI>
<EM>sub_chan_enc</EM> - Specifies whether to set the parameters for the primary 
or secondary encoder. 
</LI>
<LI>
<EM>alarm_video_enc_params</EM> - The parameters for the video encoder channel 
after an alarm is triggered. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_alarm_video_encoder_params"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_alarm_video_encoder_params">sdvr_get_alarm_video_encoder_params</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>              handle,
                                                <A HREF="#sdvr_sdk_html_Types__sdvr_sub_encoders_e">sdvr_sub_encoders_e</A>             sub_chan_enc,
                                                <A HREF="#sdvr_sdk_html_Types__sdvr_alarm_video_enc_params_t">sdvr_alarm_video_enc_params_t</A> * alarm_video_enc_params);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to get the parameters of a video encoder channel after 
an alarm has triggered. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - Handle of an encoding channel. 
</LI>
<LI>
<EM>sub_chan_enc</EM> - Specifies whether to set the parameters for the primary 
or secondary encoder. 
</LI>
<LI>
<EM>alarm_video_enc_params</EM> - A pointer to a variable that will be filled  
with post-alarm encoder channel parameters when this function returns.  
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_set_audio_encoder_channel_params"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_set_audio_encoder_channel_params">sdvr_set_audio_encoder_channel_params</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>             handle,
                                                  <A HREF="#sdvr_sdk_html_Types__sdvr_audio_enc_chan_params_t">sdvr_audio_enc_chan_params_t</A> * audio_enc_params);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to set the parameters of an audio encoder channel.  
There are no corresponding functions for setting the parameters 
for an audio decoding channel. This is because the decoding  
channel takes its parameters from the encoded stream.  
</P>
<P>
The parameters of an audio encoding channel can only be changed when 
encoding is stopped. 
</P>
<P>
<STRONG>NOTE: This feature is not implemented in this release. Only G.711 
audio encoding is supported for this release.</STRONG> 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - An encoding channel handle. 
</LI>
<LI>
<EM>audio_enc_params</EM> - The parameters for the audio encoder channel.  
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_audio_encoder_channel_params"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_audio_encoder_channel_params">sdvr_get_audio_encoder_channel_params</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>             handle,
                                                  <A HREF="#sdvr_sdk_html_Types__sdvr_audio_enc_chan_params_t">sdvr_audio_enc_chan_params_t</A> * audio_enc_params);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to get the parameters of an audio encoder channel.  
</P>
<P>
You must set the parameters before you can get them.  
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> -An encoding channel handle. 
</LI>
<LI>
<EM>audio_enc_params</EM> - A pointer to a variable that will be filled with 
encoder channel parameters when this function returns.  
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>

<a name="sdvr_sdk_html_Routines__Video___Analytics___and___Privacy___Blocking___API"></a>
<H3>4.10.3 &nbsp; Video Analytics and Privacy Blocking API</H3>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_set_regions_map"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_set_regions_map">sdvr_set_regions_map</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>    handle,
                                 <A HREF="#sdvr_sdk_html_Types__sdvr_regions_type_e">sdvr_regions_type_e</A>   region_type,
                                 <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>            * regions_map);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to map out the Regions Of Interest (ROI) within a  
full decimation of the current video standard size frame to be used for different  
alarms detections or privacy blocking. 
</P>
<P>
The map of ROI is made of (width x lines) Macro Blocks (MB) based on 
full resolution of the current video standard, 
where, the size of each MB is 16x16 pixels, the value of 
width is calculated by dividing the width of the current video standard by  
16 and the value of lines is calculated by dividing the height of the  
current video standard by 16. Following table shows the ROI map dimensions 
for mostly used video standards. 
<PRE class="ccode">
 
     Video Standard |  ROI Map width  | ROI Map lines 
     ---------------+-----------------+--------------- 
        NTSC D1     |        45       |       30 
     ---------------+-----------------+--------------- 
        PAL D1      |        45       |       36 
     ---------------+-----------------+--------------- 
        NTSC 4CIF   |        44       |       30 
     ---------------+-----------------+--------------- 
        PAL 4CIF    |        44       |       36 
 
</PRE>
</P>
<P>
There are four (4) layers of ROI for motion detections but only one  
layer for other alarms detection and privacy blocking. Each bit within 
the map of ROI elements corresponds to a ROI layer. Where the right-most 
side bit is layer one, second right-most side bit is layer two, 
and so on. To include an MB for alarm detection or privacy blocking, set 
the corresponding bit of the map of ROI array element to one (1). 
</P>
<P>
D1 PAL ROI map size = (<A HREF="#sdvr_sdk_html_Defines__SDVR_REGION_MAP_D1_WIDTH">SDVR_REGION_MAP_D1_WIDTH</A>*<A HREF="#sdvr_sdk_html_Defines__SDVR_REGION_MAP_LINE_PAL">SDVR_REGION_MAP_LINE_PAL</A>) 
</P>
<P>
D1 NTSC ROI map size = (<A HREF="#sdvr_sdk_html_Defines__SDVR_REGION_MAP_D1_WIDTH">SDVR_REGION_MAP_D1_WIDTH</A>*<A HREF="#sdvr_sdk_html_Defines__SDVR_REGION_MAP_LINE_NTSC">SDVR_REGION_MAP_LINE_NTSC</A>) 
</P>
<P>
4-CIF PAL ROI map size = (<A HREF="#sdvr_sdk_html_Defines__SDVR_REGION_MAP_4CIF_WIDTH">SDVR_REGION_MAP_4CIF_WIDTH</A>*<A HREF="#sdvr_sdk_html_Defines__SDVR_REGION_MAP_LINE_PAL">SDVR_REGION_MAP_LINE_PAL</A>) 
</P>
<P>
4-CIF NTSC ROI map size = (<A HREF="#sdvr_sdk_html_Defines__SDVR_REGION_MAP_4CIF_WIDTH">SDVR_REGION_MAP_4CIF_WIDTH</A>*<A HREF="#sdvr_sdk_html_Defines__SDVR_REGION_MAP_LINE_NTSC">SDVR_REGION_MAP_LINE_NTSC</A>) 
</P>
<P>
Note: For NTSC video standard the last six lines are missing, whereas for 
4-CIF the last column is missing. 
<PRE class="ccode">
P of ROI 
yer:  87654321   87654321   87654321   ...   87654321   87654321       
t map     0          1          2      ...      43        44 
    +----------+----------+----------+-----+----------+----------+ 
-&gt; 0| 00000000 | 00000000 | 00000000 | ... | 00000101 | 00000000 | 
    +----------+----------+----------+-----+----------+----------+ 
-&gt; 1| 00000000 | 00000000 | 00000000 | ... | 00000000 | 00000000 | 
    +----------+----------+----------+-----+----------+----------+ 
-&gt; 2| 00000000 | 00000000 | 00000000 | ... | 00000000 | 00000000 | 
    +----------+----------+----------+-----+----------+----------+ 
         .          .          .       .        .          . 
nes      .          .          .       .        .          . 
         .          .          .       .        .          . 
    +----------+----------+----------+-----+----------+----------+ 
-&gt;34| 00000000 | 00000000 | 00000000 | ... | 00000000 | 00000000 | 
    +----------+----------+----------+-----+----------+----------+ 
-&gt;35| 00000000 | 00000000 | 00000000 | ... | 00000000 | 00000000 | 
    +----------+----------+----------+-----+----------+----------+ 
 
    |&lt;------------------------ width ---------------------------&gt;| 
</PRE>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> -An encoding channel handle. 
</LI>
<LI>
<EM>region_type</EM> - The type of region of interest. 
</LI>
<LI>
<EM>regions_map</EM> - A pointer to an array of (width x lines) 8-bit elements 
that provides a map of regions of interests for the given region 
type. The area of the map is based on Macro Blocks (MB) of size 
16x16 pixels within a 1:1 video decimation frame based on the current 
video standard. Each bit within 
an element of the array corresponds to the layer of regions of 
interest for the region type.  
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
<P>
Example: 
<PRE class="ccode">
  // The following code adds MB[0,43] ROI to the layer 1 and 3 of the 
  // motion detection map 
 
  <A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A> handle; 
  <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> *regions_map; 
  int line, column; 
  int width_size, line_size; 
 
  // Assuming the current video standard is D1 NTSC: 
  width_size = <A HREF="#sdvr_sdk_html_Defines__SDVR_REGION_MAP_D1_WIDTH">SDVR_REGION_MAP_D1_WIDTH</A>; 
  line_size = <A HREF="#sdvr_sdk_html_Defines__SDVR_REGION_MAP_LINE_NTSC">SDVR_REGION_MAP_LINE_NTSC</A>; 
 
  regions_map = (<A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> *)calloc(width_size*line_size, sizeof(<A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>)); 
 
  column = 43; 
  row = 0; 
  regions_map[row * width_size + column] = 0x5; 
  <A HREF="#sdvr_sdk_html_Routines__sdvr_set_regions_map">sdvr_set_regions_map</A>(handle, <A HREF="#sdvr_sdk_html_Types__SDVR_REGION_MOTION">SDVR_REGION_MOTION</A>, regions_map); 
</PRE>
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_set_regions"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_set_regions">sdvr_set_regions</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>    handle,
                             <A HREF="#sdvr_sdk_html_Types__sdvr_regions_type_e">sdvr_regions_type_e</A>   region_type,
                             <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>              overlay_num,
                             <A HREF="#sdvr_sdk_html_Types__sdvr_mb_region_t">sdvr_mb_region_t</A>    * regions_list,
                             <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>              num_of_regions);
</PRE>
<DIV CLASS="descr">
<P>
This is a convenient function for specifying the Regions Of Interest  
(ROI) based on Macro Blocks (MB) rectangles within a full decimation  
of the current video standard size frame to be  
used for different alarms detection or privacy blocking. 
</P>
<P>
By calling this function with parameter regions_list set to NULL or 
specifing a value of zero for num_of_regions, the 
regions within the given overlay will be reset. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> -An encoding channel handle. 
</LI>
<LI>
<EM>region_type</EM> - The type of region of interest. 
</LI>
<LI>
<EM>overlay_num</EM> - The overlay number to add the regions. 
For region_type of <A HREF="#sdvr_sdk_html_Types__SDVR_REGION_MOTION">SDVR_REGION_MOTION</A> overlay_num is in the 
range 1-4. For all other region types, it is ignored. 
</LI>
<LI>
<EM>regions_list</EM> - A pointer to an array of macro block 
rectangles. NULL means to reset the regions for the  
given overlay_num. 
</LI>
<LI>
<EM>num_of_regions</EM> - The number of elements in regions_list array. 
A value of zero resets the regions for the given overlay_num. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
By default the entire first overlay is enabled. In case you are interested to 
set an overlay other than the first overlay, call this function for  
first overlay with regions_list parameter set to NULL prior setting the new 
overlay. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_motion_value_analyzer"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_motion_value_analyzer">sdvr_motion_value_analyzer</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>         * motion_values,
                                       <A HREF="#sdvr_sdk_html_Types__sdvr_video_std_e">sdvr_video_std_e</A>   motion_values_vstd,
                                       <A HREF="#sdvr_sdk_html_Types__sdvr_mb_region_t">sdvr_mb_region_t</A> * regions_list,
                                       <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>           num_of_regions,
                                       <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>          threshold);
</PRE>
<DIV CLASS="descr">
<P>
This function allows you to determine if an alarm occurred on any of 
the given Macro Block (MB) rectangular regions within a given motion  
values frame buffer. 
</P>
<P>
To calculate an alarm condition, the average motion values within each 
region of interest in the given regions list is used against the  
given threshold. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>motion_values</EM> - The motion values frame received from the DVR 
board. This the payload in the frame buffer returned by  
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_av_buffer">sdvr_get_av_buffer</A>()</NOBR> with the 
frame type of <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_MOTION_VALUES">SDVR_FRAME_MOTION_VALUES</A>. 
</LI>
<LI>
<EM>motion_values_vstd</EM> - The video standard for which the  
motion_values buffer was based. 
</LI>
<LI>
<EM>regions_list</EM> - A pointer to an array of macro block 
rectangles. Upon return, the alarm_flag field of each entry 
is set according to the specified threshold. 
</LI>
<LI>
<EM>num_of_regions</EM> - The number of elements in regions_list array. 
</LI>
<LI>
<EM>threshold</EM> - The value to be used to determine the 
alarm condition for a region in the regions_list. The motion_flag 
for each region within the regions_list is set if the motion 
value within the given region exceeds this threshold. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
You may choose to perform different motion value analysis  by directly 
looking at the motion value of each field in the motion_values buffer. 
Each element of motion_values buffer contains the motion value for 
the corresponding MB, where the first index is the first 
16x16 MB within the FULL size video frame. See <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_regions_map">sdvr_set_regions_map</A>()</NOBR> for 
more information regarding the buffer format. The exception is that each 
element in motion_values buffer contains the motion value from 0 - 255 instead 
of the bit indicating to motion detection. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_set_motion_value_frequency"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_set_motion_value_frequency">sdvr_set_motion_value_frequency</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>   handle,
                                            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>             every_n_frames);
</PRE>
<DIV CLASS="descr">
<P>
This function sets the frequency of sending the motion value frames from the 
DVR board to the DVR Application per encoder channel. Once <EM>every_n_frames</EM> 
is set to a non-zero value, motion value frames are sent at the requested 
intervals. For example if <EM>every_n_frames</EM> is set to 5, then a motion value 
frame will be sent every 5 video frames. However, note that as long as motion 
detection is enabled, a motion value frame will be sent every time that the 
motion threshold is exceeded. This is <A HREF="#sdvr_sdk_html_Defines__true">true</A> even if <EM>every_n_frames</EM> is set to 
zero. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> -An encoding channel handle. 
</LI>
<LI>
<EM>every_n_frames</EM> - The frequency of alarm value frame to send. Setting this 
field to one (1) means send with every frame, two (2) means send every other 
frame, and so on.  Default is zero (0). The valid range is 0-255. If this 
is set to zero (0) while motion detection is enabled, then a motion value 
frame will still be sent every time that the motion threshold is exceeded. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
Call this function with frequency of zero (0) after disabling the 
motion detection if you are not interested to receive motion value frames 
while the motion detection is disabled. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_alarm_motion_value"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_alarm_motion_value">sdvr_get_alarm_motion_value</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>   data,
                                        <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>    overlay_num,
                                        <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>  * motion_value);
</PRE>
<DIV CLASS="descr">
<P>
This function returns the motion value for the specified motion region 
overlay number.  
</P>
<P>
If an alarm callback function is registered by the DVR Application, 
Once motion alarm is detected by the DVR firmware, the alarm callback  
is called with a <EM>data</EM> parameter. Call this function to get each 
motion value for each region overlay. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>data</EM> - The data parameter returned by alarm callback function. 
</LI>
<LI>
<EM>overlay_num</EM> - The motion region overlay number from which to get its 
motion value. The valid range in the field is 1-4. 
</LI>
<LI>
<EM>motion_value</EM> - A pointer to hold the motion value for the requested 
motion region overlay. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_add_region"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_add_region">sdvr_add_region</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>    handle,
                            <A HREF="#sdvr_sdk_html_Types__sdvr_regions_type_e">sdvr_regions_type_e</A>   region_type,
                            <A HREF="#sdvr_sdk_html_Types__sdvr_region_t">sdvr_region_t</A>       * region);
</PRE>
<DIV CLASS="descr">
<P>
Regions can be added to any encoding or decoding video channel for motion or  
blind detection as well as privacy.  
</P>
<P>
This function adds a new region type based on pixel coordinates to a video channel. 
Number of regions define using this function is limited to 4.  
</P>
<P>
After regions are created, you must enable them by calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_motion_detection">sdvr_enable_motion_detection</A>()</NOBR>, 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_blind_detection">sdvr_enable_blind_detection</A>()</NOBR>, pr <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_privacy_regions">sdvr_enable_privacy_regions</A>()</NOBR> as appropriate.  
</P>
<P>
<STRONG>NOTE: This function is kept for backward compatibility.</STRONG> 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - An encoding or decoding video channel handle. 
</LI>
<LI>
<EM>region_type</EM> - The type of region to be added. 
</LI>
<LI>
<EM>region</EM> - A structure to specify the coordinates of the region as input. 
If the region was added successfully, the region_id field of the structure holds 
the region ID as output. This ID needs to be set to remove or change 
the coordinates of the region. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
<P>
Remarks: 
</P>
<P>
You should call  <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_regions">sdvr_set_regions</A>()</NOBR> or <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_regions_map">sdvr_set_regions_map</A>()</NOBR> to create  
unlimited number of regions based on Macro Blocks. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_change_region"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_change_region">sdvr_change_region</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>    handle,
                               <A HREF="#sdvr_sdk_html_Types__sdvr_regions_type_e">sdvr_regions_type_e</A>   region_type,
                               <A HREF="#sdvr_sdk_html_Types__sdvr_region_t">sdvr_region_t</A>       * region);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to change the coordinates of a region that is  
defined by calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_add_region">sdvr_add_region</A>()</NOBR>.  
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - An encoding/decoding video channel handle. 
</LI>
<LI>
<EM>region_type</EM> - The type of region. 
</LI>
<LI>
<EM>region</EM> - A structure that specifies the new coordinates of the region. 
The region_id field of the structure holds the region to be changed. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_remove_region"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_remove_region">sdvr_remove_region</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>    handle,
                               <A HREF="#sdvr_sdk_html_Types__sdvr_regions_type_e">sdvr_regions_type_e</A>   region_type,
                               <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>              region_id);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to remove an existing region that was added by  
calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_add_region">sdvr_add_region</A>()</NOBR>. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - An encoding or decoding video channel handle. 
</LI>
<LI>
<EM>region_type</EM> - The type of region. 
</LI>
<LI>
<EM>region_id</EM> - The region ID to be removed from the given region type. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_motion_detection"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_motion_detection">sdvr_get_motion_detection</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>        handle,
                                      <A HREF="#sdvr_sdk_html_Types__sdvr_motion_detection_t">sdvr_motion_detection_t</A> * motion_detection);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to get the motion threshold, motion detection state, 
and regions for a particular channel. A motion region is where motion is  
detected by the encoder. If no motion regions are defined, the entire 
video picture is used for motion detection. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> -An encoding or decoding video channel handle. 
</LI>
<LI>
<EM>motion_detection</EM> - A pointer to a structure describing the motion  
threshold, regions, and enable state. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
Information regarding regions returned in this function only  
applies to those that were added using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_add_region">sdvr_add_region</A>()</NOBR>.  
This function is kept for backward compatibility. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_blind_detection"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_blind_detection">sdvr_get_blind_detection</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>       handle,
                                     <A HREF="#sdvr_sdk_html_Types__sdvr_blind_detection_t">sdvr_blind_detection_t</A> * blind_detection);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to get the blind threshold and regions for a  
particular channel. A blind detection region is where constant video image is  
detected by the encoder in the specified region. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - An encoding or decoding channel handle. 
</LI>
<LI>
<EM>blind_detection</EM> - A pointer to a structure describing the  
blind threshold, regions, and enable state. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
Information regarding regions returned in this function only  
applies to those that were added using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_add_region">sdvr_add_region</A>()</NOBR>.  
This function is kept for backward compatibility. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_privacy_regions"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_privacy_regions">sdvr_get_privacy_regions</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>      handle,
                                     <A HREF="#sdvr_sdk_html_Types__sdvr_privacy_region_t">sdvr_privacy_region_t</A> * privacy_regions);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to get the privacy regions for a particular channel. 
Privacy regions are blanked in live and encoded video. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - Handle of an encoding or decoding channel. 
</LI>
<LI>
<EM>privacy_region</EM> - A pointer to a data structure containing the <STRONG>region</STRONG>(s) 
to blanked as well as their enable <STRONG>state</STRONG>(s). 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
Information regarding regions returned in this function only  
applies to those that were added using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_add_region">sdvr_add_region</A>()</NOBR>.  
This function is kept for backward compatibility. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_night_detection"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_night_detection">sdvr_get_night_detection</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>       handle,
                                     <A HREF="#sdvr_sdk_html_Types__sdvr_night_detection_t">sdvr_night_detection_t</A> * night_detection);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to get the threshold and enable state of  
night detection. 
</P>
<P>
Night detection refers to the entire picture, and  
not to any particular region of the picture.  
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - An encoding or decoding channel handle. 
</LI>
<LI>
<EM>night_detection</EM> - Pointer to a structure containing the threshold and 
enable state for night detection. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_enable_privacy_regions"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_enable_privacy_regions">sdvr_enable_privacy_regions</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>   handle,
                                        <A HREF="#sdvr_sdk_html_Types__sx_bool">sx_bool</A>              enable);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to enable or disable all the privacy regions that are 
defined by calling the function <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_add_region">sdvr_add_region</A>()</NOBR>. After 
privacy region is enabled, all the regions are blacked out in both the live/decoded 
and encoded video. If no privacy region is defined, the entire video picture 
will be blacked out. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - An encoding or decoding channel handle. 
</LI>
<LI>
<EM>enable</EM> - A non-zero value enables privacy regions, zero  
disables privacy regions.  
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_enable_motion_detection"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_enable_motion_detection">sdvr_enable_motion_detection</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>   handle,
                                         <A HREF="#sdvr_sdk_html_Types__sx_bool">sx_bool</A>              enable,
                                         <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>             threshold);
</PRE>
<DIV CLASS="descr">
<P>
After regions are specified for motion detection by calling the function  
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_add_region">sdvr_add_region</A>()</NOBR> or <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_regions_map">sdvr_set_regions_map</A>()</NOBR>, you must enable motion detection.   
</P>
<P>
This function is used to enable and disable motion detection on all the  
specified regions. The motion detection uses the entire picture if no motion 
region is specified. As you enable the motion detection, you must specify  
a threshold above which motion should be detected. 
</P>
<P>
After motion detection is enabled, the video alarm callback function is  
called every time motion is detected. Addtionally, video frame callback 
function is called with <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_MOTION_VALUES">SDVR_FRAME_MOTION_VALUES</A> frame type that holds the  
macro block motion values for the video frame with the motion. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - An encoding or decoding channel handle. 
</LI>
<LI>
<EM>enable</EM> - A non-zero value enables motion detection,  
zero disables motion detection. 
</LI>
<LI>
<EM>threshold</EM> - The threshold value for motion detection. This field is 
ignored if you are disabling motion detection. 
The valid range is 0 - 99.  
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
This function only sets the motion threshold for the first motion overlay  
region. To set the threshold for other motion overlay call  
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_motion_detection_ex">sdvr_enable_motion_detection_ex</A>()</NOBR>. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_enable_motion_detection_ex"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_enable_motion_detection_ex">sdvr_enable_motion_detection_ex</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>   handle,
                                            <A HREF="#sdvr_sdk_html_Types__sx_bool">sx_bool</A>              enable,
                                            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>             threshold1,
                                            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>             threshold2,
                                            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>             threshold3,
                                            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>             threshold4);
</PRE>
<DIV CLASS="descr">
<P>
After regions are specified for motion detection by calling the function  
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_regions_map">sdvr_set_regions_map</A>()</NOBR>, you must enable motion detection.   
This is an extended version of <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_motion_detection">sdvr_enable_motion_detection</A>()</NOBR> that allows  
you to set the motion detection threshold for multiple motion 
overlay regions.  
</P>
<P>
This function is used to enable and disable motion detection on all the  
specified regions. The motion detection uses the entire picture if no motion 
region is specified. As you enable the motion detection, you must specify  
a threshold above which motion should be detected for each motion region overlay. 
</P>
<P>
After motion detection is enabled, the video alarm callback function is  
called every time motion is detected. Addtionally, video frame callback 
function is called with <A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_MOTION_VALUES">SDVR_FRAME_MOTION_VALUES</A> frame type that holds the  
macro block motion values for the video frame with the motion. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - An encoding or decoding channel handle. 
</LI>
<LI>
<EM>enable</EM> - A non-zero value enables motion detection,  
zero disables motion detection. 
</LI>
<LI>
<EM>threshold1</EM> - The threshold value for the first motion detection overlay 
region.  
The valid range is 0 - 99.  
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
Threshold fields are ignored if you are disabling motion detection. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_enable_blind_detection"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_enable_blind_detection">sdvr_enable_blind_detection</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>   handle,
                                        <A HREF="#sdvr_sdk_html_Types__sx_bool">sx_bool</A>              enable,
                                        <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>             threshold);
</PRE>
<DIV CLASS="descr">
<P>
After regions are specified for blind detection by calling the function  
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_add_region">sdvr_add_region</A>()</NOBR>, you must enable blind detection.   
</P>
<P>
This function is used to enable and disable blind detection on all the  
specified regions. The blind detection uses the entire picture if no 
region is specified. As you enable the blind detection, you must specify  
a threshold above which blind detection is triggered. 
</P>
<P>
After blind detection is enabled, the video alarm callback function is  
called every time video blind is detected. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - Handle of an encoding/decoding channel. 
</LI>
<LI>
<EM>enable</EM> - A non-zero value enables blind detection,  
zero disables blind detection. 
</LI>
<LI>
<EM>threshold</EM> - The threshold value for blind detection. This field is 
ignored if you are disabling the blind detection. 
The valid range is 0 - 99.  
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_enable_night_detection"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_enable_night_detection">sdvr_enable_night_detection</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>   handle,
                                        <A HREF="#sdvr_sdk_html_Types__sx_bool">sx_bool</A>              enable,
                                        <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>             threshold);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to enable and disable night detection. 
</P>
<P>
Night detection refers to the entire picture, and  
not to any particular region of the picture. As you enable the night  
detection, you must specify  
a threshold below which night should be detected. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - An encoding or decoding channel handle. 
</LI>
<LI>
<EM>enable</EM> - A non-zero value enables night detection, 
zero disables night detection. 
</LI>
<LI>
<EM>threshold</EM> - The threshold value for night detection. This field is 
ignored if you are disabling night detection. 
The valid range is 0 - 255.  
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>

<a name="sdvr_sdk_html_Routines__Encoding___and___Raw___Audio___Video___API"></a>
<H3>4.10.4 &nbsp; Encoding and Raw Audio/Video API</H3>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_enable_encoder"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_enable_encoder">sdvr_enable_encoder</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>    handle,
                                <A HREF="#sdvr_sdk_html_Types__sdvr_sub_encoders_e">sdvr_sub_encoders_e</A>   sub_chan_enc,
                                <A HREF="#sdvr_sdk_html_Types__sx_bool">sx_bool</A>               enable);
</PRE>
<DIV CLASS="descr">
<P>
This function enables the Nth encoder on a particular channel. After an encoder is 
enabled for a particular channel, the associated video encoding on  
alarms will be activated. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - An encoding channel handle. 
</LI>
<LI>
<EM>sub_chan_enc</EM> - The encoder subchannel to enable or disable. 
</LI>
<LI>
<EM>enable</EM> - If <A HREF="#sdvr_sdk_html_Defines__true">true</A>, the encoding is enabled; disabled otherwise. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise see the error code list. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
After the encoder is enabled, both audio (if the channel has one) and video 
frames are sent. 
</LI>
<LI>
<STRONG>NOTE: There are no audio frames for secondary encoders.</STRONG> 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_av_buffer"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_av_buffer">sdvr_get_av_buffer</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>    handle,
                               <A HREF="#sdvr_sdk_html_Types__sdvr_frame_type_e">sdvr_frame_type_e</A>     frame_type,
                               <A HREF="#sdvr_sdk_html_Types__sdvr_av_buffer_t">sdvr_av_buffer_t</A>   ** frame_buffer);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to get one of: 
</P>
<UL>
<LI>
An encoded video frame from the encoder 
</LI>
<LI>
An encoded audio frame from the encoder 
</LI>
<LI>
A raw audio PCM frame 
</LI>
<LI>
A motion values frame. 
</LI>
</UL>
<P>
This function is called by the DVR Application to get a frame of the  
appropriate type from the SDK. Typically, the DVR Application registers 
a callback so that it can be informed when a frame is available. A callback, 
however, is not required. This function can be called at any time 
by the DVR Application to request a particular frame type. If the frame 
is not available, an error code indicates that no frame 
is available and the buffer pointer is NULL.  
</P>
<P>
This is the typical flow of operation in the encoding path: 
</P>
<UL>
<LI>
DVR Application registers a AV frame callback using  
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_av_frame_callback">sdvr_set_av_frame_callback</A>()</NOBR>. 
</LI>
<LI>
When this callback function is called, the DVR Application notes 
the channels and the frame types available in a data structure. 
</LI>
<LI>
In a separate thread that saves encoded streams or motion values to  
disk, the DVR application uses the information from the previous  
step to retrieve the encoded AV frames or motion values and saves  
them to disk. 
</LI>
<LI>
In a separate thread that displays live video or audio, the DVR Application 
uses the information saved earlier to retrieve the raw audio and  
video frames, and renders them on the display or plays them.  
</LI>
</UL>
<P>
When this function is called, an <A HREF="#sdvr_sdk_html_Types__sdvr_av_buffer_t">sdvr_av_buffer_t</A> * pointer to a frame is 
returned.   
The DVR Application should treat this buffer as read-only, 
and not modify any field of the structure. After the buffer is  
used, it must be released to the SDK using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_release_av_buffer">sdvr_release_av_buffer</A>()</NOBR>. 
This release should happen as soon as possible because there are limited 
buffers in the SDK and released buffers are used to hold incoming data.  
If the DVR Application holds a buffer for too long, frame loss could result. 
</P>
<P>
This function can be called repeatedly to retrieve frames for  
different channels. It can be called repeatedly for the same channel and 
it will return as many frames as are available before returning  
an error code indicating no more frames are available. 
</P>
<P>
<STRONG>What to do with the buffer header information?</STRONG> 
The <A HREF="#sdvr_sdk_html_Types__sdvr_av_buffer_t">sdvr_av_buffer_t</A> structure contains a header in addition to the  
frame buffer (payload). This header contains information about the  
size of the frame buffer, the type of the frame, whether motion 
was detected in this frame, and so on. This information may be useful  
later to search through the stored video file to locate  
events quickly, e.g., frames where motion happened. We highly 
recommend that you store the header and the frame buffer. We also 
recommended that you save the header in a separate file (perhaps 
with other information) from the frame buffer file, so that you  
can search the header file to locate 
a particular section of encoded video and then jump to that location 
in the frame buffer file. The reserved field in the  
buffer data structure need not be saved. Also, the reserved field should  
not be changed or else <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_release_av_buffer">sdvr_release_av_buffer</A>()</NOBR> will have trouble recycling 
the buffer. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - An encoding channel handle. 
</LI>
<LI>
<EM>frame_type</EM> - The type of frame you want. 
</LI>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_VIDEO_ENCODED_PRIMARY">SDVR_FRAME_VIDEO_ENCODED_PRIMARY</A> - For an encoded video 
frame associated with the primary encoder. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_VIDEO_ENCODED_SECONDARY">SDVR_FRAME_VIDEO_ENCODED_SECONDARY</A> - For an encoded video 
frame associated with the secondary encoder. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_AUDIO_ENCODED">SDVR_FRAME_AUDIO_ENCODED</A> - For an encoded audio frame 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_RAW_AUDIO">SDVR_FRAME_RAW_AUDIO</A> - For a raw audio PCM frame 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_MOTION_VALUES">SDVR_FRAME_MOTION_VALUES</A> - For motion values frame. 
</LI>
</UL>
<LI>
<EM>frame_buffer</EM> - The pointer to a pointer to an A/V buffer 
structure.  
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_yuv_buffer"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_yuv_buffer">sdvr_get_yuv_buffer</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>    handle,
                                <A HREF="#sdvr_sdk_html_Types__sdvr_yuv_buffer_t">sdvr_yuv_buffer_t</A>  ** frame_buffer);
</PRE>
<DIV CLASS="descr">
<P>
This function is called by the DVR Application to get a raw video frame    
from the SDK. Typically, the DVR Application registers a callback so 
that it can be informed when a frame is available. A callback, however, 
is not required. This function can be called at any time 
by the DVR Application to request a particular frame type. If the frame 
is not available, an error code indicates that no frame 
is available and that the buffer pointer is NULL.  
</P>
<P>
This is the typical flow of operation in an encoding path: 
</P>
<UL>
<LI>
The DVR Application registers an AV frame callback using  
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_av_frame_callback">sdvr_set_av_frame_callback</A>()</NOBR>. 
</LI>
<LI>
When this callback function is called, the DVR Application notes 
the channels and the frame types available in a data structure. 
</LI>
<LI>
In a separate thread that displays live video, the DVR Application 
uses the information saved earlier to retrieve the raw  
video frames and renders them on the display or plays them.  
</LI>
</UL>
<P>
When this function is called, an <A HREF="#sdvr_sdk_html_Types__sdvr_yuv_buffer_t">sdvr_yuv_buffer_t</A> pointer to a raw frame is 
returned.   
The DVR Application should treat this buffer as read-only  
and not modify any field of the structure. After the buffer is  
used, it must be released to the SDK using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_release_yuv_buffer">sdvr_release_yuv_buffer</A>()</NOBR>. 
This release should happen as soon as possible because there are limited 
buffers in the SDK, and released buffers are used to hold incoming data.  
If the DVR Application holds a buffer for too long, frame loss could result. 
</P>
<P>
This function can be called repeatedly to retrieve frames for  
different channels. It can be called repeatedly for the same channel and 
it will return as many frames that are available before returning  
an error code indicating no more frames are available. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - An encoding or decoding channel handle. 
</LI>
<LI>
<EM>frame_buffer</EM> - The pointer to a pointer to a YUV buffer structure.  
NULL if no YUV buffer is available. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_release_av_buffer"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_release_av_buffer">sdvr_release_av_buffer</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_av_buffer_t">sdvr_av_buffer_t</A> *frame_buffer);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to release an A/V frame to the SDK.  
Buffers should be released as quickly as possible to prevent  
frame loss.  
</P>
<P>
Decoder buffers obtained from <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_alloc_av_buffer">sdvr_alloc_av_buffer</A>()</NOBR> will be released when 
you call <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_send_av_frame">sdvr_send_av_frame</A>()</NOBR>. If you don't need to send the 
buffer after it is allocated, you must release the buffer by calling 
this function. 
</P>
<P>
<STRONG>NOTE: To release a raw video YUV frame, you must call sdvr_release_yuv_buffer.</STRONG> 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>frame_buffer</EM> - The pointer to a buffer obtained using 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_av_buffer">sdvr_get_av_buffer</A>()</NOBR> or <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_alloc_av_buffer">sdvr_alloc_av_buffer</A>()</NOBR>. 
<STRONG>You should not call this function if frame_buffer was 
already used in <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_send_av_frame">sdvr_send_av_frame</A>()</NOBR>.</STRONG> 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_release_yuv_buffer"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_release_yuv_buffer">sdvr_release_yuv_buffer</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_yuv_buffer_t">sdvr_yuv_buffer_t</A> *frame_buffer);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to release a YUV frame buffer to the SDK.  
Buffers should be released as quickly as possible to prevent  
frame loss.  
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>frame_buffer</EM> - The pointer to a buffer obtained using 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_yuv_buffer">sdvr_get_yuv_buffer</A>()</NOBR>. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_enable_auth_key"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_enable_auth_key">sdvr_enable_auth_key</A> (<A HREF="#sdvr_sdk_html_Types__sx_bool">sx_bool</A> enable);
</PRE>
<DIV CLASS="descr">
<P>
This function sets whether or not there must be an H.264 authentication 
key code set on the DVR board at the time of calling to  
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_board_connect">sdvr_board_connect</A>()</NOBR>. This function must be called after <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_sdk_init">sdvr_sdk_init</A>()</NOBR> 
and before connecting to any DVR boards. 
</P>
<P>
Parameters:  
</P>
<UL>
<LI>
<EM>enable</EM> - The flag to enforce the authentication key presence. 
</LI>
</UL>
<P>
Returns:  
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success.  
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NO_DVR_BOARD">SDVR_ERR_NO_DVR_BOARD</A> - Error code if <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_sdk_init">sdvr_sdk_init</A>()</NOBR> was not called 
or no DVR board was found on the system. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_BOARD_CONNECTED">SDVR_ERR_BOARD_CONNECTED</A> - Error code if at least one DVR board is  
connected at the time of calling this function. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
Once authentication key is enabled, there must be an authentication key 
burned in the eeprom of the DVR board 
before calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_board_connect">sdvr_board_connect</A>()</NOBR>. If the key does not exist 
on the board, board connection will fail. 
</LI>
</UL>
</DIV>

</DIV>

<a name="sdvr_sdk_html_Routines__Frame___Buffer___Field___Access___API"></a>
<H3>4.10.5 &nbsp; Frame Buffer Field Access API</H3>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_buffer_channel"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_buffer_channel">sdvr_get_buffer_channel</A> (void *frame_buffer);
</PRE>
<DIV CLASS="descr">
<P>
This function returns the channel handle corresponding to the given 
frame buffer. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>frame_buffer</EM> - The encoded or raw A/V frame or the motion values 
buffer. 
This buffer was obtained by the call to either <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_av_buffer">sdvr_get_av_buffer</A>()</NOBR> or 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_yuv_buffer">sdvr_get_yuv_buffer</A>()</NOBR>.  
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
The channel handle corresponding to the given frame buffer. A value of 
<A HREF="#sdvr_sdk_html_Defines__INVALID_CHAN_HANDLE">INVALID_CHAN_HANDLE</A> indicates that the given buffer is invalid. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_buffer_timestamp"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_buffer_timestamp">sdvr_get_buffer_timestamp</A> (void      * frame_buffer,
                                      <A HREF="#sdvr_sdk_html_Types__sx_uint64">sx_uint64</A> * timestamp64);
</PRE>
<DIV CLASS="descr">
<P>
This function returns the 64-bit hardware-generated timestamp  
corresponding to the given frame buffer. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>frame_buffer</EM> - The encoded or raw A/V frame or the motion values 
buffer. 
This buffer was obtained by the call to either <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_av_buffer">sdvr_get_av_buffer</A>()</NOBR> or 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_yuv_buffer">sdvr_get_yuv_buffer</A>()</NOBR>.  
</LI>
<LI>
<EM>timestamp64</EM> - A pointer to a 64-bit variable that holds the  
timestamp on successful return. This is hardware-generated  
timestamp of when the frame was captured. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_buffer_frame_type"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_buffer_frame_type">sdvr_get_buffer_frame_type</A> (void     * frame_buffer,
                                       <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> * frame_type);
</PRE>
<DIV CLASS="descr">
<P>
This function returns frame type corresponding to the given 
frame buffer. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>frame_buffer</EM> - The encoded or raw A/V frame or the motion values 
buffer. 
This buffer was obtained by the call to either <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_av_buffer">sdvr_get_av_buffer</A>()</NOBR> or 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_yuv_buffer">sdvr_get_yuv_buffer</A>()</NOBR>.  
</LI>
<LI>
<EM>frame_type</EM> - A pointer to a variable that holds the  
frame type on successful return. (See <A HREF="#sdvr_sdk_html_Types____sdvr_frame_type_e">__sdvr_frame_type_e</A> for all the 
possible frame types.) 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_buffer_yuv_format"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_buffer_yuv_format">sdvr_get_buffer_yuv_format</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_yuv_buffer_t">sdvr_yuv_buffer_t</A> * frame_buffer,
                                       <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>          * format);
</PRE>
<DIV CLASS="descr">
<P>
This function returns YUV format type corresponding to the given 
raw video frame buffer. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>frame_buffer</EM> - The raw video frame. 
This buffer was obtained by the call to  
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_yuv_buffer">sdvr_get_yuv_buffer</A>()</NOBR>.  
</LI>
<LI>
<EM>format</EM> - A pointer to a variable that holds the  
YUV format type on successful return. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_buffer_sub_encoder"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_buffer_sub_encoder">sdvr_get_buffer_sub_encoder</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_av_buffer_t">sdvr_av_buffer_t</A>    * frame_buffer,
                                        <A HREF="#sdvr_sdk_html_Types__sdvr_sub_encoders_e">sdvr_sub_encoders_e</A> * sub_enc);
</PRE>
<DIV CLASS="descr">
<P>
This function returns whether the given buffer is associated to  
the primary or secondary encoder. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>frame_buffer</EM> - The encoded video frame. 
This buffer was obtained by the call to <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_av_buffer">sdvr_get_av_buffer</A>()</NOBR>.  
</LI>
<LI>
<EM>sub_enc</EM> - A pointer to a variable that holds the  
sub-encoder ID on successful return. This field is only valid for encoded frames.  
It indicates whether the video frame is from the primary (<A HREF="#sdvr_sdk_html_Types__SDVR_ENC_PRIMARY">SDVR_ENC_PRIMARY</A>) or 
the secondary (<A HREF="#sdvr_sdk_html_Types__SDVR_ENC_SECONDARY">SDVR_ENC_SECONDARY</A>) encoder on this encoded channel. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
The value of sub_enc is nondeterministic if the provided frame_buffer  
does not correspond to an encoded video frame. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_buffer_alarm_value"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_buffer_alarm_value">sdvr_get_buffer_alarm_value</A> (void               * frame_buffer,
                                        <A HREF="#sdvr_sdk_html_Types__sdvr_video_alarm_e">sdvr_video_alarm_e</A>   alarm_type,
                                        <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>             overlay_num,
                                        <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>           * alarm_value);
</PRE>
<DIV CLASS="descr">
<P>
This function returns the alarm value for the given alarm type and overlay 
assoicated with the given video frame buffer. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>frame_buffer</EM> - The encoded or raw video frame. 
This buffer was obtained by the call to either <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_av_buffer">sdvr_get_av_buffer</A>()</NOBR> or 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_yuv_buffer">sdvr_get_yuv_buffer</A>()</NOBR>.  
</LI>
<LI>
<EM>alarm_type</EM> - The type of the alarm. <A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_ALARM_MOTION">SDVR_VIDEO_ALARM_MOTION</A>, 
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_ALARM_BLIND">SDVR_VIDEO_ALARM_BLIND</A>,  and <A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_ALARM_NIGHT">SDVR_VIDEO_ALARM_NIGHT</A> are the 
only supported alarm types. 
</LI>
<LI>
<EM>overlay_num</EM> - The overlay alarm region. Currently, this field 
is only valid for alarm_type of <A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_ALARM_MOTION">SDVR_VIDEO_ALARM_MOTION</A>. The valid 
range is 1-4. 
</LI>
<LI>
<EM>alarm_value</EM> - A pointer to a variable to hold the alarm value 
assoicated to the given alarm_type and overlay_num. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
The value of alarm value is nondeterministic if the provided frame_buffer  
does not correspond to a video frame. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_av_buf_video_dimensions"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_av_buf_video_dimensions">sdvr_av_buf_video_dimensions</A> (void      * frame_buffer,
                                         <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> * width,
                                         <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A> * lines);
</PRE>
<DIV CLASS="descr">
<P>
This function returns the video frame width and number of lines for the given  
video frame buffer. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>frame_buffer</EM> - The encoded or raw video frame. 
This buffer was obtained by the call to either <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_av_buffer">sdvr_get_av_buffer</A>()</NOBR> or 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_yuv_buffer">sdvr_get_yuv_buffer</A>()</NOBR>.  
</LI>
<LI>
<EM>width</EM> - A pointer to a variable to hold the width of the  
video frame. This field is valid only for raw and encoded video frames. 
</LI>
<LI>
<EM>lines</EM> - A pointer to a variable to hold the number of lines of the  
video frame. This field is valid only for raw and encoded video frames. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
The value of width and lines are nondeterministic if the provided frame_buffer  
does not correspond to a video frame. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_av_buf_sequence"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_av_buf_sequence">sdvr_av_buf_sequence</A> (void      * frame_buffer,
                                 <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> * seq_number,
                                 <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> * frame_number,
                                 <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> * frame_drop_count);
</PRE>
<DIV CLASS="descr">
<P>
Call this function to get the frame drop count, sequence number, and 
frame number associated to the given audio video frame buffer. Once the 
data port is enabled, all of these parameters are reset to zero. <EM>Frame 
number</EM> is incremented by one for each frame that is recieved from the hardware 
whereas the <EM>sequence number</EM> is the Nth frame that is sent out from the firmware 
to the host DVR Application. In streaming full frame rate, these two numbers 
are the same. If streaming less than full frame rate, there will be  
gaps in <EM>frame number</EM> but <EM>sequence number</EM> should only increment by 
one. Any gap in <EM>sequene number</EM> means a frame was lost between the firmware and 
the host DVR Application. In a full frame rate, any gap in <EM>frame number</EM> means 
the frame was lost at the data port. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>frame_buffer</EM> - The encoded or raw A/V frame. 
This buffer was obtained by the call to either <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_av_buffer">sdvr_get_av_buffer</A>()</NOBR> or 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_yuv_buffer">sdvr_get_yuv_buffer</A>()</NOBR>.  
</LI>
<LI>
<EM>seq_number</EM> - A pointer to a variable to hold frame sequence number.  
This field is valid only 
for raw and encoded video frames. Every channel and 
stream combination will have independent sequence numbering. The raw 
and encoded video streams from the same channel will have independent 
sequence numbering. 
</LI>
<LI>
<EM>frame_number</EM> - A pointer to a variable to hold  number of frames  
seen on this channel so far. 
This field is valid only for raw and encoded video frames. The 
frame number and sequence number will be identical when the  
stream is being run at full frame rate. 
</LI>
<LI>
<EM>frame_drop_count</EM> - A pointer to a variable to hold number of frames  
dropped detected by the firmware on the current stream. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_av_buf_payload"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_av_buf_payload">sdvr_av_buf_payload</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_av_buffer_t">sdvr_av_buffer_t</A> *  frame_buffer,
                                <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>         ** payload,
                                <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>        *  payload_size);
</PRE>
<DIV CLASS="descr">
<P>
Call this function to get the encoded A/V frame, raw or encoded audio frame, or the  
motion values buffer that is assoiced to the given frame buffer. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>frame_buffer</EM> - The encoded A/V, raw audio, or motion values buffer. This buffer was 
obtained by the call to <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_av_buffer">sdvr_get_av_buffer</A>()</NOBR>. 
</LI>
<LI>
<EM>payload</EM> - A pointer to a pointer to points to the beginning of data 
for the given frame. 
</LI>
<LI>
<EM>payload_size</EM> - A pointer to a variable to hold size of payload. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list.   
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_av_buf_yuv_payload"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_av_buf_yuv_payload">sdvr_av_buf_yuv_payload</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_yuv_buffer_t">sdvr_yuv_buffer_t</A> *  yuv_buffer,
                                    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>          ** y_data,
                                    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>          ** u_data,
                                    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>          ** v_data,
                                    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>         *  y_data_size,
                                    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>         *  u_data_size,
                                    <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>         *  v_data_size);
</PRE>
<DIV CLASS="descr">
<P>
Call this function to get the raw video buffers for the given frame buffer. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>yuv_buffer</EM> - The raw video frame. This buffer was obtained by the 
call to <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_yuv_buffer">sdvr_get_yuv_buffer</A>()</NOBR>. 
</LI>
<LI>
<EM>y_data</EM> - Pointer to a buffer containing the Y data of a raw frame. 
</LI>
<LI>
<EM>u_data</EM> - Pointer to a buffer containing the U data of a raw frame. 
</LI>
<LI>
<EM>v_data</EM> - Pointer to a buffer containing the V data of a raw frame. 
</LI>
<LI>
<EM>y_data_size</EM> - Pointer to a variable the holds the number of bytes in 
y_data buffer. 
</LI>
<LI>
<EM>u_data_size</EM> - Pointer to a variable the holds the number of bytes in 
u_data buffer. 
</LI>
<LI>
<EM>v_data_size</EM> - Pointer to a variable the holds the number of bytes in 
v_data buffer. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list.   
</LI>
</UL>
</DIV>

</DIV>

<a name="sdvr_sdk_html_Routines__Decoding___API"></a>
<H3>4.10.6 &nbsp; Decoding API</H3>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_enable_decoder"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_enable_decoder">sdvr_enable_decoder</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A> handle, <A HREF="#sdvr_sdk_html_Types__sx_bool">sx_bool</A> enable);
</PRE>
<DIV CLASS="descr">
<P>
This function enables decoding using a particular channel. This function 
must be called every time a new playback session is started and ended. 
</P>
<P>
Each decoded video frames can either be displayed on the SMO by calling 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_smo_grid">sdvr_set_smo_grid</A>()</NOBR> or requested to be sent to the DVR Application for 
displaying on the host monitor by calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_stream_raw_video">sdvr_stream_raw_video</A>()</NOBR>. 
</P>
<P>
We recommend to call <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_smo_grid">sdvr_set_smo_grid</A>()</NOBR> and <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_stream_raw_video">sdvr_stream_raw_video</A>()</NOBR> 
before enabling the decoder so that no decoded video is lost. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - A decoding channel handle. 
</LI>
<LI>
<EM>enable</EM> - If <A HREF="#sdvr_sdk_html_Defines__true">true</A>, then decoding is enabled; otherwise, disabled. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_set_decoder_size"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_set_decoder_size">sdvr_set_decoder_size</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>   handle,
                                  <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A>            width,
                                  <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A>            lines);
</PRE>
<DIV CLASS="descr">
<P>
This function sets the encoded video frame size to be decoded for the given 
decoder channel type. 
</P>
<P>
You must call this function before calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_decoder">sdvr_enable_decoder</A>()</NOBR> to enable 
the decoder. Otherwise, the encoded video size is assumed to be the size 
of the current video standard at full resolution. 
</P>
<P>
You do not need to call this function multiple times prior to enabling the 
decoder if the video frame size has not changed. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - A decoder channel handle. 
</LI>
<LI>
<EM>width</EM> - Width in pixels of the encoded frames. 
</LI>
<LI>
<EM>lines</EM> - Number of lines in pixels of the encoded frames. 
</LI>
<LI>
<STRONG>NOTE</STRONG>: Width and lines combinations must match one of the supported 
video resolutions. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
<P>
Remarks: 
</P>
<P>
If you call this function while the decoder is enabled, the change 
takes affect after the decoder is re-enabled. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_alloc_av_buffer_wait"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_alloc_av_buffer_wait">sdvr_alloc_av_buffer_wait</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>    handle,
                                      <A HREF="#sdvr_sdk_html_Types__sdvr_av_buffer_t">sdvr_av_buffer_t</A>   ** frame_buffer,
                                      <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>             timeout);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to get a buffer from the SDK. To decode video, the 
DVR Application first needs to call this function to get an empty buffer. 
The application then copies encoded video from the disk into this buffer. 
Then it can be sent to the board for decoding using 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_send_av_frame">sdvr_send_av_frame</A>()</NOBR>. 
</P>
<P>
Each buffer can hold one encoded AV frame. For normal speed playback, the 
DVR Application needs to send 30 frames per second to the decoder. 
</P>
<P>
The decoded data can be retrieved from the board using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_av_buffer">sdvr_get_av_buffer</A>()</NOBR> 
using the channel number that was used for decoding. 
</P>
<P>
Buffers allocated this way should be returned as quickly 
as possible to the SDK, so that the decoder is not starved of data. 
</P>
<P>
The returned buffer has the board and channel numbers, and 
other information embedded in the buffer data structure. This information 
has to be treated as read-only. Only the <EM>payload</EM> field in the 
<A HREF="#sdvr_sdk_html_Types__sdvr_av_buffer_t">sdvr_av_buffer_t</A> structure can be modified by the DVR Application. 
</P>
<P>
<STRONG>How to fill up the AV buffer?</STRONG> The buffer returned by this function 
is of type <A HREF="#sdvr_sdk_html_Types__sdvr_av_buffer_t">sdvr_av_buffer_t</A> and has a header and location for the frame 
buffer (payload). The frame buffer can be filled with the encoded data 
from disk. If you stored the header for the encoded buffer (see the description 
of <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_av_buffer">sdvr_get_av_buffer</A>()</NOBR>), then you can copy the header into the 
header for this buffer. You have to be careful, however, not to overwrite 
the reserved field of the buffer returned by this function, as the 
reserved field is used by the SDK when you call <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_send_av_frame">sdvr_send_av_frame</A>()</NOBR>. 
</P>
<P>
<STRONG>NOTE: The board index, channel number, and channel types will be 
set to match the given channel handle upon successful return.</STRONG> 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - A decoding channel handle. 
</LI>
<LI>
<EM>frame_buffer</EM> - A pointer to the buffer variable that is 
set when this function returns. 
</LI>
<LI>
<EM>timeout</EM> - Wait for this number of milliseconds for an available 
buffer before timing out. 
</LI>
</UL>
<P>
Returns 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_alloc_av_buffer"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_alloc_av_buffer">sdvr_alloc_av_buffer</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>    handle,
                                 <A HREF="#sdvr_sdk_html_Types__sdvr_av_buffer_t">sdvr_av_buffer_t</A>   ** frame_buffer);
</PRE>
<DIV CLASS="descr">
<P>
Convenience function equivalent to calling sdvr_alloc_av_buffer_wait with 
timeout set to 0. Returns immediately if no empty buffer available. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - A decoding channel handle. 
</LI>
<LI>
<EM>frame_buffer</EM> - A pointer to the buffer variable that is 
set when this function returns. 
</LI>
</UL>
<P>
Returns 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_send_av_frame"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_send_av_frame">sdvr_send_av_frame</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_av_buffer_t">sdvr_av_buffer_t</A> *frame_buffer);
</PRE>
<DIV CLASS="descr">
<P>
The buffer obtained using <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_alloc_av_buffer">sdvr_alloc_av_buffer</A>()</NOBR> 
is filled with encoded data by the DVR Application, and then the 
buffer is sent to the decoder for decoding using this function. 
</P>
<P>
NOTE: Sending the buffer for decoding also implicitly returns the 
buffer to the SDK so that it can be used again in a future call to 
allocate a buffer. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>frame_buffer</EM> - Pointer to the buffer to be sent. The channel 
number, board number, and so on are already a part of the 
buffer data structure. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>

<a name="sdvr_sdk_html_Routines__Display___and___Sound___API"></a>
<H3>4.10.7 &nbsp; Display and Sound API</H3>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_stream_raw_video"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_stream_raw_video">sdvr_stream_raw_video</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>            handle,
                                  <A HREF="#sdvr_sdk_html_Types__sdvr_video_res_decimation_e">sdvr_video_res_decimation_e</A>   res_decimation,
                                  <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>                      frame_rate,
                                  <A HREF="#sdvr_sdk_html_Types__sx_bool">sx_bool</A>                       enable);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to enable streaming of raw video for a526 
channel to the host. If the channel is an encoding channel,  
then the raw video is from the camera. If it is a decoding  
channel, the raw video is the decoded video.  
</P>
<P>
This function can be called multiple times to enable and disable streaming. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - An encoding or decoding channel handle. 
</LI>
<LI>
<EM>res_decimation</EM> - Specifies whether the video is streamed at 
the system-wide maximum resolution, or 1/4 (CIF), or 1/16 (QCIF), or 2CIF 
of that resolution. (NOTE: DCIF resolution is not supported). 
</LI>
<LI>
<EM>frame_rate</EM> - Specifies the frame rate at which the raw video 
frames are being sent to the host application. In general this 
value should be 30.  
The valid range is 1 - 30. 
</LI>
<LI>
<EM>enable</EM> - If <A HREF="#sdvr_sdk_html_Defines__true">true</A>, streaming is enabled. Disabled otherwise. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_stream_raw_audio"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_stream_raw_audio">sdvr_stream_raw_audio</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>   handle,
                                  <A HREF="#sdvr_sdk_html_Types__sx_bool">sx_bool</A>              enable);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to enable streaming of raw audio for a 
channel to the host. If the channel is an encoding channel,  
then the raw audio is from the microphone. If it is a decoding  
channel, the raw audio is the decoded audio. 
</P>
<P>
The raw audio can only be enabled on a channel that is streaming raw 
video. Otherwise, this function is ignored.  
</P>
<P>
This function can be called multiple times to enable and disable streaming. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - An encoding or decoding channel handle. 
</LI>
<LI>
<EM>enable</EM> - If <A HREF="#sdvr_sdk_html_Defines__true">true</A>, streaming is enabled; otherwise, disabled. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_video_in_params"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_video_in_params">sdvr_get_video_in_params</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>   handle,
                                     <A HREF="#sdvr_sdk_html_Types__sdvr_image_ctrl_t">sdvr_image_ctrl_t</A>  * image_ctrl);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to get the current video-in image parameters. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - An encoding channel handle. 
</LI>
<LI>
<EM>image_ctrl</EM> - A pointer to <A HREF="#sdvr_sdk_html_Types__sdvr_image_ctrl_t">sdvr_image_ctrl_t</A> which holds the 
current video-in image parameter for the given upon successful 
return. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_set_video_in_params"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_set_video_in_params">sdvr_set_video_in_params</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>   handle,
                                     <A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A>            image_ctrl_flag,
                                     <A HREF="#sdvr_sdk_html_Types__sdvr_image_ctrl_t">sdvr_image_ctrl_t</A>  * image_ctrl);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to set various video-in image control parameters. 
You may choose to change one or more of the image control parameters. This 
is accompolished by setting the approriate bit in the control parameter 
flag. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - An encoding channel handle. 
</LI>
<LI>
<EM>image_ctrl_flag</EM> - A bit field indicating which of the fields 
in image_ctrl parameter needs to be updated. Use <A HREF="#sdvr_sdk_html_Defines__SDVR_ICFLAG_ALL">SDVR_ICFLAG_ALL</A> to update 
all the video-in image control parameters. Or choose specific fields 
by ORing any of the image control flags (<A HREF="#sdvr_sdk_html_Defines__SDVR_ICFLAG_HUE">SDVR_ICFLAG_HUE</A>, <A HREF="#sdvr_sdk_html_Defines__SDVR_ICFLAG_SATURATION">SDVR_ICFLAG_SATURATION</A>, <A HREF="#sdvr_sdk_html_Defines__SDVR_ICFLAG_BRIGHTNESS">SDVR_ICFLAG_BRIGHTNESS</A>, 
<A HREF="#sdvr_sdk_html_Defines__SDVR_ICFLAG_CONTRAST">SDVR_ICFLAG_CONTRAST</A>, and <A HREF="#sdvr_sdk_html_Defines__SDVR_ICFLAG_SHARPNESS">SDVR_ICFLAG_SHARPNESS</A>). 
</LI>
<LI>
<EM>image_ctrl</EM> - A pointer to <A HREF="#sdvr_sdk_html_Types__sdvr_image_ctrl_t">sdvr_image_ctrl_t</A> which holds the 
new video-in image parameter for the given. For each image control 
flag set in image_ctrl_flag parameter, you must have the corresponding 
value in image_ctrl data structure parameter. (See <A HREF="#sdvr_sdk_html_Types__sdvr_image_ctrl_t">sdvr_image_ctrl_t</A> for 
valid ranges and defualt values for each field in this structure.) 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
Changing these parameters could effect both alarms detection and 
encoding bitrate. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_set_yuv_format"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_set_yuv_format">sdvr_set_yuv_format</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> board_index, <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> format);
</PRE>
<DIV CLASS="descr">
<P>
By calling this function, you can specify the  
format by which the raw video frames should be constructed. This is a system 
wide settings that affects raw video streaming for both the decoded and 
live video frames.  
By default all the raw video frames are YUV 4:2:0 format. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>board_index</EM> - The number of the board to set its raw video 
streaming format. 
This is a zero based number. It means the first board number  
is index zero, second board number is index one, and so on. 
</LI>
<LI>
<EM>format</EM> - The requested YUV format. If the given format is not 
valid, it will default to <A HREF="#sdvr_sdk_html_Types__SDVR_RAWV_FORMAT_YUV_4_2_0">SDVR_RAWV_FORMAT_YUV_4_2_0</A> 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
None. 
</LI>
</UL>
<P>
Remarks: 
</P>
<P>
This function should only be called if the board is in idle state. This 
means there is no A/V encoding, decoding, or streaming. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_enable_deinterlacing"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_enable_deinterlacing">sdvr_enable_deinterlacing</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>   handle,
                                      <A HREF="#sdvr_sdk_html_Types__sx_bool">sx_bool</A>              enable);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to enable or disable deinterlacing on the  
specified input channel. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM>  Handle to an existing encoder or raw video channel. 
</LI>
<LI>
<EM>enable</EM>  Set to True to enable deinterlacing,  
False to disable deinterlacing. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> on success. Otherwise, see the error list for possible error codes. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
Deinterlacing is enabled by default. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_enable_noise_reduction"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_enable_noise_reduction">sdvr_enable_noise_reduction</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>   handle,
                                        <A HREF="#sdvr_sdk_html_Types__sx_bool">sx_bool</A>              enable);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to enable or disable Stretch-lateral  
noise reduction filtering on the specified input channel. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM>  Handle to an existing encoder or raw video channel. 
</LI>
<LI>
<EM>enable</EM>  Set to True to enable noise reduction,  
False to disable noise reduction. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> on success. Otherwise, see the error list for possible error codes. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
noise reduction is enabled by default. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_set_gain_mode"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_set_gain_mode">sdvr_set_gain_mode</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A> handle, <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> value);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to adjust the gain on the specified camera input. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM>  Handle to an existing encoder or raw video channel. 
</LI>
<LI>
<EM>value</EM>  Gain setting value.  
This value will be passed through as-is to the hardware. The range 
is 0 - 255. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> on success. Otherwise, see the error list for possible error codes. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
Default values for this field is hardware specific.  
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_set_camera_termination"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_set_camera_termination">sdvr_set_camera_termination</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>   handle,
                                        <A HREF="#sdvr_sdk_html_Types__sdvr_term_e">sdvr_term_e</A>          term);
</PRE>
<DIV CLASS="descr">
<P>
This function sets the camera termination impedance value. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM>  Handle of the channel to be affected. 
</LI>
<LI>
<EM>term</EM>  Enumerated constant defining the termination value. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> on success. Otherwise, see the error list for possible error codes. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
The default termination value is <A HREF="#sdvr_sdk_html_Types__SDVR_TERM_75OHM">SDVR_TERM_75OHM</A>. 
</LI>
</UL>
</DIV>

</DIV>

<a name="sdvr_sdk_html_Routines__On___Screen___Display___API"></a>
<H3>4.10.8 &nbsp; On-Screen Display API</H3>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_osd_text_config_ex"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_osd_text_config_ex">sdvr_osd_text_config_ex</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>     handle,
                                    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>               osd_id,
                                    <A HREF="#sdvr_sdk_html_Types__sdvr_osd_config_ex_t">sdvr_osd_config_ex_t</A> * osd_text_config);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to configure the OSD text for an OSD item on all 
the video streams (HMO, encoded, and SMOs). The text 
associated with each OSD item can be up to 100 characters long but the actual 
display is limited to the size of the video and the starting location of 
the text. Additionally, you can specify whether to append a timestamp  
to the displayed text. Appending a time stamp reduces the number of characters 
that can be displayed for your OSD item. 
</P>
<P>
After you configure an OSD item, you can show or hide its display state 
by calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_osd_text_show">sdvr_osd_text_show</A>()</NOBR>. The original state of the OSD item is 
hidden. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - An encoding or decoding channel handle. 
</LI>
<LI>
<EM>osd_id</EM> - The OSD item to be configured. Currently there can be two OSD 
items per each channel. ID zero corresponds to the first OSD, 1 to the second, 
and so on. The current valid range is 0 - 1. 
</LI>
<LI>
<EM>osd_text_config</EM> - This data structure defines the text and its position 
for display over the video for the given channel as well as whether a  
timestamp should be appended to the text. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
<P>
Remark: 
</P>
<UL>
<LI>
Call <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_smo_osd_text_config">sdvr_smo_osd_text_config</A>()</NOBR> 
to selectively configure the OSD text on a specific video stream. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_osd_text_show"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_osd_text_show">sdvr_osd_text_show</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>   handle,
                               <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>             osd_id,
                               <A HREF="#sdvr_sdk_html_Types__sx_bool">sx_bool</A>              show);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to control the display state of an OSD item for 
a given channel. The OSD text is displayed as soon as  
encoding, raw video, or SMO streaming is enabled for the current channel 
handle. Changing the video streaming has no affect on the display state of  
an OSD item for the given channels. 
</P>
<P>
This function must be called only after an OSD item is configured by 
calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_osd_text_config_ex">sdvr_osd_text_config_ex</A>()</NOBR> for the given channel handle. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - An encoding or decoding channel handle. 
</LI>
<LI>
<EM>osd_id</EM> - The OSD item to show or hide. Currently each channel is  
limited to two OSD items. ID zero corresponds to the first OSD, 1 to the second, 
and so on. The current valid range is 0 - 1. 
</LI>
<LI>
<EM>show</EM> - If <A HREF="#sdvr_sdk_html_Defines__true">true</A>, OSD item is displayed; otherwise, it is not 
displayed. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
<P>
Remark: 
</P>
<UL>
<LI>
This function controls the display state of OSD text on all the video 
stream (HMO, encoded, and SMO). Call <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_smo_osd_text_show">sdvr_smo_osd_text_show</A>()</NOBR> 
to selectively change the display 
state of OSD text on a specific video stream for this channel. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_osd_set_font_table"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_osd_set_font_table">sdvr_osd_set_font_table</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_font_table_t">sdvr_font_table_t</A> *font_desc);
</PRE>
<DIV CLASS="descr">
<P>
Use this function to specify a different OSD text display font table than  
the default ASCII font. Currently, Bitmap Distribution  
Format (BDF) file is the only support font format. (The BDF  
by Adobe is a file format for storing bitmap fonts. BDF is most commonly used 
font file within the linux operation system.) 
</P>
<P>
The new font table is used for all the DVR boards that are connected 
at the time of calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_osd_set_font_table">sdvr_osd_set_font_table</A>()</NOBR>. 
You can either choose to use all the characters within 
the font table or a sub-set of it. To use all the characters, set 
start_font_code parameter to 0 and end_font_code parameter to 65536. 
The specified YUV font color is used for all the 
characters within the table. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>font_desc</EM> - A pointer to font descriptor data structure defining 
the new font table to load. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
You should only call this function once and after you connected to all the 
DVR boards. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_osd_use_font_table"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_osd_use_font_table">sdvr_osd_use_font_table</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A> font_id);
</PRE>
<DIV CLASS="descr">
<P>
After you down load font tables into the firmware by calling  
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_osd_set_font_table">sdvr_osd_set_font_table</A>()</NOBR>, you can select which font table to use. By default, 
the last font table down loaded is selected. If no, font table is specified, 
the default English font table is used. 
</P>
<P>
Font table IDs of less than 8 are reserved for pre-defined system fonts.  
Currently, there is only one system font ID <A HREF="#sdvr_sdk_html_Defines__SDVR_FT_FONT_ENGLISH">SDVR_FT_FONT_ENGLISH</A> defined. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>font_id</EM> - The font table ID to be selected. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
The given font table is used for all the DVR boards that are connected 
at the time of calling this function. 
</LI>
</UL>
</DIV>

</DIV>

<a name="sdvr_sdk_html_Routines__Spot___Monitor___Output___API"></a>
<H3>4.10.9 &nbsp; Spot Monitor Output API</H3>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_set_smo_grid"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_set_smo_grid">sdvr_set_smo_grid</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>   handle,
                              <A HREF="#sdvr_sdk_html_Types__sdvr_smo_grid_t">sdvr_smo_grid_t</A>    * smo_grid);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to set the Spot Monitor Output (SMO) grid pattern.  
</P>
<P>
You can divide  the SMO into different grid patterns. Each tile of the 
SMO grid is defined by its left top most coordinate in pixels, and by the 
decimation of its original  video resolution. 
</P>
<P>
The grid pattern on a spot monitor is flexible and can be defined 
in various patterns (such as 4x4, 3x3, or 8x8 grids) as it applies to the 
resolution of the connected monitor. 
</P>
<P>
Each tile of the grid is described by an <A HREF="#sdvr_sdk_html_Types__sdvr_smo_grid_t">sdvr_smo_grid_t</A> data structure.  
</P>
<P>
Each tile can either be enabled or disabled. If you have more than one  
channel in one tile position, you must also specify a dwell time, that is, 
the amount of time each channel is displayed before switching to the  
next channel. If you only have one channel assigned to a tile, that  
channel is permanently displayed while it is enabled. 
</P>
<P>
<STRONG>NOTE: You can include encoder and decoder channels in the SMO tile. For 
encoder channels, the live video is displayed. For decoder channels,  
the decoded (playback) video is displayed. </STRONG> 
</P>
<P>
You can assign multiple channels to a tile, but a specific channel cannot  
be assigned to different tiles. 
</P>
<P>
Assuming your SMO is an NTSC monitor of 720x480 resolution, and you want 
to specify 16 tiles arranged in a 4x4 grid pattern, then each tile is 
180x120. The first left top most grid is (0,0) the next one is (180,120), and so on. 
The resolution decimation for each grid is 1/4 of the camera resolution. 
</P>
<P>
<STRONG>NOTE: The top left coordinates of each tile must be an even number (i.e., 
coordinates (0,5) or (1,2) are invalid).</STRONG> 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - An encode or decode video channel handle whose output is 
displayed on this grid. See section <EM>Spot Monitor Output (SMO)</EM> for 
restriction in using decode video channel handle. 
</LI>
<LI>
<EM>smo_grid</EM> - A pointer structure defining one grid on an SMO.  
Supported SMO resolution decimations are <A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_EQUAL">SDVR_VIDEO_RES_DECIMATION_EQUAL</A>, 
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_CIF">SDVR_VIDEO_RES_DECIMATION_CIF</A>, and <A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_QCIF">SDVR_VIDEO_RES_DECIMATION_QCIF</A>. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
The SMO grid is not displayed at all if it does not fit completely  
on the screen. 
</LI>
<LI>
Call <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_smo_grid_ex">sdvr_set_smo_grid_ex</A>()</NOBR> if your system has more than one SMO  
monitor and you are interested to 
define the SMO grids for a specific spot monitor display. 
</LI>
<LI>
This call will be removed after release 5.x.x.x. Please start using 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_smo_grid_ex">sdvr_set_smo_grid_ex</A>()</NOBR>; 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_smo_grid"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_smo_grid">sdvr_get_smo_grid</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>   handle,
                              <A HREF="#sdvr_sdk_html_Types__sdvr_smo_grid_t">sdvr_smo_grid_t</A>    * smo_grid);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to get the current SMO grid configuration. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - An encode or decode video channel handle whose output is 
displayed on this grid. 
</LI>
<LI>
<EM>smo_grid</EM> - A pointer structure defining one grid on an SMO.  
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
This call will be removed after release 5.x.x.x. Please start using 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_smo_grid_ex">sdvr_get_smo_grid_ex</A>()</NOBR>. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_set_smo_grid_ex"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_set_smo_grid_ex">sdvr_set_smo_grid_ex</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>   handle,
                                 <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>             port_num,
                                 <A HREF="#sdvr_sdk_html_Types__sdvr_smo_grid_t">sdvr_smo_grid_t</A>    * smo_grid);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to set the Spot Monitor Output (SMO) grid pattern 
for a specific SMO display. 
</P>
<P>
You can divide  the SMO into different grid patterns. Each tile of the 
SMO grid is defined by its left top most coordinate in pixels, and by the 
decimation of its original  video resolution. 
</P>
<P>
The grid pattern on a spot monitor is flexible and can be defined 
in various patterns (such as 4x4, 3x3, or 8x8 grids) as it applies to the 
resolution of the connected monitor. 
</P>
<P>
Each tile of the grid is described by an <A HREF="#sdvr_sdk_html_Types__sdvr_smo_grid_t">sdvr_smo_grid_t</A> data structure.  
</P>
<P>
Each tile can either be enabled or disabled. If you have more than one  
channel in one tile position, you must also specify a dwell time, that is, 
the amount of time each channel is displayed before switching to the  
next channel. If you only have one channel assigned to a tile, that  
channel is permanently displayed while it is enabled. 
</P>
<P>
<STRONG>NOTE: You can include encoder and decoder channels in the SMO tile. For 
encoder channels, the live video is displayed. For decoder channels,  
the decoded (playback) video is displayed. </STRONG> 
</P>
<P>
You can assign multiple channels to a tile, but a specific channel cannot  
be assigned to different tiles. 
</P>
<P>
Assuming your SMO is an NTSC monitor of 720x480 resolution, and you want 
to specify 16 tiles arranged in a 4x4 grid pattern, then each tile is 
180x120. The first left top most grid is (0,0) the next one is (180,120), and so on. 
The resolution decimation for each grid is 1/4 of the camera resolution. 
</P>
<P>
<STRONG>NOTE: The top left coordinates of each tile must be an even number (i.e., 
coordinates (0,5) or (1,2) are invalid).</STRONG> 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - An encode or decode video channel handle whose output is 
displayed on this grid. See section <EM>Spot Monitor Output (SMO)</EM> for 
restriction in using decode video channel handle. 
</LI>
<LI>
<EM>port_num</EM> - The SMO port number where the first SMO display is 
one (1). 
</LI>
<LI>
<EM>smo_grid</EM> - A pointer structure defining one grid on an SMO.  
Supported SMO resolution decimations are <A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_EQUAL">SDVR_VIDEO_RES_DECIMATION_EQUAL</A>, 
<A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_CIF">SDVR_VIDEO_RES_DECIMATION_CIF</A>, and <A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_QCIF">SDVR_VIDEO_RES_DECIMATION_QCIF</A>. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
The SMO grid is not displayed at all if it does not fit completely  
on the screen. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_smo_grid_ex"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_smo_grid_ex">sdvr_get_smo_grid_ex</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>   handle,
                                 <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>             port_num,
                                 <A HREF="#sdvr_sdk_html_Types__sdvr_smo_grid_t">sdvr_smo_grid_t</A>    * smo_grid);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to get the current SMO grid configuration for a given 
SMO display . 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - An encode or decode video channel handle whose output is 
displayed on this grid. 
</LI>
<LI>
<EM>port_num</EM> - The SMO port number where the first SMO display is 
one (1). 
</LI>
<LI>
<EM>smo_grid</EM> - A pointer structure defining one grid on an SMO.  
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_smo_attributes"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_smo_attributes">sdvr_get_smo_attributes</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>              board_index,
                                    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>               port_num,
                                    <A HREF="#sdvr_sdk_html_Types__sdvr_smo_attribute_t">sdvr_smo_attribute_t</A> * smo_attrib);
</PRE>
<DIV CLASS="descr">
<P>
This function returns various attributes assoicated to the requested 
Spot Montior Out (SMO). Call this function to find out the SMO 
screen size. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>board_index</EM> - Zero based index of the DVR board to  
query its SMO information. 
</LI>
<LI>
<EM>port_num</EM> - The video out port number starting from port number 1. 
</LI>
<LI>
<EM>smo_attrib</EM> - A structure to hold the attribute of the  
requested SMO port. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> on success. Otherwise, see the error list for possible 
error codes. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_start_video_output"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_start_video_output">sdvr_start_video_output</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>             board_index,
                                    <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>              port_num,
                                    <A HREF="#sdvr_sdk_html_Types__sdvr_rawv_formats_e">sdvr_rawv_formats_e</A>   video_format,
                                    <A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>  * handle);
</PRE>
<DIV CLASS="descr">
<P>
This function initializes the video output port on the specified board. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>board_index</EM> - Index of the board to send the video. 
</LI>
<LI>
<EM>port_num</EM> - The video out port number starting from port number 1. 
</LI>
<LI>
<EM>video_format</EM> - The raw video format that is going to be sent to the 
firmware. 
</LI>
<LI>
<EM>handle</EM> - Pointer to storage for the output channel handle, filled in on 
return. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> on success. Otherwise, see the error list for possible 
error codes. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_stop_video_output"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_stop_video_output">sdvr_stop_video_output</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A> handle);
</PRE>
<DIV CLASS="descr">
<P>
This function shuts down the video output port on the specified board. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - The handle of the output channel to close. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> on success. Otherwise, see the error list for possible 
error codes. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_video_output_buffer"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_video_output_buffer">sdvr_get_video_output_buffer</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>    handle,
                                         <A HREF="#sdvr_sdk_html_Types__sdvr_av_buffer_t">sdvr_av_buffer_t</A>   ** frame_buffer);
</PRE>
<DIV CLASS="descr">
<P>
Get an empty buffer to hold the raw video frame for the purpose of video  
output. This can be filled in and sent to the board  
for display. The raw video frame should be copied to the payload field 
of this buffer in the compact form. In case your raw video frame is 
YUV format, you must copy Y plane followed by U plane followed by V 
plane at the payload field of this buffer. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - Handle of the output channel. This is the handle that 
was created and returned by the call to <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_start_video_output">sdvr_start_video_output</A>()</NOBR>. 
</LI>
<LI>
<EM>frame_buffer</EM> - Pointer to storage that will hold a pointer to the  
allocated buffer on successful return. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> on success. Otherwise, see the error list for possible 
error codes. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
The size of this buffer varies depending on the the video format 
specified when <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_start_video_output">sdvr_start_video_output</A>()</NOBR> was called and the SMO 
video size. To get the SMO video size call <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_smo_attributes">sdvr_get_smo_attributes</A>()</NOBR>. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_send_video_output"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_send_video_output">sdvr_send_video_output</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>   handle,
                                   <A HREF="#sdvr_sdk_html_Types__sdvr_av_buffer_t">sdvr_av_buffer_t</A>   * frame_buffer);
</PRE>
<DIV CLASS="descr">
<P>
Send one raw compact video frame to the video output. 
Each frame resolution is assumed to be 4CIF based on the current system 
video standard.  
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - Handle of the output channel. This is the handle that 
was created and returned by the call to <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_start_video_output">sdvr_start_video_output</A>()</NOBR>. 
</LI>
<LI>
<EM>frame_buffer</EM> - Pointer to a <A HREF="#sdvr_sdk_html_Types__sdvr_av_buffer_t">sdvr_av_buffer_t</A> object that has  
been filled in with the a raw video frame. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> on success. Otherwise, see the error list for possible 
error codes. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
This buffer must have been allocated by the call to 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_video_output_buffer">sdvr_get_video_output_buffer</A>()</NOBR>. 
The raw video frame should have been copied to the payload field 
of this buffer in the compacted raw video format.  
In case your raw video frame is YUV format, you must copy Y  
plane followed by U plane followed by V 
plane at the payload field of this buffer. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_smo_osd_text_config"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_smo_osd_text_config">sdvr_smo_osd_text_config</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>              board_index,
                                     <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>               smo_port,
                                     <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>               osd_id,
                                     <A HREF="#sdvr_sdk_html_Types__sdvr_osd_config_ex_t">sdvr_osd_config_ex_t</A> * osd_text_config);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to configure the OSD text for an OSD item on a specific 
SMO port. The given OSD text applies to the entire SMO monitor and not to any  
particular video channel. The text 
associated with each OSD item can be up to 100 characters long but the actual 
display is limited to the size of the video and the starting location of 
the text. Additionally, you can specify whether to append a timestamp  
to the displayed text. Appending a time stamp reduces the number of characters 
that can be displayed for your OSD item. 
</P>
<P>
After you configure an OSD item, you can show or hide its display state 
by calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_smo_osd_text_show">sdvr_smo_osd_text_show</A>()</NOBR>. The original state of the OSD item is 
hidden. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>board_index</EM> - Index of the board to set its SMO OSD. 
</LI>
<LI>
<EM>smo_port</EM> - Enter the SMO port number for which to configure its OSD text 
where SMO port numbers start from one (1). 
</LI>
<LI>
<EM>osd_id</EM> - The OSD item to be configured. Currently there can be two OSD 
items per each SMO monitor. ID zero corresponds to the first OSD, 1 to the second, 
and so on. The current valid range is 0 - 1. 
</LI>
<LI>
<EM>osd_text_config</EM> - This data structure defines the text and its position 
for display over the given SMO video as well as whether a  
timestamp should be appended to the text. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
The OSD text is not associated to displaying of any SMO streaming. 
As result, you may show or hide OSD text while no other video is 
being displayed on the SMO monitor. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_smo_osd_text_show"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_smo_osd_text_show">sdvr_smo_osd_text_show</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>   board_index,
                                   <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>    smo_port,
                                   <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>    osd_id,
                                   <A HREF="#sdvr_sdk_html_Types__sx_bool">sx_bool</A>     show);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to control the display state of an OSD item for 
a given SMO display on a given DVR board. The OSD text is displayed as soon as  
SMO streaming is enabled for any channel handle on this SMO monitor. 
</P>
<P>
This function must be called only after an OSD item is configured by 
calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_smo_osd_text_config">sdvr_smo_osd_text_config</A>()</NOBR> for the given channel handle. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>board_index</EM> - Index of the board to change the show state of 
its SMO OSD for a given SMO port. 
</LI>
<LI>
<EM>smo_port</EM> - The SMO port number for which to change its  
OSD text display state where SMO port numbers start from one (1). 
</LI>
<LI>
<EM>show</EM> - If <A HREF="#sdvr_sdk_html_Defines__true">true</A>, OSD item is displayed; otherwise, it is not 
displayed. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>

<a name="sdvr_sdk_html_Routines__RS485___Communication___API"></a>
<H3>4.10.10 &nbsp; RS485 Communication API</H3>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_init_uart"></a>
<PRE class="cdef">
<A HREF="#sdvr_ui_sdk_html_Defines__EXTERN">EXTERN</A> <A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_init_uart">sdvr_init_uart</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>   board_index,
                                  <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>   baud_rate,
                                  <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>    data_bits,
                                  <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>    stop_bits,
                                  <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>    parity_enable,
                                  <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>    parity_even);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to initialize the UART port on the S6 to talk 
to the RS-485.  
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>board_index</EM> - The board number.  
This is a zero based number. It means the first board number  
is index zero, second board number is index one, and so on. 
</LI>
<LI>
<EM>baud_rate</EM> - The output baud rate. Must be between 50 and 19200. 
</LI>
<LI>
<EM>data_bits</EM> - Number of data bits. Valid values are 5-8. 
</LI>
<LI>
<EM>stop_bits</EM> - Number of stop bits. Valid values are 1 and 2. 
</LI>
<LI>
<EM>parity_enable</EM> - If this field is set to zero, parity is disabled. 
If set to a nonzero value, parity is enabled. 
</LI>
<LI>
<EM>parity_even</EM> - If this field is set to zero, odd parity is used. 
If set to a nonzero value, even parity is used. This field is 
ignored if parity is disabled. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_write_uart"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_write_uart">sdvr_write_uart</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>   board_index,
                            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>    count,
                            <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>  * data);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to write a number of 8-bit characters to the RS485 port. 
</P>
<P>
Before calling this function, the uart must be initialized by  
calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_init_uart">sdvr_init_uart</A>()</NOBR>. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>board_index</EM> - The board number.  
This is a zero based number. It means the first board number  
is index zero, second board number is index one, and so on. 
</LI>
<LI>
<EM>count</EM> - Number of bytes to transmit.  
</LI>
<LI>
<EM>data</EM> - The data bytes to transmit. The number of valid bytes in 
the array is determined by the <EM>count</EM> field. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_read_uart"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_read_uart">sdvr_read_uart</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>   board_index,
                           <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>  * data_count_read,
                           <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>    max_data_size,
                           <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>  * data);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to read up to requested number of 8-bit characters  
from the RS485 port. 
</P>
<P>
You must initialize the uart by calling <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_init_uart">sdvr_init_uart</A>()</NOBR>and sent commands  
to receive data before calling this function. 
</P>
<P>
It is possible for the data not to be ready on the port at the time of  
calling this function. In this case, you need to call 
this function multiple time while the actual number of bytes received is  
zero or is less than the expected amount. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>board_index</EM> - The board number.  
This is a zero based number. It means the first board number  
is index zero, second board number is index one, and so on. 
</LI>
<LI>
<EM>data_count_read</EM> - A pointer to a variable that holds the actual number 
characters read upon successful return. This count is less than or 
equal to the max_data_size. A value of zero means, there is no data 
available at the port. 
</LI>
<LI>
<EM>max_data_size</EM> - The maximum number of bytes request to read from the 
board. <STRONG>NOTE: The actual returned bytes maybe less than the requested 
ones.</STRONG> 
</LI>
<LI>
<EM>data</EM> - A character pointer long enough to hold the maximum number of 
bytes request. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>

<a name="sdvr_sdk_html_Routines__Sensors___and___Relays___API"></a>
<H3>4.10.11 &nbsp; Sensors and Relays API</H3>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_trigger_relay"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_trigger_relay">sdvr_trigger_relay</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>   board_index,
                               <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>   relay_num,
                               <A HREF="#sdvr_sdk_html_Types__sx_bool">sx_bool</A>     is_triggered);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to trigger relays on each SDVR board. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>board_index</EM> - Index of the board whose relay you want to set. 
This is a zero based number. It means the first board number  
is index zero, second board number is index one, and so on. 
</LI>
<LI>
<EM>relay_num</EM> - The number of the relay - a board with M relays has the  
relays numbered sequentially from 0 to M-1 (see schematics for position  
of relay number 0, 1, and so on). You can determine the number of relays  
from the board configuration data structure.  
</LI>
<LI>
<EM>is_triggered</EM> - If <A HREF="#sdvr_sdk_html_Defines__true">true</A>, the relay is triggered.  
If <A HREF="#sdvr_sdk_html_Defines__false">false</A>, the relay is reset. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_enable_sensor"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_enable_sensor">sdvr_enable_sensor</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>   board_index,
                               <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>   sensor_num,
                               <A HREF="#sdvr_sdk_html_Types__sx_bool">sx_bool</A>     enable);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to enable or disable a sensor on each SDVR board. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>board_index</EM> - Index of the board whose sensor you want to set. 
This is a zero based number. It means the first board number  
is index zero, second board number is index one, and so on. 
</LI>
<LI>
<EM>sensor_num</EM> - The number of the sensor - a board with M sensors has the  
sensors numbered sequentially from 0 to M-1 (see schematics for position  
of sensors number 0, 1, etc.). You can determine the number of sensors  
from the board configuration data structure.  
</LI>
<LI>
<EM>enable</EM> - If <A HREF="#sdvr_sdk_html_Defines__true">true</A>, the sensor is enabled, and if triggered you are 
notified. If <A HREF="#sdvr_sdk_html_Defines__false">false</A>, the sensor is disabled and no notification is 
sent to the DVR Application. Default status of the sensor is disabled. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_BOARD_NOT_CONNECTED">SDVR_ERR_BOARD_NOT_CONNECTED</A> - Error code if the board was never connected. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INVALID_ARG">SDVR_ERR_INVALID_ARG</A> - Error code if the given board index does not exist. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_config_sensors"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_config_sensors">sdvr_config_sensors</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>   board_index,
                                <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>   sensor_enable_map,
                                <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>   edge_triggered_map);
</PRE>
<DIV CLASS="descr">
<P>
This function is used to specify how each sensor should be triggered as well 
as how to enable or disable each of the sensors on each SDVR board. 
</P>
<P>
Sensors can be either edge-triggered or level-sensitive. You can specify 
the method to use to determine whether a sensor is triggered. 
</P>
<P>
A notification message will be sent to the DVR Application for every sensor  
that is enabled and is triggered. The sensors that are disabled receive no  
notification messages. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>board_index</EM> - Index of the board whose sensors you want to set. 
This is a zero based number. It means the first board number  
is index zero, second board number is index one, and so on. 
</LI>
<LI>
<EM>sensor_enable_map</EM> - A bit map corresponding to each sensor to indicate 
whether it is enabled. The least most significant (LMS) bit of this map 
corresponds to the first sensor, the next LMS bit to the second sensor, 
and so on.  You can determine the number of sensors from the board  
configuration data structure. The value of 1 for a bit means that the sensor  
is enabled for the corresponding sensor, and 0 means it is disabled. 
Default status of the sensors is disabled. 
</LI>
<LI>
<EM>edge_triggered_map</EM> -  A bit map corresponding to each sensor to indicate 
whether it is edge triggered. The least most significant (LMS) bit of this map 
corresponds to the first sensor, the next LMS bit to the second sensor, 
and so on.  You can determine the number of sensors from the board  
configuration data structure. The value of 1 for a bit means that the sensor  
is edge triggered for the corresponding sensor, and 0 means it is  
level sensitive. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_BOARD_NOT_CONNECTED">SDVR_ERR_BOARD_NOT_CONNECTED</A> - Error code if the board was never connected. 
</LI>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INVALID_ARG">SDVR_ERR_INVALID_ARG</A> - Error code if the given board index does not exist. 
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_sensors"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_sensors">sdvr_get_sensors</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>   board_index,
                             <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> * sensor_enable_map,
                             <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> * edge_triggered_map);
</PRE>
<DIV CLASS="descr">
<P>
This function returns the enable status of the sensor inputs as 
well as whether it is edge triggered 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>board_index</EM>  Index of the board to be queried. 
</LI>
<LI>
<EM>sensor_enable_map</EM> - A pointer to a bit a map corresponding to each  
sensor to indicate 
whether it is enabled. The least most significant (LMS) bit of this map 
corresponds to the first sensor, the next LMS bit to the second sensor, 
and so on.  The value of 1 for a bit means that the sensor  
is enabled for the corresponding sensor, and 0 means it is disabled. 
Default status of the sensors is disabled. 
</LI>
<LI>
<EM>edge_triggered_map</EM> -  A pointer to a bit map corresponding to each  
sensor to indicate 
whether it is edge triggered. The least most significant (LMS) bit of this map 
corresponds to the first sensor, the next LMS bit to the second sensor, 
and so on.  The value of 1 for a bit means that the sensor  
is edge triggered for the corresponding sensor, and 0 means it is  
level sensitive. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> on success. Otherwise, see the error list for possible 
error codes. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
You can determine the number of sensors from the board  
configuration data structure.  
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_get_relays"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_get_relays">sdvr_get_relays</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>   board_index,
                            <A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A> * relays_status);
</PRE>
<DIV CLASS="descr">
<P>
This function returns the status of the relay outputs. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>board_index</EM>  Index of the board to be queried. 
</LI>
<LI>
<EM>relay_status</EM>  Pointer to a bit map storage where the current 
relay status is returned. 
Each bit of the bit map identifies the enable  
state of each relay ordered from the least most significant (LMS)  
bit corresponding to the first relay. 
The value of 1 for a bit means that the relay  
is enabled for the corresponding relay, and 0 means it is disabled. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> on success. Otherwise, see the error list for possible 
error codes. 
</LI>
</UL>
<P>
Remarks: 
</P>
<UL>
<LI>
You can determine the number of relays from the board  
configuration data structure.  
</LI>
</UL>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_set_led"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_set_led">sdvr_set_led</A> (<A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A>         board_index,
                         <A HREF="#sdvr_sdk_html_Types__sdvr_led_type_e">sdvr_led_type_e</A>   led_type,
                         <A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A>          led_num,
                         <A HREF="#sdvr_sdk_html_Types__sx_bool">sx_bool</A>           enable);
</PRE>
<DIV CLASS="descr">
<P>
This function sets the state of an LED within a given LED type  
on the board. 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>board_index</EM>  Index of the board. 
</LI>
<LI>
<EM>led_type</EM>  The type of LED to set its enable status. 
</LI>
<LI>
<EM>led_num</EM>  A zero based LED number within the LED type group. 
The first LED number is specified by zero (0), second LED number 
is one (1), and so on. 
</LI>
<LI>
<EM>enable</EM>  Set to <A HREF="#sdvr_sdk_html_Defines__true">true</A> to turn the LED on, <A HREF="#sdvr_sdk_html_Defines__false">false</A> to turn it off. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> on success. Otherwise, see the error list for possible 
error codes. 
</LI>
</UL>
</DIV>

</DIV>

<a name="sdvr_sdk_html_Routines__Recording___to___File___API"></a>
<H3>4.10.12 &nbsp; Recording to File API</H3>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_start_recording"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_start_recording">sdvr_start_recording</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>    handle,
                                 <A HREF="#sdvr_sdk_html_Types__sdvr_sub_encoders_e">sdvr_sub_encoders_e</A>   sub_chan_enc,
                                 char                * file_name);
</PRE>
<DIV CLASS="descr">
<P>
This function saves the encoded audio and video frames for any of the 
sub-encoders of the specified encoder channel into the given file name. 
The generated file is in .mov format.  
</P>
<P>
Calling this function does not affect the current enable state of the encoder. 
After calling this function, you must call <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_encoder">sdvr_enable_encoder</A>()</NOBR> to 
enable the subencoder of the given encoder channel.  
</P>
<P>
Calling this function multiple times consecutively results in writing the  
audio and video frames into the new file without re-starting the encoder.  
Hence, there will not be any lose of frames. This function ensures the  
new recorded file starts with an I-frame. <STRONG>NOTE: Not implemented in this 
release.</STRONG> 
</P>
<P>
Call <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_stop_recording">sdvr_stop_recording</A>()</NOBR> to stop saving of  encoded frames.  
Additionally, if you need to stop the encoder, you must 
call <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_encoder">sdvr_enable_encoder</A>()</NOBR>. 
</P>
<P>
<STRONG>NOTE: This function is not supported and maybe changed in the next 
release.</STRONG> 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - The channel handle for which to record audio and video 
frames. 
</LI>
<LI>
<EM>sub_chan_enc</EM> - The encoder subchannel for which to save its encoded audio 
and video frames. 
</LI>
<LI>
<EM>file_name</EM> - The full file name path to record audio/video frames. 
</LI>
<LI>
<STRONG>NOTE: This function always truncates the given file before 
recording new audio and video frames.</STRONG> 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
<P>
Remarks: 
</P>
<P>
Even though this function is called to save the encoded frames, 
the DVR Application is still notified by the callback function as the audio and 
video frames arrive. You can choose to ignore these frames or call 
<NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_av_buffer">sdvr_get_av_buffer</A>()</NOBR> to get the frames and perform additional processing. 
</P>
</DIV>

</DIV>
<DIV onMouseover="this.style.backgroundColor='rgb(235, 235, 235)'"  onMouseout="this.style.backgroundColor='rgb(220, 220, 220)'" >
<a name="sdvr_sdk_html_Routines__sdvr_stop_recording"></a>
<PRE class="cdef">
<A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A> <A HREF="#sdvr_sdk_html_Routines__sdvr_stop_recording">sdvr_stop_recording</A> (<A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A>    handle,
                                <A HREF="#sdvr_sdk_html_Types__sdvr_sub_encoders_e">sdvr_sub_encoders_e</A>   sub_chan_enc);
</PRE>
<DIV CLASS="descr">
<P>
Call this function to stop saving encoded audio and video frames for 
the subencoder of the specified encoder channel that is recording. 
</P>
<P>
Calling this function does not affect the current enable state of the encoder. 
After calling this function, you must call <NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_encoder">sdvr_enable_encoder</A>()</NOBR> to 
stop the subencoder of the given encoder channel. 
</P>
<P>
<STRONG>NOTE: This function is not supported and maybe changed in the next 
release.</STRONG> 
</P>
<P>
Parameters: 
</P>
<UL>
<LI>
<EM>handle</EM> - The channel handle for which to stop recording audio/video 
frames. 
</LI>
<LI>
<EM>sub_chan_enc</EM> - The encoder subchannel to stop recording. 
</LI>
</UL>
<P>
Returns: 
</P>
<UL>
<LI>
<A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A> - On success. Otherwise, see the error code list. 
</LI>
</UL>
</DIV>

</DIV>

<!-- SEC_ROUTINES_CLOSE -->

<DIV style="page-break-before:always"></DIV>
<H3><A NAME="index_html_cdoc_xref_A"></A>A</H3>
<TABLE class="index" width="100%">
<TR>
<TD width="33%"><NOBR><A HREF="#dvr_common_html_Defines__AIM_TEST_ERRORS">AIM_TEST_ERRORS</A></NOBR></TD>
<TD width="33%"><NOBR><A HREF="#dvr_common_html_Defines__ASWITCH_ENABLE_ERR">ASWITCH_ENABLE_ERR</A></NOBR></TD>
<TD width="33%"></TD>
</TR>
</TABLE>
<H3><A NAME="index_html_cdoc_xref_B"></A>B</H3>
<TABLE class="index" width="100%">
<TR>
<TD width="33%"><NOBR><A HREF="#dvrfw_html_Types__bootloader_versions">bootloader_versions</A></NOBR></TD>
<TD width="33%"></TD>
<TD width="33%"></TD>
</TR>
</TABLE>
<H3><A NAME="index_html_cdoc_xref_C"></A>C</H3>
<TABLE class="index" width="100%">
<TR>
<TD width="33%"><NOBR><A HREF="#dvr_common_html_Types__CHIP_S6100_3_REV_C">CHIP_S6100_3_REV_C</A></NOBR></TD>
<TD width="33%"><NOBR><A HREF="#dvr_common_html_Types__CHIP_S6105_3_REV_D">CHIP_S6105_3_REV_D</A></NOBR></TD>
<TD width="33%"><NOBR><A HREF="#dvr_common_html_Types__CHIP_S6106_3_REV_F">CHIP_S6106_3_REV_F</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__CHIP_S6100_3_REV_D">CHIP_S6100_3_REV_D</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__CHIP_S6105_3_REV_F">CHIP_S6105_3_REV_F</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__CHIP_S6106_3_UNKNOWN">CHIP_S6106_3_UNKNOWN</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__CHIP_S6100_3_REV_F">CHIP_S6100_3_REV_F</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__CHIP_S6105_3_UNKNOWN">CHIP_S6105_3_UNKNOWN</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__CHIP_UNKNOWN">CHIP_UNKNOWN</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__CHIP_S6100_3_UNKNOWN">CHIP_S6100_3_UNKNOWN</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__CHIP_S6106_3_REV_C">CHIP_S6106_3_REV_C</A></NOBR></TD>
<TD></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__CHIP_S6105_3_REV_C">CHIP_S6105_3_REV_C</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__CHIP_S6106_3_REV_D">CHIP_S6106_3_REV_D</A></NOBR></TD>
<TD></TD>
</TR>
</TABLE>
<H3><A NAME="index_html_cdoc_xref_D"></A>D</H3>
<TABLE class="index" width="100%">
<TR>
<TD width="33%"><NOBR><A HREF="#dvr_common_html_Defines__DDR_DIAG_ADDRLINES_FAIL">DDR_DIAG_ADDRLINES_FAIL</A></NOBR></TD>
<TD width="33%"><NOBR><A HREF="#dvr_common_html_Types__DVR_JOB_HOST_ENCODE">DVR_JOB_HOST_ENCODE</A></NOBR></TD>
<TD width="33%"><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_SMO_NOT_DISABLED">DVR_STATUS_SMO_NOT_DISABLED</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DDR_DIAG_BITFLIP_FAIL">DDR_DIAG_BITFLIP_FAIL</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Routines__DVR_JOB_NUM">DVR_JOB_NUM</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_SMO_NOT_SUPPORTED">DVR_STATUS_SMO_NOT_SUPPORTED</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DDR_DIAG_DMA_FAIL">DDR_DIAG_DMA_FAIL</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_JOB_RESET">DVR_JOB_RESET</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_UNSUPPORTED_COMMAND">DVR_STATUS_UNSUPPORTED_COMMAND</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DDR_DIAG_READ_DMA_FAIL">DDR_DIAG_READ_DMA_FAIL</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_JOB_STATE_AUDIO_LOST">DVR_JOB_STATE_AUDIO_LOST</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_VDET_ERROR">DVR_STATUS_VDET_ERROR</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DDR_DIAG_WRITEREAD_FAIL">DDR_DIAG_WRITEREAD_FAIL</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_JOB_STATE_VIDEO_LOST">DVR_JOB_STATE_VIDEO_LOST</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_VPP_RUNTIME_ERROR">DVR_STATUS_VPP_RUNTIME_ERROR</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_ALL">DEBUG_FLAG_ALL</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_JOB_VIDEO_OUTPUT">DVR_JOB_VIDEO_OUTPUT</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_WRONG_AUDIO_FORMAT">DVR_STATUS_WRONG_AUDIO_FORMAT</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_AUDIO_OPERATIONS">DEBUG_FLAG_AUDIO_OPERATIONS</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_LED_TYPE_ALARM">DVR_LED_TYPE_ALARM</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_WRONG_CAMERA_NUMBER">DVR_STATUS_WRONG_CAMERA_NUMBER</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_BOARD">DEBUG_FLAG_BOARD</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_LED_TYPE_RECORD">DVR_LED_TYPE_RECORD</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_WRONG_CAMERA_TYPE">DVR_STATUS_WRONG_CAMERA_TYPE</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_CHANNEL">DEBUG_FLAG_CHANNEL</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_OSD_DTS_DEBUG">DVR_OSD_DTS_DEBUG</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_WRONG_CODEC_FORMAT">DVR_STATUS_WRONG_CODEC_FORMAT</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_DEBUGGING_ON">DEBUG_FLAG_DEBUGGING_ON</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_OSD_DTS_DEBUG_2">DVR_OSD_DTS_DEBUG_2</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_WRONG_CODEC_RESOLUTION">DVR_STATUS_WRONG_CODEC_RESOLUTION</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_DECODER">DEBUG_FLAG_DECODER</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_OSD_DTS_DMY_12H">DVR_OSD_DTS_DMY_12H</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_WRONG_JOB_ID">DVR_STATUS_WRONG_JOB_ID</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_DISPLAY_OPERATIONS">DEBUG_FLAG_DISPLAY_OPERATIONS</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_OSD_DTS_DMY_24H">DVR_OSD_DTS_DMY_24H</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_WRONG_JOB_TYPE">DVR_STATUS_WRONG_JOB_TYPE</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_ENCODER">DEBUG_FLAG_ENCODER</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_OSD_DTS_MDY_12H">DVR_OSD_DTS_MDY_12H</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_WRONG_VIDEO_FORMAT">DVR_STATUS_WRONG_VIDEO_FORMAT</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_FW_WRITE_TO_FILE">DEBUG_FLAG_FW_WRITE_TO_FILE</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_OSD_DTS_MDY_24H">DVR_OSD_DTS_MDY_24H</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_TERM_75OHM">DVR_TERM_75OHM</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_GENERAL_SDK">DEBUG_FLAG_GENERAL_SDK</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_OSD_DTS_NONE">DVR_OSD_DTS_NONE</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_TERM_HIGH_IMPEDANCE">DVR_TERM_HIGH_IMPEDANCE</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_OSD">DEBUG_FLAG_OSD</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_OSD_DTS_YMD_12H">DVR_OSD_DTS_YMD_12H</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_UART_CMD_CONFIG">DVR_UART_CMD_CONFIG</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_OUTPUT_TO_SCREEN">DEBUG_FLAG_OUTPUT_TO_SCREEN</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_OSD_DTS_YMD_24H">DVR_OSD_DTS_YMD_24H</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_UART_CMD_OUTPUT">DVR_UART_CMD_OUTPUT</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_RECORD_TO_FILE">DEBUG_FLAG_RECORD_TO_FILE</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_OSD_OPCODE_CLEAR_TEXT">DVR_OSD_OPCODE_CLEAR_TEXT</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_VC_FORMAT_H264">DVR_VC_FORMAT_H264</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_SENSORS_RELAYS">DEBUG_FLAG_SENSORS_RELAYS</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_OSD_OPCODE_CONFIG">DVR_OSD_OPCODE_CONFIG</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_VC_FORMAT_JPEG">DVR_VC_FORMAT_JPEG</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_SMO">DEBUG_FLAG_SMO</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_OSD_OPCODE_SHOW">DVR_OSD_OPCODE_SHOW</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_VC_FORMAT_MPEG4">DVR_VC_FORMAT_MPEG4</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_VIDEO_ALARM">DEBUG_FLAG_VIDEO_ALARM</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_OSD_OPCODE_TEXT">DVR_OSD_OPCODE_TEXT</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_VC_FORMAT_NONE">DVR_VC_FORMAT_NONE</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_VIDEO_FRAME">DEBUG_FLAG_VIDEO_FRAME</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_OSD_POS_BL">DVR_OSD_POS_BL</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_VIDEO_RES_CIF">DVR_VIDEO_RES_CIF</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__DEBUG_FLAG_WRITE_TO_FILE">DEBUG_FLAG_WRITE_TO_FILE</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_OSD_POS_BR">DVR_OSD_POS_BR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_VIDEO_RES_CLASSIC_2CIF">DVR_VIDEO_RES_CLASSIC_2CIF</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DECODER_AUDDET_TEST_NO_SYNC_ERR">DECODER_AUDDET_TEST_NO_SYNC_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_OSD_POS_CUSTOM">DVR_OSD_POS_CUSTOM</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_VIDEO_RES_CLASSIC_4CIF">DVR_VIDEO_RES_CLASSIC_4CIF</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DECODER_AUDIO_TEST_INIT_ERR">DECODER_AUDIO_TEST_INIT_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_OSD_POS_TL">DVR_OSD_POS_TL</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_VIDEO_RES_CLASSIC_CIF">DVR_VIDEO_RES_CLASSIC_CIF</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DECODER_AUDIO_TEST_NO_AUDIO_ERR">DECODER_AUDIO_TEST_NO_AUDIO_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_OSD_POS_TR">DVR_OSD_POS_TR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_VIDEO_RES_DCIF">DVR_VIDEO_RES_DCIF</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DECODER_AUDIO_TEST_TIMEOUT">DECODER_AUDIO_TEST_TIMEOUT</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_RAWV_FORMAT_YUV_4_2_0">DVR_RAWV_FORMAT_YUV_4_2_0</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_VIDEO_RES_FULL">DVR_VIDEO_RES_FULL</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DECODER_UNIQUE_AUDIO_TEST_ERR">DECODER_UNIQUE_AUDIO_TEST_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_RAWV_FORMAT_YUV_4_2_2">DVR_RAWV_FORMAT_YUV_4_2_2</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_VIDEO_RES_HALF">DVR_VIDEO_RES_HALF</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DECODER_UNIQUE_VIDEO_TEST_ERR">DECODER_UNIQUE_VIDEO_TEST_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_RAWV_FORMAT_YVU_4_2_0">DVR_RAWV_FORMAT_YVU_4_2_0</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_VIDEO_RES_INVALID">DVR_VIDEO_RES_INVALID</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DECODER_VIDDET_TEST_CONFLICT_ERR">DECODER_VIDDET_TEST_CONFLICT_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_RC_CBR">DVR_RC_CBR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_VIDEO_RES_QCIF">DVR_VIDEO_RES_QCIF</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DECODER_VIDDET_TEST_INIT_ERR">DECODER_VIDDET_TEST_INIT_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_RC_CQ">DVR_RC_CQ</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_VOUT_OPCODE_START">DVR_VOUT_OPCODE_START</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DECODER_VIDDET_TEST_NO_INPUT_ERR">DECODER_VIDDET_TEST_NO_INPUT_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_RC_CQP">DVR_RC_CQP</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_VOUT_OPCODE_STOP">DVR_VOUT_OPCODE_STOP</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DECODER_VIDDET_TEST_NO_SYNC_ERR">DECODER_VIDDET_TEST_NO_SYNC_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_RC_NONE">DVR_RC_NONE</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_VPP_ACTION_ANALYTIC">DVR_VPP_ACTION_ANALYTIC</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DECODER_VIDDET_TEST_UNKNOWN_CHIP">DECODER_VIDDET_TEST_UNKNOWN_CHIP</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_RC_VBR">DVR_RC_VBR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_VPP_ACTION_DEINTERLACE">DVR_VPP_ACTION_DEINTERLACE</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DECODER_VIDEO_TEST_INIT_ERR">DECODER_VIDEO_TEST_INIT_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_REGION_MAP_MAX_SIZE">DVR_REGION_MAP_MAX_SIZE</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_VPP_ACTION_MEDIAN_FILTER">DVR_VPP_ACTION_MEDIAN_FILTER</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DECODER_VIDEO_TEST_NO_VIDEO_ERR">DECODER_VIDEO_TEST_NO_VIDEO_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_REGION_OPCODE_CONFIG">DVR_REGION_OPCODE_CONFIG</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_VPP_ACTION_SLATERAL">DVR_VPP_ACTION_SLATERAL</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DECODER_VIDEO_TEST_TIMEOUT">DECODER_VIDEO_TEST_TIMEOUT</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_REGION_OPCODE_ENABLE">DVR_REGION_OPCODE_ENABLE</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_VPP_MODE_ANALYTICS">DVR_VPP_MODE_ANALYTICS</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVRFW_OSD_LEN">DVRFW_OSD_LEN</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_REGION_OPCODE_FINISH">DVR_REGION_OPCODE_FINISH</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_VPP_MODE_SLATERAL">DVR_VPP_MODE_SLATERAL</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvrfw_html_Defines__DVRFW_VER_BUG">DVRFW_VER_BUG</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_REGION_OPCODE_START">DVR_REGION_OPCODE_START</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_VPP_OPCODE_CONTROL">DVR_VPP_OPCODE_CONTROL</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvrfw_html_Defines__DVRFW_VER_BUILD">DVRFW_VER_BUILD</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_REGION_TYPE_BD">DVR_REGION_TYPE_BD</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_VPP_OPCODE_REGIONS">DVR_VPP_OPCODE_REGIONS</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvrfw_html_Defines__DVRFW_VER_MAJOR">DVRFW_VER_MAJOR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_REGION_TYPE_MD">DVR_REGION_TYPE_MD</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_VSTD_2CIF_NTSC">DVR_VSTD_2CIF_NTSC</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvrfw_html_Defines__DVRFW_VER_MINOR">DVRFW_VER_MINOR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_REGION_TYPE_ND">DVR_REGION_TYPE_ND</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_VSTD_2CIF_PAL">DVR_VSTD_2CIF_PAL</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_AC_FORMAT_G711">DVR_AC_FORMAT_G711</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_REGION_TYPE_PR">DVR_REGION_TYPE_PR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_VSTD_4CIF_NTSC">DVR_VSTD_4CIF_NTSC</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_AC_FORMAT_G726_16K">DVR_AC_FORMAT_G726_16K</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_REP_AUTH_KEY">DVR_REP_AUTH_KEY</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_VSTD_4CIF_PAL">DVR_VSTD_4CIF_PAL</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_AC_FORMAT_G726_24K">DVR_AC_FORMAT_G726_24K</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_REP_BD">DVR_REP_BD</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_VSTD_CIF_NTSC">DVR_VSTD_CIF_NTSC</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_AC_FORMAT_G726_32K">DVR_AC_FORMAT_G726_32K</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_REP_BOARD">DVR_REP_BOARD</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_VSTD_CIF_PAL">DVR_VSTD_CIF_PAL</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_AC_FORMAT_G726_48K">DVR_AC_FORMAT_G726_48K</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_REP_CODEC_INFO">DVR_REP_CODEC_INFO</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_VSTD_D1_NTSC">DVR_VSTD_D1_NTSC</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_AC_FORMAT_NONE">DVR_AC_FORMAT_NONE</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_REP_CONTROL">DVR_REP_CONTROL</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_VSTD_D1_PAL">DVR_VSTD_D1_PAL</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_AUTH_KEY_LEN">DVR_AUTH_KEY_LEN</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_REP_DECODE">DVR_REP_DECODE</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_VSTD_QCIF_NTSC">DVR_VSTD_QCIF_NTSC</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_DATA_G711">DVR_DATA_G711</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_REP_ENCODE">DVR_REP_ENCODE</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_VSTD_QCIF_PAL">DVR_VSTD_QCIF_PAL</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_DATA_G726_16K">DVR_DATA_G726_16K</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_REP_ENC_ALARM">DVR_REP_ENC_ALARM</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_VSTD_UNKNOWN">DVR_VSTD_UNKNOWN</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_DATA_G726_32K">DVR_DATA_G726_32K</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_REP_FONT_TABLE">DVR_REP_FONT_TABLE</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_ac_format_e">dvr_ac_format_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_DATA_H264_B">DVR_DATA_H264_B</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_REP_HMO">DVR_REP_HMO</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_ac_format_enum">dvr_ac_format_enum</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_DATA_H264_I">DVR_DATA_H264_I</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_REP_IOCTL">DVR_REP_IOCTL</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_auth_key_t">dvr_auth_key_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_DATA_H264_IDR">DVR_DATA_H264_IDR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_REP_JOB">DVR_REP_JOB</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_bd_t">dvr_bd_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_DATA_H264_P">DVR_DATA_H264_P</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_REP_MD">DVR_REP_MD</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_board_t">dvr_board_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_DATA_H264_PPS">DVR_DATA_H264_PPS</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_REP_ND">DVR_REP_ND</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_chip_rev_e">dvr_chip_rev_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_DATA_H264_SPS">DVR_DATA_H264_SPS</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_REP_OSD">DVR_REP_OSD</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_chip_rev_enum">dvr_chip_rev_enum</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_DATA_HDR_LEN">DVR_DATA_HDR_LEN</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_REP_OSD_EX">DVR_REP_OSD_EX</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_codec_info_t">dvr_codec_info_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_DATA_HDR_SIG">DVR_DATA_HDR_SIG</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_REP_PR">DVR_REP_PR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_start_of_file">dvr_common</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_DATA_HDR_VER">DVR_DATA_HDR_VER</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_REP_REGIONS_MAP">DVR_REP_REGIONS_MAP</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_control_t">dvr_control_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_DATA_JPEG">DVR_DATA_JPEG</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_REP_RELAYS">DVR_REP_RELAYS</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_data_header_t">dvr_data_header_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_DATA_MOTION_VALUES">DVR_DATA_MOTION_VALUES</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_REP_SENSORS">DVR_REP_SENSORS</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_data_type_e">dvr_data_type_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_DATA_MPEG4_B">DVR_DATA_MPEG4_B</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_REP_SMO">DVR_REP_SMO</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_data_type_enum">dvr_data_type_enum</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_DATA_MPEG4_I">DVR_DATA_MPEG4_I</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_REP_SMO_ATTRIB">DVR_REP_SMO_ATTRIB</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_decode_info_t">dvr_decode_info_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_DATA_MPEG4_P">DVR_DATA_MPEG4_P</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_REP_TIME">DVR_REP_TIME</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_enc_alarm_info_t">dvr_enc_alarm_info_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_DATA_MPEG4_VOL">DVR_DATA_MPEG4_VOL</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_REP_UART">DVR_REP_UART</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_encode_info_t">dvr_encode_info_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_DATA_RAW_AUDIO">DVR_DATA_RAW_AUDIO</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_REP_VER_INFO">DVR_REP_VER_INFO</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_font_table_t">dvr_font_table_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_DATA_RAW_VIDEO">DVR_DATA_RAW_VIDEO</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_REP_VIDEO_OUTPUT">DVR_REP_VIDEO_OUTPUT</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_hmo_t">dvr_hmo_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_DATA_RAW_VIDEO_U">DVR_DATA_RAW_VIDEO_U</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_REP_WATCHDOG">DVR_REP_WATCHDOG</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_ioctl_t">dvr_ioctl_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_DATA_RAW_VIDEO_V">DVR_DATA_RAW_VIDEO_V</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SET_AUTH_KEY">DVR_SET_AUTH_KEY</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_job_action_e">dvr_job_action_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_DATA_RAW_VIDEO_Y">DVR_DATA_RAW_VIDEO_Y</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SET_BD">DVR_SET_BD</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_job_action_enum">dvr_job_action_enum</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_DATA_UNKNOWN">DVR_DATA_UNKNOWN</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SET_BOARD">DVR_SET_BOARD</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_job_t">dvr_job_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_FONT_ENGLISH">DVR_FONT_ENGLISH</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SET_CONTROL">DVR_SET_CONTROL</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_job_type_e">dvr_job_type_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_FONT_FORMAT_YUV_4_2_0">DVR_FONT_FORMAT_YUV_4_2_0</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SET_DECODE">DVR_SET_DECODE</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_job_type_enum">dvr_job_type_enum</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_BUF_INDEX">DVR_FONT_OPCODE_BUF_INDEX</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SET_ENCODE">DVR_SET_ENCODE</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_led_type_e">dvr_led_type_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_BUF_UTF16">DVR_FONT_OPCODE_BUF_UTF16</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SET_ENC_ALARM">DVR_SET_ENC_ALARM</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_led_type_enum">dvr_led_type_enum</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_BUF_UU">DVR_FONT_OPCODE_BUF_UU</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SET_FONT_TABLE">DVR_SET_FONT_TABLE</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_md_t">dvr_md_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_BUF_VV">DVR_FONT_OPCODE_BUF_VV</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SET_HMO">DVR_SET_HMO</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_message_e">dvr_message_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_BUF_WIDTH">DVR_FONT_OPCODE_BUF_WIDTH</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SET_IOCTL">DVR_SET_IOCTL</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_message_enum">dvr_message_enum</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_BUF_YY">DVR_FONT_OPCODE_BUF_YY</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SET_JOB">DVR_SET_JOB</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_nd_t">dvr_nd_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_COPY">DVR_FONT_OPCODE_COPY</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SET_MD">DVR_SET_MD</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_osd_dts_e">dvr_osd_dts_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_COPY_DONE">DVR_FONT_OPCODE_COPY_DONE</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SET_ND">DVR_SET_ND</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_osd_dts_enum">dvr_osd_dts_enum</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_FINISH">DVR_FONT_OPCODE_FINISH</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SET_OSD">DVR_SET_OSD</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_osd_ex_t">dvr_osd_ex_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_SELECT">DVR_FONT_OPCODE_SELECT</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SET_OSD_EX">DVR_SET_OSD_EX</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_osd_pos_e">dvr_osd_pos_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_FONT_OPCODE_START">DVR_FONT_OPCODE_START</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SET_PR">DVR_SET_PR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_osd_pos_enum">dvr_osd_pos_enum</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_FW_INTERNAL">DVR_FW_INTERNAL</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SET_REGIONS_MAP">DVR_SET_REGIONS_MAP</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_osd_t">dvr_osd_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_GET_AUTH_KEY">DVR_GET_AUTH_KEY</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SET_RELAYS">DVR_SET_RELAYS</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_pr_t">dvr_pr_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_GET_BD">DVR_GET_BD</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SET_SENSORS">DVR_SET_SENSORS</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_rawv_format_e">dvr_rawv_format_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_GET_BOARD">DVR_GET_BOARD</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SET_SMO">DVR_SET_SMO</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_rawv_format_enum">dvr_rawv_format_enum</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_GET_CODEC_INFO">DVR_GET_CODEC_INFO</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SET_TIME">DVR_SET_TIME</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_rc_e">dvr_rc_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_GET_CONTROL">DVR_GET_CONTROL</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SET_UART">DVR_SET_UART</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_rc_enum">dvr_rc_enum</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_GET_DECODE">DVR_GET_DECODE</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SET_VIDEO_OUTPUT">DVR_SET_VIDEO_OUTPUT</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_regions_map_t">dvr_regions_map_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_GET_ENCODE">DVR_GET_ENCODE</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SET_WATCHDOG">DVR_SET_WATCHDOG</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_relay_t">dvr_relay_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_GET_ENC_ALARM">DVR_GET_ENC_ALARM</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SIGNAL_BLIND_DETECTED">DVR_SIGNAL_BLIND_DETECTED</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_sensor_t">dvr_sensor_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_GET_HMO">DVR_GET_HMO</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SIGNAL_FATAL_ERROR">DVR_SIGNAL_FATAL_ERROR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_sig_host_t">dvr_sig_host_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_GET_IOCTL">DVR_GET_IOCTL</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SIGNAL_HEARTBEAT">DVR_SIGNAL_HEARTBEAT</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_signal_type_e">dvr_signal_type_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_GET_JOB">DVR_GET_JOB</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SIGNAL_MOTION_DETECTED">DVR_SIGNAL_MOTION_DETECTED</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_signal_type_enum">dvr_signal_type_enum</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_GET_MD">DVR_GET_MD</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SIGNAL_NIGHT_DETECTED">DVR_SIGNAL_NIGHT_DETECTED</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_smo_attrib_t">dvr_smo_attrib_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_GET_ND">DVR_GET_ND</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SIGNAL_RUNTIME_ERROR">DVR_SIGNAL_RUNTIME_ERROR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_smo_capabilities_e">dvr_smo_capabilities_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_GET_OSD">DVR_GET_OSD</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SIGNAL_SENSOR_ACTIVATED">DVR_SIGNAL_SENSOR_ACTIVATED</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_smo_t">dvr_smo_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_GET_OSD_EX">DVR_GET_OSD_EX</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SIGNAL_VIDEO_DETECTED">DVR_SIGNAL_VIDEO_DETECTED</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_status_e">dvr_status_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_GET_PR">DVR_GET_PR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SIGNAL_VIDEO_LOST">DVR_SIGNAL_VIDEO_LOST</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_status_enum">dvr_status_enum</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_GET_RELAYS">DVR_GET_RELAYS</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SIGNAL_WATCHDOG_EXPIRED">DVR_SIGNAL_WATCHDOG_EXPIRED</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_term_e">dvr_term_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_GET_SENSORS">DVR_GET_SENSORS</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SIG_HOST">DVR_SIG_HOST</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_term_enum">dvr_term_enum</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_GET_SMO">DVR_GET_SMO</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SMO_CAP_ALPHA_BLENDING">DVR_SMO_CAP_ALPHA_BLENDING</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_time_t">dvr_time_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_GET_SMO_ATTRIB">DVR_GET_SMO_ATTRIB</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SMO_CAP_ANALOG">DVR_SMO_CAP_ANALOG</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_uart_t">dvr_uart_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_GET_TIME">DVR_GET_TIME</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SMO_CAP_OSD">DVR_SMO_CAP_OSD</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_vc_format_e">dvr_vc_format_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_GET_UART">DVR_GET_UART</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SMO_CAP_OUTPUT">DVR_SMO_CAP_OUTPUT</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_vc_format_enum">dvr_vc_format_enum</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_GET_VER_INFO">DVR_GET_VER_INFO</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_SMO_CAP_TILING">DVR_SMO_CAP_TILING</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_ver_info_t">dvr_ver_info_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_GET_WATCHDOG">DVR_GET_WATCHDOG</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_AUDIO_RUNTIME_ERROR">DVR_STATUS_AUDIO_RUNTIME_ERROR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_video_res_e">dvr_video_res_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_ICFLAG_BRT">DVR_ICFLAG_BRT</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_DECODER_RUNTIME_ERROR">DVR_STATUS_DECODER_RUNTIME_ERROR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_video_res_enum">dvr_video_res_enum</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_ICFLAG_CONT">DVR_ICFLAG_CONT</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_ENCODER_RUNTIME_ERROR">DVR_STATUS_ENCODER_RUNTIME_ERROR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_videoout_t">dvr_videoout_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_ICFLAG_HUE">DVR_ICFLAG_HUE</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_EXCEED_CPU_LIMIT">DVR_STATUS_EXCEED_CPU_LIMIT</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_vpp_action_e">dvr_vpp_action_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_ICFLAG_SAT">DVR_ICFLAG_SAT</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_ILLEGAL_COMMAND">DVR_STATUS_ILLEGAL_COMMAND</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_vpp_action_enum">dvr_vpp_action_enum</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_ICFLAG_SHARP">DVR_ICFLAG_SHARP</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_ILLEGAL_PARAMETER">DVR_STATUS_ILLEGAL_PARAMETER</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_vpp_mode_e">dvr_vpp_mode_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_CLOSE_CHAN">DVR_IOCTL_CODE_CLOSE_CHAN</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_ILLEGAL_SMO_PARAMS">DVR_STATUS_ILLEGAL_SMO_PARAMS</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_vpp_mode_enum">dvr_vpp_mode_enum</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_DECODER_REGS">DVR_IOCTL_CODE_DECODER_REGS</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_INTERNAL_ERROR">DVR_STATUS_INTERNAL_ERROR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__dvr_watchdog_t">dvr_watchdog_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_GAIN_MODE">DVR_IOCTL_CODE_GAIN_MODE</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_INVALID_TIME">DVR_STATUS_INVALID_TIME</A></NOBR></TD>
<TD><NOBR><A HREF="#dvrfw_html_start_of_file">dvrfw</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_IMG_CONTROL">DVR_IOCTL_CODE_IMG_CONTROL</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_JOB_ALREADY_CREATED">DVR_STATUS_JOB_ALREADY_CREATED</A></NOBR></TD>
<TD><NOBR><A HREF="#dvrfw_html_Routines__dvrfw_camera_encode">dvrfw_camera_encode</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_LED">DVR_IOCTL_CODE_LED</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_JOB_NOT_CREATED">DVR_STATUS_JOB_NOT_CREATED</A></NOBR></TD>
<TD><NOBR><A HREF="#dvrfw_html_Routines__dvrfw_host_data_proxy">dvrfw_host_data_proxy</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_MOTION_FRAME_FREQ">DVR_IOCTL_CODE_MOTION_FRAME_FREQ</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_JOB_NOT_DISABLED">DVR_STATUS_JOB_NOT_DISABLED</A></NOBR></TD>
<TD><NOBR><A HREF="#dvrfw_html_Routines__dvrfw_host_decode">dvrfw_host_decode</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_OPEN_CHAN">DVR_IOCTL_CODE_OPEN_CHAN</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_JOB_NOT_ENABLED">DVR_STATUS_JOB_NOT_ENABLED</A></NOBR></TD>
<TD><NOBR><A HREF="#dvrfw_html_Routines__dvrfw_host_encode">dvrfw_host_encode</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_RAWV_FORMAT">DVR_IOCTL_CODE_RAWV_FORMAT</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_NO_IO_BOARD">DVR_STATUS_NO_IO_BOARD</A></NOBR></TD>
<TD><NOBR><A HREF="#dvrfw_html_Routines__dvrfw_host_msg_proxy">dvrfw_host_msg_proxy</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_TERMINATION">DVR_IOCTL_CODE_TERMINATION</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_OK">DVR_STATUS_OK</A></NOBR></TD>
<TD><NOBR><A HREF="#dvrfw_html_Routines__dvrfw_io_manager">dvrfw_io_manager</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__DVR_IOCTL_CODE_VPP_CONTROL">DVR_IOCTL_CODE_VPP_CONTROL</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_OUT_OF_MEMORY">DVR_STATUS_OUT_OF_MEMORY</A></NOBR></TD>
<TD><NOBR><A HREF="#dvrfw_html_Routines__dvrfw_smo_manager">dvrfw_smo_manager</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_JOB_CAMERA_ENCODE">DVR_JOB_CAMERA_ENCODE</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_RES_LIMIT_EXCEEDED">DVR_STATUS_RES_LIMIT_EXCEEDED</A></NOBR></TD>
<TD><NOBR><A HREF="#dvrfw_html_Routines__dvrfw_stdout_manager">dvrfw_stdout_manager</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_JOB_CREATE">DVR_JOB_CREATE</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_RUNTIME_ERROR">DVR_STATUS_RUNTIME_ERROR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvrfw_html_Routines__dvrfw_vout_manager">dvrfw_vout_manager</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_JOB_DESTROY">DVR_JOB_DESTROY</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_SMO_CHAN_FAILED">DVR_STATUS_SMO_CHAN_FAILED</A></NOBR></TD>
<TD></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_JOB_HOST_DECODE">DVR_JOB_HOST_DECODE</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Types__DVR_STATUS_SMO_NOT_CREATED">DVR_STATUS_SMO_NOT_CREATED</A></NOBR></TD>
<TD></TD>
</TR>
</TABLE>
<H3><A NAME="index_html_cdoc_xref_E"></A>E</H3>
<TABLE class="index" width="100%">
<TR>
<TD width="33%"><NOBR><A HREF="#dvr_common_html_Defines__EPSON_REG_TEST_INIT_ERR">EPSON_REG_TEST_INIT_ERR</A></NOBR></TD>
<TD width="33%"><NOBR><A HREF="#dvr_common_html_Defines__EPSON_REG_TEST_WALKING_ERR">EPSON_REG_TEST_WALKING_ERR</A></NOBR></TD>
<TD width="33%"><NOBR><A HREF="#sdvr_ui_sdk_html_Defines__EXTERN">EXTERN</A></NOBR></TD>
</TR>
</TABLE>
<H3><A NAME="index_html_cdoc_xref_F"></A>F</H3>
<TABLE class="index" width="100%">
<TR>
<TD width="33%"><NOBR><A HREF="#sdvr_sdk_html_Defines__false">false</A></NOBR></TD>
<TD width="33%"></TD>
<TD width="33%"></TD>
</TR>
</TABLE>
<H3><A NAME="index_html_cdoc_xref_G"></A>G</H3>
<TABLE class="index" width="100%">
<TR>
<TD width="33%"><NOBR><A HREF="#dvr_common_html_Defines__GLOBAL_RESET_TEST_ERR">GLOBAL_RESET_TEST_ERR</A></NOBR></TD>
<TD width="33%"></TD>
<TD width="33%"></TD>
</TR>
</TABLE>
<H3><A NAME="index_html_cdoc_xref_I"></A>I</H3>
<TABLE class="index" width="100%">
<TR>
<TD width="33%"><NOBR><A HREF="#sdvr_sdk_html_Defines__INVALID_CHAN_HANDLE">INVALID_CHAN_HANDLE</A></NOBR></TD>
<TD width="33%"><NOBR><A HREF="#dvr_common_html_Defines__IOBOARD_ALARMOUT_ERR">IOBOARD_ALARMOUT_ERR</A></NOBR></TD>
<TD width="33%"><NOBR><A HREF="#dvr_common_html_Defines__IOBOARD_LOOPBACK_ERR">IOBOARD_LOOPBACK_ERR</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__IOBOARD_ALARMIN_ERR">IOBOARD_ALARMIN_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__IOBOARD_CAMTERM_ERR">IOBOARD_CAMTERM_ERR</A></NOBR></TD>
<TD></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__IOBOARD_ALARMOUTRELAY_ERR">IOBOARD_ALARMOUTRELAY_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__IOBOARD_LED_ERR">IOBOARD_LED_ERR</A></NOBR></TD>
<TD></TD>
</TR>
</TABLE>
<H3><A NAME="index_html_cdoc_xref_N"></A>N</H3>
<TABLE class="index" width="100%">
<TR>
<TD width="33%"><NOBR><A HREF="#dvr_common_html_Defines__NVP1104_REG_TEST_ERR">NVP1104_REG_TEST_ERR</A></NOBR></TD>
<TD width="33%"><NOBR><A HREF="#dvr_common_html_Defines__NVP1114_REG_TEST_ERR">NVP1114_REG_TEST_ERR</A></NOBR></TD>
<TD width="33%"></TD>
</TR>
</TABLE>
<H3><A NAME="index_html_cdoc_xref_P"></A>P</H3>
<TABLE class="index" width="100%">
<TR>
<TD width="33%"><NOBR><A HREF="#dvr_common_html_Defines__PCIE_EYEMASK_TEST_ERR">PCIE_EYEMASK_TEST_ERR</A></NOBR></TD>
<TD width="33%"><NOBR><A HREF="#dvr_common_html_Defines__PLL_TEST_DDR_DLL_ERR">PLL_TEST_DDR_DLL_ERR</A></NOBR></TD>
<TD width="33%"><NOBR><A HREF="#dvr_common_html_Defines__PLL_TEST_MHZ_ERR">PLL_TEST_MHZ_ERR</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__PCIE_EYEMASK_TEST_NO_CBB">PCIE_EYEMASK_TEST_NO_CBB</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__PLL_TEST_DP0_PLL_ERR">PLL_TEST_DP0_PLL_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__PLL_TEST_SYS_PLL_ERR">PLL_TEST_SYS_PLL_ERR</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__PCIE_EYEMASK_TEST_TIMEOUT">PCIE_EYEMASK_TEST_TIMEOUT</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__PLL_TEST_DP2_PLL_ERR">PLL_TEST_DP2_PLL_ERR</A></NOBR></TD>
<TD></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__PLL_TEST_AIM_PLL_ERR">PLL_TEST_AIM_PLL_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__PLL_TEST_IO_PLL_ERR">PLL_TEST_IO_PLL_ERR</A></NOBR></TD>
<TD></TD>
</TR>
</TABLE>
<H3><A NAME="index_html_cdoc_xref_S"></A>S</H3>
<TABLE class="index" width="100%">
<TR>
<TD width="33%"><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_AUDIO_ENC_G711">SDVR_AUDIO_ENC_G711</A></NOBR></TD>
<TD width="33%"><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_MPEG4_P">SDVR_FRAME_MPEG4_P</A></NOBR></TD>
<TD width="33%"><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_diag_code_e">sdvr_diag_code_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_AUDIO_ENC_G726_16K">SDVR_AUDIO_ENC_G726_16K</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_MPEG4_VOL">SDVR_FRAME_MPEG4_VOL</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_display_debug_callback">sdvr_display_debug_callback</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_AUDIO_ENC_G726_24K">SDVR_AUDIO_ENC_G726_24K</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_RAW_AUDIO">SDVR_FRAME_RAW_AUDIO</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_dts_style_e">sdvr_dts_style_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_AUDIO_ENC_G726_32K">SDVR_AUDIO_ENC_G726_32K</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_RAW_VIDEO">SDVR_FRAME_RAW_VIDEO</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_auth_key">sdvr_enable_auth_key</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_AUDIO_ENC_G726_48K">SDVR_AUDIO_ENC_G726_48K</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_VIDEO_ENCODED_PRIMARY">SDVR_FRAME_VIDEO_ENCODED_PRIMARY</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_blind_detection">sdvr_enable_blind_detection</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_AUDIO_ENC_NONE">SDVR_AUDIO_ENC_NONE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_VIDEO_ENCODED_SECONDARY">SDVR_FRAME_VIDEO_ENCODED_SECONDARY</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_decoder">sdvr_enable_decoder</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__SDVR_AV_STATE_AUDIO_LOST">SDVR_AV_STATE_AUDIO_LOST</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_AUDIO_RUNTIME">SDVR_FRMW_ERR_AUDIO_RUNTIME</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_deinterlacing">sdvr_enable_deinterlacing</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__SDVR_AV_STATE_VIDEO_LOST">SDVR_AV_STATE_VIDEO_LOST</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_CHANNEL_ALREADY_CREATED">SDVR_FRMW_ERR_CHANNEL_ALREADY_CREATED</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_encoder">sdvr_enable_encoder</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_BITRATE_CONTROL_CBR">SDVR_BITRATE_CONTROL_CBR</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_CHANNEL_NOT_CREATED">SDVR_FRMW_ERR_CHANNEL_NOT_CREATED</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_motion_detection">sdvr_enable_motion_detection</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_BITRATE_CONTROL_CONSTANT_QUALITY">SDVR_BITRATE_CONTROL_CONSTANT_QUALITY</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_CHANNEL_NOT_DISABLED">SDVR_FRMW_ERR_CHANNEL_NOT_DISABLED</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_motion_detection_ex">sdvr_enable_motion_detection_ex</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_BITRATE_CONTROL_CQP">SDVR_BITRATE_CONTROL_CQP</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_CHANNEL_NOT_ENABLED">SDVR_FRMW_ERR_CHANNEL_NOT_ENABLED</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_night_detection">sdvr_enable_night_detection</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_BITRATE_CONTROL_NONE">SDVR_BITRATE_CONTROL_NONE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_DECODER_RUNTIME_ERROR">SDVR_FRMW_ERR_DECODER_RUNTIME_ERROR</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_noise_reduction">sdvr_enable_noise_reduction</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_BITRATE_CONTROL_VBR">SDVR_BITRATE_CONTROL_VBR</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_ENCODER_RUNTIME_ERROR">SDVR_FRMW_ERR_ENCODER_RUNTIME_ERROR</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_privacy_regions">sdvr_enable_privacy_regions</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__SDVR_BOARD_SERIAL_LENGTH">SDVR_BOARD_SERIAL_LENGTH</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_EXCEED_CPU_LIMIT">SDVR_FRMW_ERR_EXCEED_CPU_LIMIT</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_enable_sensor">sdvr_enable_sensor</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_CHAN_TYPE_DECODER">SDVR_CHAN_TYPE_DECODER</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_ILLEGAL_COMMAND">SDVR_FRMW_ERR_ILLEGAL_COMMAND</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_err_e">sdvr_err_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_CHAN_TYPE_ENCODER">SDVR_CHAN_TYPE_ENCODER</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_ILLEGAL_PARAMETER">SDVR_FRMW_ERR_ILLEGAL_PARAMETER</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Types__sdvr_err_ui_e">sdvr_err_ui_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_CHAN_TYPE_NONE">SDVR_CHAN_TYPE_NONE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_ILLEGAL_SMO_PARAMS">SDVR_FRMW_ERR_ILLEGAL_SMO_PARAMS</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_firmware_ver_t">sdvr_firmware_ver_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_CHAN_TYPE_OUTPUT">SDVR_CHAN_TYPE_OUTPUT</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_INTERNAL_ERROR">SDVR_FRMW_ERR_INTERNAL_ERROR</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_font_table_t">sdvr_font_table_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_CHIP_S6100_3_REV_C">SDVR_CHIP_S6100_3_REV_C</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_INVALID_TIME">SDVR_FRMW_ERR_INVALID_TIME</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_frame_type_e">sdvr_frame_type_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_CHIP_S6100_3_REV_D">SDVR_CHIP_S6100_3_REV_D</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_NO_IO_BOARD">SDVR_FRMW_ERR_NO_IO_BOARD</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_alarm_motion_value">sdvr_get_alarm_motion_value</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_CHIP_S6100_3_REV_F">SDVR_CHIP_S6100_3_REV_F</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_OUT_OF_MEMORY">SDVR_FRMW_ERR_OUT_OF_MEMORY</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_alarm_video_encoder_params">sdvr_get_alarm_video_encoder_params</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_CHIP_S6100_3_UNKNOWN">SDVR_CHIP_S6100_3_UNKNOWN</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_RES_LIMIT_EXCEEDED">SDVR_FRMW_ERR_RES_LIMIT_EXCEEDED</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_audio_encoder_channel_params">sdvr_get_audio_encoder_channel_params</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_CHIP_S6105_3_REV_C">SDVR_CHIP_S6105_3_REV_C</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_RUNTIME_ERROR">SDVR_FRMW_ERR_RUNTIME_ERROR</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_av_buffer">sdvr_get_av_buffer</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_CHIP_S6105_3_REV_D">SDVR_CHIP_S6105_3_REV_D</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_SMO_CHAN_FAILED">SDVR_FRMW_ERR_SMO_CHAN_FAILED</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_blind_detection">sdvr_get_blind_detection</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_CHIP_S6105_3_REV_F">SDVR_CHIP_S6105_3_REV_F</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_SMO_NOT_CREATED">SDVR_FRMW_ERR_SMO_NOT_CREATED</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_board_attributes">sdvr_get_board_attributes</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_CHIP_S6105_3_UNKNOWN">SDVR_CHIP_S6105_3_UNKNOWN</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_SMO_NOT_DISABLED">SDVR_FRMW_ERR_SMO_NOT_DISABLED</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_board_config">sdvr_get_board_config</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_CHIP_S6106_3_REV_C">SDVR_CHIP_S6106_3_REV_C</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_SMO_NOT_SUPPORTED">SDVR_FRMW_ERR_SMO_NOT_SUPPORTED</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_board_count">sdvr_get_board_count</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_CHIP_S6106_3_REV_D">SDVR_CHIP_S6106_3_REV_D</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_UNSUPPORTED_COMMAND">SDVR_FRMW_ERR_UNSUPPORTED_COMMAND</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_board_index">sdvr_get_board_index</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_CHIP_S6106_3_REV_F">SDVR_CHIP_S6106_3_REV_F</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_VDET_ERROR">SDVR_FRMW_ERR_VDET_ERROR</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_buffer_alarm_value">sdvr_get_buffer_alarm_value</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_CHIP_S6106_3_UNKNOWN">SDVR_CHIP_S6106_3_UNKNOWN</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_VPP_RUNTIME_ERROR">SDVR_FRMW_ERR_VPP_RUNTIME_ERROR</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_buffer_channel">sdvr_get_buffer_channel</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_CHIP_UNKNOWN">SDVR_CHIP_UNKNOWN</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_WRONG_AUDIO_FORMAT">SDVR_FRMW_ERR_WRONG_AUDIO_FORMAT</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_buffer_frame_type">sdvr_get_buffer_frame_type</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__SDVR_DATA_HDR_SIG">SDVR_DATA_HDR_SIG</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_WRONG_CAMERA_NUMBER">SDVR_FRMW_ERR_WRONG_CAMERA_NUMBER</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_buffer_sub_encoder">sdvr_get_buffer_sub_encoder</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__SDVR_DATA_HDR_VER">SDVR_DATA_HDR_VER</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_WRONG_CAMERA_TYPE">SDVR_FRMW_ERR_WRONG_CAMERA_TYPE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_buffer_timestamp">sdvr_get_buffer_timestamp</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DDR_ADDRLINES_FAIL">SDVR_DIAG_DDR_ADDRLINES_FAIL</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_WRONG_CHANNEL_ID">SDVR_FRMW_ERR_WRONG_CHANNEL_ID</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_buffer_yuv_format">sdvr_get_buffer_yuv_format</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DDR_BITFLIP_FAIL">SDVR_DIAG_DDR_BITFLIP_FAIL</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_WRONG_CHANNEL_TYPE">SDVR_FRMW_ERR_WRONG_CHANNEL_TYPE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_chan_num">sdvr_get_chan_num</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DDR_DMA_FAIL">SDVR_DIAG_DDR_DMA_FAIL</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_WRONG_CODEC_FORMAT">SDVR_FRMW_ERR_WRONG_CODEC_FORMAT</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_chan_type">sdvr_get_chan_type</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DDR_READ_DMA_FAIL">SDVR_DIAG_DDR_READ_DMA_FAIL</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_WRONG_CODEC_RESOLUTION">SDVR_FRMW_ERR_WRONG_CODEC_RESOLUTION</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_chan_user_data">sdvr_get_chan_user_data</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DDR_WRITEREAD_FAIL">SDVR_DIAG_DDR_WRITEREAD_FAIL</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRMW_ERR_WRONG_VIDEO_FORMAT">SDVR_FRMW_ERR_WRONG_VIDEO_FORMAT</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_date_time">sdvr_get_date_time</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DECODER_AUDDET_TEST_NO_SYNC_ERR">SDVR_DIAG_DECODER_AUDDET_TEST_NO_SYNC_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__SDVR_FT_FONT_ENGLISH">SDVR_FT_FONT_ENGLISH</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_driver_version">sdvr_get_driver_version</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DECODER_AUDIO_TEST_INIT">SDVR_DIAG_DECODER_AUDIO_TEST_INIT</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__SDVR_FT_FORMAT_BDF">SDVR_FT_FORMAT_BDF</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_error_text">sdvr_get_error_text</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DECODER_AUDIO_TEST_NO_AUDIO">SDVR_DIAG_DECODER_AUDIO_TEST_NO_AUDIO</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__SDVR_ICFLAG_ALL">SDVR_ICFLAG_ALL</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_firmware_version_ex">sdvr_get_firmware_version_ex</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DECODER_AUDIO_TEST_TIMEOUT">SDVR_DIAG_DECODER_AUDIO_TEST_TIMEOUT</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__SDVR_ICFLAG_BRIGHTNESS">SDVR_ICFLAG_BRIGHTNESS</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_motion_detection">sdvr_get_motion_detection</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DECODER_UNIQUE_VIDEO_TEST">SDVR_DIAG_DECODER_UNIQUE_VIDEO_TEST</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__SDVR_ICFLAG_CONTRAST">SDVR_ICFLAG_CONTRAST</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_night_detection">sdvr_get_night_detection</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DECODER_VIDDET_TEST_CONFLICT_ERR">SDVR_DIAG_DECODER_VIDDET_TEST_CONFLICT_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__SDVR_ICFLAG_HUE">SDVR_ICFLAG_HUE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_pci_attrib">sdvr_get_pci_attrib</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DECODER_VIDDET_TEST_INIT_ERR">SDVR_DIAG_DECODER_VIDDET_TEST_INIT_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__SDVR_ICFLAG_SATURATION">SDVR_ICFLAG_SATURATION</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_privacy_regions">sdvr_get_privacy_regions</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DECODER_VIDDET_TEST_NO_INPUT_ERR">SDVR_DIAG_DECODER_VIDDET_TEST_NO_INPUT_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__SDVR_ICFLAG_SHARPNESS">SDVR_ICFLAG_SHARPNESS</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_relays">sdvr_get_relays</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DECODER_VIDDET_TEST_NO_SYNC_ERR">SDVR_DIAG_DECODER_VIDDET_TEST_NO_SYNC_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_LED_TYPE_ALARM">SDVR_LED_TYPE_ALARM</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_sdk_params">sdvr_get_sdk_params</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DECODER_VIDDET_TEST_UNKNOWN_CHIP">SDVR_DIAG_DECODER_VIDDET_TEST_UNKNOWN_CHIP</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_LED_TYPE_RECORD">SDVR_LED_TYPE_RECORD</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_sdk_version">sdvr_get_sdk_version</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DECODER_VIDEO_TEST_INIT">SDVR_DIAG_DECODER_VIDEO_TEST_INIT</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_LOC_BOTTOM_LEFT">SDVR_LOC_BOTTOM_LEFT</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_sensors">sdvr_get_sensors</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DECODER_VIDEO_TEST_NO_VIDEO">SDVR_DIAG_DECODER_VIDEO_TEST_NO_VIDEO</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_LOC_BOTTOM_RIGHT">SDVR_LOC_BOTTOM_RIGHT</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_smo_attributes">sdvr_get_smo_attributes</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_DECODER_VIDEO_TEST_TIMEOUT">SDVR_DIAG_DECODER_VIDEO_TEST_TIMEOUT</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_LOC_CUSTOM">SDVR_LOC_CUSTOM</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_smo_grid">sdvr_get_smo_grid</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_EPSON_REG_TEST_INIT">SDVR_DIAG_EPSON_REG_TEST_INIT</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_LOC_TOP_LEFT">SDVR_LOC_TOP_LEFT</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_smo_grid_ex">sdvr_get_smo_grid_ex</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_EPSON_REG_TEST_WALKING">SDVR_DIAG_EPSON_REG_TEST_WALKING</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_LOC_TOP_RIGHT">SDVR_LOC_TOP_RIGHT</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_supported_vstd">sdvr_get_supported_vstd</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_NVP1104_REG_TEST">SDVR_DIAG_NVP1104_REG_TEST</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__SDVR_MAX_BD_REGIONS">SDVR_MAX_BD_REGIONS</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_video_encoder_channel_params">sdvr_get_video_encoder_channel_params</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_NVP1114_REG_TEST">SDVR_DIAG_NVP1114_REG_TEST</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Defines__SDVR_MAX_DRAW_REGIONS">SDVR_MAX_DRAW_REGIONS</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_video_in_params">sdvr_get_video_in_params</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_OK">SDVR_DIAG_OK</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__SDVR_MAX_MD_REGIONS">SDVR_MAX_MD_REGIONS</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_video_output_buffer">sdvr_get_video_output_buffer</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_PCIE_EYEMASK_TEST_ERR">SDVR_DIAG_PCIE_EYEMASK_TEST_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__SDVR_MAX_OSD">SDVR_MAX_OSD</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_video_standard">sdvr_get_video_standard</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_PCIE_EYEMASK_TEST_NO_CBB">SDVR_DIAG_PCIE_EYEMASK_TEST_NO_CBB</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__SDVR_MAX_OSD_EX_TEXT">SDVR_MAX_OSD_EX_TEXT</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_watchdog_state">sdvr_get_watchdog_state</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_PCIE_EYEMASK_TEST_TIMEOUT">SDVR_DIAG_PCIE_EYEMASK_TEST_TIMEOUT</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__SDVR_MAX_OSD_TEXT">SDVR_MAX_OSD_TEXT</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_get_yuv_buffer">sdvr_get_yuv_buffer</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_PLL_TEST_AIM">SDVR_DIAG_PLL_TEST_AIM</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__SDVR_MAX_PR_REGIONS">SDVR_MAX_PR_REGIONS</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_image_ctrl_t">sdvr_image_ctrl_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_PLL_TEST_DDR">SDVR_DIAG_PLL_TEST_DDR</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_OSD_DTS_DEBUG">SDVR_OSD_DTS_DEBUG</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_init_uart">sdvr_init_uart</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_PLL_TEST_DP0">SDVR_DIAG_PLL_TEST_DP0</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_OSD_DTS_DMY_12H">SDVR_OSD_DTS_DMY_12H</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_led_type_e">sdvr_led_type_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_PLL_TEST_DP2">SDVR_DIAG_PLL_TEST_DP2</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_OSD_DTS_DMY_24H">SDVR_OSD_DTS_DMY_24H</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_location_e">sdvr_location_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_PLL_TEST_IO">SDVR_DIAG_PLL_TEST_IO</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_OSD_DTS_MDY_12H">SDVR_OSD_DTS_MDY_12H</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_mb_region_t">sdvr_mb_region_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_PLL_TEST_MHZ">SDVR_DIAG_PLL_TEST_MHZ</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_OSD_DTS_MDY_24H">SDVR_OSD_DTS_MDY_24H</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_motion_detection_t">sdvr_motion_detection_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_PLL_TEST_SYS">SDVR_DIAG_PLL_TEST_SYS</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_OSD_DTS_NONE">SDVR_OSD_DTS_NONE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_motion_value_analyzer">sdvr_motion_value_analyzer</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_SPI_TEST_COMPARE">SDVR_DIAG_SPI_TEST_COMPARE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_OSD_DTS_YMD_12H">SDVR_OSD_DTS_YMD_12H</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_night_detection_t">sdvr_night_detection_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_SPI_TEST_ERASE">SDVR_DIAG_SPI_TEST_ERASE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_OSD_DTS_YMD_24H">SDVR_OSD_DTS_YMD_24H</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_osd_config_ex_t">sdvr_osd_config_ex_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_SPI_TEST_MAINT">SDVR_DIAG_SPI_TEST_MAINT</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_RAWV_FORMAT_YUV_4_2_0">SDVR_RAWV_FORMAT_YUV_4_2_0</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_osd_set_font_table">sdvr_osd_set_font_table</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_SPI_TEST_MISC">SDVR_DIAG_SPI_TEST_MISC</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_RAWV_FORMAT_YUV_4_2_2">SDVR_RAWV_FORMAT_YUV_4_2_2</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_osd_text_config_ex">sdvr_osd_text_config_ex</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_SPI_TEST_PROG">SDVR_DIAG_SPI_TEST_PROG</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_RAWV_FORMAT_YVU_4_2_0">SDVR_RAWV_FORMAT_YVU_4_2_0</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_osd_text_config_t">sdvr_osd_text_config_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_SPI_TEST_READ">SDVR_DIAG_SPI_TEST_READ</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_REGION_BLIND">SDVR_REGION_BLIND</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_osd_text_show">sdvr_osd_text_show</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_SPI_TEST_UNLOCK">SDVR_DIAG_SPI_TEST_UNLOCK</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__SDVR_REGION_MAP_4CIF_WIDTH">SDVR_REGION_MAP_4CIF_WIDTH</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_osd_use_font_table">sdvr_osd_use_font_table</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_TW2815_REG_TEST">SDVR_DIAG_TW2815_REG_TEST</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__SDVR_REGION_MAP_D1_WIDTH">SDVR_REGION_MAP_D1_WIDTH</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_pci_attrib_t">sdvr_pci_attrib_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_TW2864_REG_TEST">SDVR_DIAG_TW2864_REG_TEST</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__SDVR_REGION_MAP_LINE_NTSC">SDVR_REGION_MAP_LINE_NTSC</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_privacy_region_t">sdvr_privacy_region_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_TWI_EEPROM_TEST_COMPARE">SDVR_DIAG_TWI_EEPROM_TEST_COMPARE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__SDVR_REGION_MAP_LINE_PAL">SDVR_REGION_MAP_LINE_PAL</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_rawv_formats_e">sdvr_rawv_formats_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_TWI_EEPROM_TEST_INIT">SDVR_DIAG_TWI_EEPROM_TEST_INIT</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_REGION_MOTION">SDVR_REGION_MOTION</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_read_ioctl">sdvr_read_ioctl</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_TWI_EEPROM_TEST_READ">SDVR_DIAG_TWI_EEPROM_TEST_READ</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_REGION_PRIVACY">SDVR_REGION_PRIVACY</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_read_uart">sdvr_read_uart</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_TWI_EEPROM_TEST_WP_COMPARE">SDVR_DIAG_TWI_EEPROM_TEST_WP_COMPARE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_SIGNAL_FATAL_ERROR">SDVR_SIGNAL_FATAL_ERROR</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_region_t">sdvr_region_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DIAG_TWI_EEPROM_TEST_WRITE">SDVR_DIAG_TWI_EEPROM_TEST_WRITE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_SIGNAL_RUNTIME_ERROR">SDVR_SIGNAL_RUNTIME_ERROR</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_regions_type_e">sdvr_regions_type_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DRV_BOARD_BOOT_FAIL">SDVR_DRV_BOARD_BOOT_FAIL</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_SMO_CAP_ALPHA_BLENDING">SDVR_SMO_CAP_ALPHA_BLENDING</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_release_av_buffer">sdvr_release_av_buffer</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_BOARD_CLOSE">SDVR_DRV_ERR_BOARD_CLOSE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_SMO_CAP_ANALOG">SDVR_SMO_CAP_ANALOG</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_release_yuv_buffer">sdvr_release_yuv_buffer</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_BOARD_CONNECT">SDVR_DRV_ERR_BOARD_CONNECT</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_SMO_CAP_OSD">SDVR_SMO_CAP_OSD</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_remove_region">sdvr_remove_region</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_BOARD_IN_USE">SDVR_DRV_ERR_BOARD_IN_USE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_SMO_CAP_OUTPUT">SDVR_SMO_CAP_OUTPUT</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_rgb">sdvr_rgb</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_BOARD_RESET">SDVR_DRV_ERR_BOARD_RESET</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_SMO_CAP_TILING">SDVR_SMO_CAP_TILING</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_run_diagnostics">sdvr_run_diagnostics</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_CHANNEL_CLOSE">SDVR_DRV_ERR_CHANNEL_CLOSE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_TERM_75OHM">SDVR_TERM_75OHM</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_start_of_file">sdvr_sdk</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_CHANNEL_CONNECT">SDVR_DRV_ERR_CHANNEL_CONNECT</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_TERM_HIGH_IMPEDANCE">SDVR_TERM_HIGH_IMPEDANCE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_sdk_close">sdvr_sdk_close</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_CHANNEL_CREATE">SDVR_DRV_ERR_CHANNEL_CREATE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Defines__SDVR_UI_ERR_NONE">SDVR_UI_ERR_NONE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_sdk_init">sdvr_sdk_init</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_CHANNEL_DEAD">SDVR_DRV_ERR_CHANNEL_DEAD</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Defines__SDVR_UI_LS_DASH">SDVR_UI_LS_DASH</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_sdk_params_t">sdvr_sdk_params_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_CHANNEL_IN_USE">SDVR_DRV_ERR_CHANNEL_IN_USE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Defines__SDVR_UI_LS_DOT">SDVR_UI_LS_DOT</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_send_av_frame">sdvr_send_av_frame</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_CHANNEL_NOT_ACTIVE">SDVR_DRV_ERR_CHANNEL_NOT_ACTIVE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Defines__SDVR_UI_LS_SOLID">SDVR_UI_LS_SOLID</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_send_confirmation_callback">sdvr_send_confirmation_callback</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_INVALID_PARAMETER">SDVR_DRV_ERR_INVALID_PARAMETER</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_ALARM_BLIND">SDVR_VIDEO_ALARM_BLIND</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_send_video_output">sdvr_send_video_output</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_IPC_INIT">SDVR_DRV_ERR_IPC_INIT</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_ALARM_DETECTED">SDVR_VIDEO_ALARM_DETECTED</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_sensor_callback">sdvr_sensor_callback</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_MSG_RECV">SDVR_DRV_ERR_MSG_RECV</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_ALARM_LOSS">SDVR_VIDEO_ALARM_LOSS</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_alarm_video_encoder_params">sdvr_set_alarm_video_encoder_params</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_MSG_SEND">SDVR_DRV_ERR_MSG_SEND</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_ALARM_MOTION">SDVR_VIDEO_ALARM_MOTION</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_audio_encoder_channel_params">sdvr_set_audio_encoder_channel_params</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_NO_CHANNELS">SDVR_DRV_ERR_NO_CHANNELS</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_ALARM_NIGHT">SDVR_VIDEO_ALARM_NIGHT</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_av_frame_callback">sdvr_set_av_frame_callback</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_NO_RECV_BUFFERS">SDVR_DRV_ERR_NO_RECV_BUFFERS</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_ALARM_NONE">SDVR_VIDEO_ALARM_NONE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_camera_termination">sdvr_set_camera_termination</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_DRV_ERR_NO_SEND_BUFFERS">SDVR_DRV_ERR_NO_SEND_BUFFERS</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_ENC_H264">SDVR_VIDEO_ENC_H264</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_chan_user_data">sdvr_set_chan_user_data</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ENC_PRIMARY">SDVR_ENC_PRIMARY</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_ENC_JPEG">SDVR_VIDEO_ENC_JPEG</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_channel_default">sdvr_set_channel_default</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ENC_SECONDARY">SDVR_ENC_SECONDARY</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_ENC_MPEG4">SDVR_VIDEO_ENC_MPEG4</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_confirmation_callback">sdvr_set_confirmation_callback</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_AUTH_KEY_LEN">SDVR_ERR_AUTH_KEY_LEN</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_ENC_NONE">SDVR_VIDEO_ENC_NONE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_date_time">sdvr_set_date_time</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_AUTH_KEY_MISSING">SDVR_ERR_AUTH_KEY_MISSING</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_CIF">SDVR_VIDEO_RES_DECIMATION_CIF</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_decoder_size">sdvr_set_decoder_size</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_BOARD_CLOSED">SDVR_ERR_BOARD_CLOSED</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_CLASSIC_2CIF">SDVR_VIDEO_RES_DECIMATION_CLASSIC_2CIF</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_display_debug">sdvr_set_display_debug</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_BOARD_CONNECTED">SDVR_ERR_BOARD_CONNECTED</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_CLASSIC_4CIF">SDVR_VIDEO_RES_DECIMATION_CLASSIC_4CIF</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_gain_mode">sdvr_set_gain_mode</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_BOARD_NOT_CONNECTED">SDVR_ERR_BOARD_NOT_CONNECTED</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_CLASSIC_CIF">SDVR_VIDEO_RES_DECIMATION_CLASSIC_CIF</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_led">sdvr_set_led</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_BUF_NOT_AVAIL">SDVR_ERR_BUF_NOT_AVAIL</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_DCIF">SDVR_VIDEO_RES_DECIMATION_DCIF</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_motion_value_frequency">sdvr_set_motion_value_frequency</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_CALLBACK_FAILED">SDVR_ERR_CALLBACK_FAILED</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_EQUAL">SDVR_VIDEO_RES_DECIMATION_EQUAL</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_regions">sdvr_set_regions</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_CAMERA_IN_REC">SDVR_ERR_CAMERA_IN_REC</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_FOURTH">SDVR_VIDEO_RES_DECIMATION_FOURTH</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_regions_map">sdvr_set_regions_map</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_CHANNEL_CLOSED">SDVR_ERR_CHANNEL_CLOSED</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_HALF">SDVR_VIDEO_RES_DECIMATION_HALF</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_sdk_params">sdvr_set_sdk_params</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_COMMAND_NOT_SUPPORTED">SDVR_ERR_COMMAND_NOT_SUPPORTED</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_NONE">SDVR_VIDEO_RES_DECIMATION_NONE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_sensor_callback">sdvr_set_sensor_callback</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_DBG_FILE">SDVR_ERR_DBG_FILE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_QCIF">SDVR_VIDEO_RES_DECIMATION_QCIF</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_signals_callback">sdvr_set_signals_callback</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_DECODER_NOT_ENABLED">SDVR_ERR_DECODER_NOT_ENABLED</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_RES_DECIMATION_SIXTEENTH">SDVR_VIDEO_RES_DECIMATION_SIXTEENTH</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_smo_grid">sdvr_set_smo_grid</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_ENCODER_NOT_DISABLED">SDVR_ERR_ENCODER_NOT_DISABLED</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_176x112">SDVR_VIDEO_SIZE_176x112</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_smo_grid_ex">sdvr_set_smo_grid_ex</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_ENCODER_NOT_ENABLED">SDVR_ERR_ENCODER_NOT_ENABLED</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_176x144">SDVR_VIDEO_SIZE_176x144</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_video_alarm_callback">sdvr_set_video_alarm_callback</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_FAILED_ADD_AUDIO_TRACK">SDVR_ERR_FAILED_ADD_AUDIO_TRACK</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_352x240">SDVR_VIDEO_SIZE_352x240</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_video_encoder_channel_params">sdvr_set_video_encoder_channel_params</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_FAILED_ADD_VIDEO_TRACK">SDVR_ERR_FAILED_ADD_VIDEO_TRACK</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_352x288">SDVR_VIDEO_SIZE_352x288</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_video_in_params">sdvr_set_video_in_params</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_FONT_ID">SDVR_ERR_FONT_ID</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_528x320">SDVR_VIDEO_SIZE_528x320</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_watchdog_state">sdvr_set_watchdog_state</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INTERNAL">SDVR_ERR_INTERNAL</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_528x384">SDVR_VIDEO_SIZE_528x384</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_watchdog_state_ex">sdvr_set_watchdog_state_ex</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INVALID_ARG">SDVR_ERR_INVALID_ARG</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_704x240">SDVR_VIDEO_SIZE_704x240</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_set_yuv_format">sdvr_set_yuv_format</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INVALID_BITRATE">SDVR_ERR_INVALID_BITRATE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_704x288">SDVR_VIDEO_SIZE_704x288</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_signal_info_t">sdvr_signal_info_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INVALID_BITRATE_CONTROL">SDVR_ERR_INVALID_BITRATE_CONTROL</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_704x480">SDVR_VIDEO_SIZE_704x480</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_signals_callback">sdvr_signals_callback</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INVALID_BOARD">SDVR_ERR_INVALID_BOARD</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_704x576">SDVR_VIDEO_SIZE_704x576</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_signals_type_e">sdvr_signals_type_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INVALID_CHANNEL">SDVR_ERR_INVALID_CHANNEL</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_720x240">SDVR_VIDEO_SIZE_720x240</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_smo_attribute_t">sdvr_smo_attribute_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INVALID_CHAN_HANDLE">SDVR_ERR_INVALID_CHAN_HANDLE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_720x288">SDVR_VIDEO_SIZE_720x288</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_smo_capabilities_e">sdvr_smo_capabilities_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INVALID_FPS">SDVR_ERR_INVALID_FPS</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_720x480">SDVR_VIDEO_SIZE_720x480</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_smo_grid_t">sdvr_smo_grid_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INVALID_FRAME_TYPE">SDVR_ERR_INVALID_FRAME_TYPE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_SIZE_720x576">SDVR_VIDEO_SIZE_720x576</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_smo_osd_text_config">sdvr_smo_osd_text_config</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INVALID_GOP">SDVR_ERR_INVALID_GOP</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_STD_2CIF_NTSC">SDVR_VIDEO_STD_2CIF_NTSC</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_smo_osd_text_show">sdvr_smo_osd_text_show</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INVALID_HANDLE">SDVR_ERR_INVALID_HANDLE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_STD_2CIF_PAL">SDVR_VIDEO_STD_2CIF_PAL</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_start_recording">sdvr_start_recording</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INVALID_OSD_ID">SDVR_ERR_INVALID_OSD_ID</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_STD_4CIF_NTSC">SDVR_VIDEO_STD_4CIF_NTSC</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_start_video_output">sdvr_start_video_output</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INVALID_QUALITY">SDVR_ERR_INVALID_QUALITY</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_STD_4CIF_PAL">SDVR_VIDEO_STD_4CIF_PAL</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_stop_recording">sdvr_stop_recording</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INVALID_REGION">SDVR_ERR_INVALID_REGION</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_STD_CIF_NTSC">SDVR_VIDEO_STD_CIF_NTSC</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_stop_video_output">sdvr_stop_video_output</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_INVALID_RESOLUTION">SDVR_ERR_INVALID_RESOLUTION</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_STD_CIF_PAL">SDVR_VIDEO_STD_CIF_PAL</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_stream_raw_audio">sdvr_stream_raw_audio</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_IN_STREAMING">SDVR_ERR_IN_STREAMING</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_STD_D1_NTSC">SDVR_VIDEO_STD_D1_NTSC</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_stream_raw_video">sdvr_stream_raw_video</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_LOAD_FIRMWARE">SDVR_ERR_LOAD_FIRMWARE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_STD_D1_PAL">SDVR_VIDEO_STD_D1_PAL</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_sub_encoders_e">sdvr_sub_encoders_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_MAX_REGIONS">SDVR_ERR_MAX_REGIONS</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_STD_NONE">SDVR_VIDEO_STD_NONE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_term_e">sdvr_term_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NOBUF">SDVR_ERR_NOBUF</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_STD_QCIF_NTSC">SDVR_VIDEO_STD_QCIF_NTSC</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_trigger_relay">sdvr_trigger_relay</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NONE">SDVR_ERR_NONE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VIDEO_STD_QCIF_PAL">SDVR_VIDEO_STD_QCIF_PAL</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_clear_yuv">sdvr_ui_clear_yuv</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NO_AFRAME">SDVR_ERR_NO_AFRAME</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VPP_MODE_ANALYTICS">SDVR_VPP_MODE_ANALYTICS</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_close">sdvr_ui_close</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NO_DVR_BOARD">SDVR_ERR_NO_DVR_BOARD</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_VPP_MODE_SLATERAL">SDVR_VPP_MODE_SLATERAL</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Types__sdvr_ui_color_key_t">sdvr_ui_color_key_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_NO_VFRAME">SDVR_ERR_NO_VFRAME</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__SMO_ENABLE_ERR">SMO_ENABLE_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_draw_frame">sdvr_ui_draw_frame</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_ODD_SMO_COORDINATES">SDVR_ERR_ODD_SMO_COORDINATES</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__SPI_TEST_COMPARE_ERR">SPI_TEST_COMPARE_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_draw_yuv">sdvr_ui_draw_yuv</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_OPEN_REC_FILE">SDVR_ERR_OPEN_REC_FILE</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__SPI_TEST_ERASE_ERR">SPI_TEST_ERASE_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Types__sdvr_ui_hwnd_t">sdvr_ui_hwnd_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_OSD_FONT_FILE">SDVR_ERR_OSD_FONT_FILE</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__SPI_TEST_MAINT_ERR">SPI_TEST_MAINT_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_init">sdvr_ui_init</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_OSD_LENGTH">SDVR_ERR_OSD_LENGTH</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__SPI_TEST_MISC_ERR">SPI_TEST_MISC_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Types__sdvr_ui_preview_cb">sdvr_ui_preview_cb</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_OUT_OF_MEMORY">SDVR_ERR_OUT_OF_MEMORY</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__SPI_TEST_PROG_ERR">SPI_TEST_PROG_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_refresh">sdvr_ui_refresh</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_SDK_BUF_EXCEEDED">SDVR_ERR_SDK_BUF_EXCEEDED</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__SPI_TEST_READ_ERR">SPI_TEST_READ_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Types__sdvr_ui_region_t">sdvr_ui_region_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_SDK_NO_FRAME_BUF">SDVR_ERR_SDK_NO_FRAME_BUF</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__SPI_TEST_UNLOCK_ERR">SPI_TEST_UNLOCK_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_set_key_color">sdvr_ui_set_key_color</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_SMO_PORT_NUM">SDVR_ERR_SMO_PORT_NUM</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_start_of_file">Stretch</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_set_preview_callback">sdvr_ui_set_preview_callback</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Types__SDVR_ERR_UI_CHANNEL_NOT_START">SDVR_ERR_UI_CHANNEL_NOT_START</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_add_region">sdvr_add_region</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_set_yuv_buffer">sdvr_ui_set_yuv_buffer</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Types__SDVR_ERR_UI_DRAWINFO_FULL">SDVR_ERR_UI_DRAWINFO_FULL</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_aenc_e">sdvr_aenc_e</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_start_video_preview">sdvr_ui_start_video_preview</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Types__SDVR_ERR_UI_DRAW_YUV">SDVR_ERR_UI_DRAW_YUV</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_alarm_video_enc_params_t">sdvr_alarm_video_enc_params_t</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_stop_video_preview">sdvr_ui_stop_video_preview</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Types__SDVR_ERR_UI_INIT">SDVR_ERR_UI_INIT</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_alloc_av_buffer">sdvr_alloc_av_buffer</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Routines__sdvr_ui_version">sdvr_ui_version</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Types__SDVR_ERR_UI_INVALID_PARAM">SDVR_ERR_UI_INVALID_PARAM</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_alloc_av_buffer_wait">sdvr_alloc_av_buffer_wait</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_upgrade_firmware">sdvr_upgrade_firmware</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Types__SDVR_ERR_UI_INVALID_YUV_BUF">SDVR_ERR_UI_INVALID_YUV_BUF</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_audio_enc_chan_params_t">sdvr_audio_enc_chan_params_t</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_venc_e">sdvr_venc_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Types__SDVR_ERR_UI_MAX_PREVIEW_REGIONS">SDVR_ERR_UI_MAX_PREVIEW_REGIONS</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_av_buf_payload">sdvr_av_buf_payload</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_video_alarm_callback">sdvr_video_alarm_callback</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Types__SDVR_ERR_UI_MEMORY">SDVR_ERR_UI_MEMORY</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_av_buf_sequence">sdvr_av_buf_sequence</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_video_alarm_e">sdvr_video_alarm_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Types__SDVR_ERR_UI_NO_BUFFER">SDVR_ERR_UI_NO_BUFFER</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_av_buf_video_dimensions">sdvr_av_buf_video_dimensions</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_video_enc_chan_params_t">sdvr_video_enc_chan_params_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Types__SDVR_ERR_UI_NO_INIT">SDVR_ERR_UI_NO_INIT</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_av_buf_yuv_payload">sdvr_av_buf_yuv_payload</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_video_res_decimation_e">sdvr_video_res_decimation_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Types__SDVR_ERR_UI_SET_BUFFER">SDVR_ERR_UI_SET_BUFFER</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_av_buffer_t">sdvr_av_buffer_t</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_video_size_e">sdvr_video_size_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_ui_sdk_html_Types__SDVR_ERR_UI_VIDEO_SIZE">SDVR_ERR_UI_VIDEO_SIZE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_av_frame_callback">sdvr_av_frame_callback</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_video_std_e">sdvr_video_std_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_UNSUPPORTED_FIRMWARE">SDVR_ERR_UNSUPPORTED_FIRMWARE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_blind_detection_t">sdvr_blind_detection_t</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_vpp_mode_e">sdvr_vpp_mode_e</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_WRONG_CHANNEL_TYPE">SDVR_ERR_WRONG_CHANNEL_TYPE</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_board_attrib_t">sdvr_board_attrib_t</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_write_ioctl">sdvr_write_ioctl</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_ERR_WRONG_DRIVER_VERSION">SDVR_ERR_WRONG_DRIVER_VERSION</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_board_config_t">sdvr_board_config_t</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_write_uart">sdvr_write_uart</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_AUDIO_ENCODED">SDVR_FRAME_AUDIO_ENCODED</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_board_connect">sdvr_board_connect</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_yuv_buffer_t">sdvr_yuv_buffer_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_G711">SDVR_FRAME_G711</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_board_disconnect">sdvr_board_disconnect</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sx_bool">sx_bool</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_H264_B">SDVR_FRAME_H264_B</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_board_reset">sdvr_board_reset</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sx_int16">sx_int16</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_H264_I">SDVR_FRAME_H264_I</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_br_control_e">sdvr_br_control_e</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sx_int32">sx_int32</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_H264_IDR">SDVR_FRAME_H264_IDR</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_chan_def_t">sdvr_chan_def_t</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sx_int64">sx_int64</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_H264_P">SDVR_FRAME_H264_P</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_chan_handle_t">sdvr_chan_handle_t</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sx_int8">sx_int8</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_H264_PPS">SDVR_FRAME_H264_PPS</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_chan_type_e">sdvr_chan_type_e</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sx_uint16">sx_uint16</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_H264_SPS">SDVR_FRAME_H264_SPS</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_change_region">sdvr_change_region</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sx_uint32">sx_uint32</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_JPEG">SDVR_FRAME_JPEG</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sdvr_chip_rev_e">sdvr_chip_rev_e</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sx_uint64">sx_uint64</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_MOTION_VALUES">SDVR_FRAME_MOTION_VALUES</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_config_sensors">sdvr_config_sensors</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__sx_uint8">sx_uint8</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_MPEG4_B">SDVR_FRAME_MPEG4_B</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_create_chan">sdvr_create_chan</A></NOBR></TD>
<TD></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__SDVR_FRAME_MPEG4_I">SDVR_FRAME_MPEG4_I</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Routines__sdvr_destroy_chan">sdvr_destroy_chan</A></NOBR></TD>
<TD></TD>
</TR>
</TABLE>
<H3><A NAME="index_html_cdoc_xref_T"></A>T</H3>
<TABLE class="index" width="100%">
<TR>
<TD width="33%"><NOBR><A HREF="#dvr_common_html_Defines__TW2815_REG_TEST_ERR">TW2815_REG_TEST_ERR</A></NOBR></TD>
<TD width="33%"><NOBR><A HREF="#dvr_common_html_Defines__TWI_EEPROM_TEST_INIT_ERR">TWI_EEPROM_TEST_INIT_ERR</A></NOBR></TD>
<TD width="33%"><NOBR><A HREF="#dvr_common_html_Defines__TWI_EEPROM_TEST_WRITE_ERR">TWI_EEPROM_TEST_WRITE_ERR</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__TW2864_REG_TEST_ERR">TW2864_REG_TEST_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__TWI_EEPROM_TEST_READ_ERR">TWI_EEPROM_TEST_READ_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Types__time_t">time_t</A></NOBR></TD>
</TR>
<TR>
<TD><NOBR><A HREF="#dvr_common_html_Defines__TWI_EEPROM_TEST_COMPARE_ERR">TWI_EEPROM_TEST_COMPARE_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#dvr_common_html_Defines__TWI_EEPROM_TEST_WP_COMPARE_ERR">TWI_EEPROM_TEST_WP_COMPARE_ERR</A></NOBR></TD>
<TD><NOBR><A HREF="#sdvr_sdk_html_Defines__true">true</A></NOBR></TD>
</TR>
</TABLE>
<H3><A NAME="index_html_cdoc_xref_V"></A>V</H3>
<TABLE class="index" width="100%">
<TR>
<TD width="33%"><NOBR><A HREF="#dvr_common_html_Defines__VOUT_ENABLE_ERR">VOUT_ENABLE_ERR</A></NOBR></TD>
<TD width="33%"></TD>
<TD width="33%"></TD>
</TR>
</TABLE>
</BODY>
</HTML>
